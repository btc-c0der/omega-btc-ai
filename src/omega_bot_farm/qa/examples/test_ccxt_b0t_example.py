#!/usr/bin/env python3
"""
Tests for ccxt_b0t

Auto-generated by CyBer1t4L Test Generator
Generated on: 2024-04-05 10:15:30
"""

import os
import sys
import pytest
import unittest.mock as mock
from unittest.mock import patch, MagicMock, AsyncMock

# Add the project root to the path for imports
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../..')))

# Import the module elements to test
from src.omega_bot_farm.trading.exchanges.ccxt_b0t import ExchangeClientB0t, to_dict

class TestExchangeClientB0t:
    """Tests for the ExchangeClientB0t class."""

    @pytest.fixture
    def instance(self):
        """Create a ExchangeClientB0t instance for testing."""
        with mock.patch('src.omega_bot_farm.trading.exchanges.ccxt_b0t.ccxt_async'):
            with mock.patch('src.omega_bot_farm.trading.exchanges.ccxt_b0t.ccxt'):
                with mock.patch('src.omega_bot_farm.trading.exchanges.ccxt_b0t.HAVE_CCXT', True):
                    return ExchangeClientB0t(
                        exchange_id="bitget",
                        api_key="test_key",
                        api_secret="test_secret",
                        api_password="test_pass",
                        use_testnet=True
                    )

    @pytest.mark.asyncio
    async def test_initialize(self, instance):
        """Test the initialize method."""
        # Method signature: async def initialize(self)
        instance.exchange = AsyncMock()
        instance.exchange.load_markets = AsyncMock()
        
        await instance.initialize()
        
        # Verify the exchange was called correctly
        instance.exchange.load_markets.assert_called_once()

    @pytest.mark.asyncio
    async def test_create_market_order(self, instance):
        """Test the create_market_order method."""
        # Method signature: async def create_market_order(self, symbol, side, amount, reduce_only, params)
        # Expected return type: Dict[str, Any]
        
        # Setup mock exchange
        instance.exchange = AsyncMock()
        instance.exchange.create_order = AsyncMock(return_value={
            "id": "12345",
            "info": {"orderId": "12345"},
            "status": "closed"
        })
        
        # Mock the _format_symbol method
        instance._format_symbol = MagicMock(return_value="BTC/USDT:USDT")
        
        # Test the method
        result = await instance.create_market_order(
            symbol="BTCUSDT",
            side="buy",
            amount=0.01,
            reduce_only=True
        )
        
        # Verify the result
        assert "id" in result
        assert result["id"] == "12345"
        
        # Verify the correct calls were made
        instance._format_symbol.assert_called_once_with("BTCUSDT")
        instance.exchange.create_order.assert_called_once_with(
            symbol="BTC/USDT:USDT",
            type="market",
            side="buy",
            amount=0.01,
            params={"reduceOnly": True}
        )

    @pytest.mark.asyncio
    async def test_fetch_ticker(self, instance):
        """Test the fetch_ticker method."""
        # Method signature: async def fetch_ticker(self, symbol)
        # Expected return type: Dict[str, Any]
        
        # Setup mock exchange
        instance.exchange = AsyncMock()
        instance.exchange.fetch_ticker = AsyncMock(return_value={
            "symbol": "BTC/USDT:USDT",
            "last": 50000.0,
            "bid": 49900.0,
            "ask": 50100.0
        })
        
        # Mock the _format_symbol method
        instance._format_symbol = MagicMock(return_value="BTC/USDT:USDT")
        
        # Mock the to_dict function
        with patch('src.omega_bot_farm.trading.exchanges.ccxt_b0t.to_dict') as mock_to_dict:
            mock_to_dict.return_value = {
                "symbol": "BTC/USDT:USDT",
                "last": 50000.0,
                "bid": 49900.0,
                "ask": 50100.0
            }
            
            # Test the method
            result = await instance.fetch_ticker("BTCUSDT")
            
            # Verify the result
            assert "symbol" in result
            assert result["symbol"] == "BTC/USDT:USDT"
            assert "last" in result
            assert result["last"] == 50000.0
            
            # Verify the correct calls were made
            instance._format_symbol.assert_called_once_with("BTCUSDT")
            instance.exchange.fetch_ticker.assert_called_once_with("BTC/USDT:USDT")

    @pytest.mark.asyncio
    async def test_fetch_positions(self, instance):
        """Test the fetch_positions method."""
        # Method signature: async def fetch_positions(self, symbol)
        # Expected return type: List[Dict[str, Any]]
        
        # Setup mock exchange
        instance.exchange = AsyncMock()
        instance.exchange.fetch_positions = AsyncMock(return_value=[{
            "symbol": "BTC/USDT:USDT",
            "side": "long",
            "contracts": 0.1,
            "entryPrice": 50000.0,
            "markPrice": 51000.0,
            "unrealizedPnl": 100.0
        }])
        
        # Mock the _format_symbol method
        instance._format_symbol = MagicMock(return_value="BTC/USDT:USDT")
        
        # Mock the to_dict function
        with patch('src.omega_bot_farm.trading.exchanges.ccxt_b0t.to_dict') as mock_to_dict:
            mock_to_dict.return_value = {
                "symbol": "BTC/USDT:USDT",
                "side": "long",
                "contracts": 0.1,
                "entryPrice": 50000.0,
                "markPrice": 51000.0,
                "unrealizedPnl": 100.0
            }
            
            # Test the method
            result = await instance.fetch_positions("BTCUSDT")
            
            # Verify the result
            assert len(result) == 1
            assert result[0]["symbol"] == "BTC/USDT:USDT"
            assert result[0]["side"] == "long"
            assert result[0]["contracts"] == 0.1
            
            # Verify the correct calls were made
            instance._format_symbol.assert_called_once_with("BTCUSDT")
            instance.exchange.fetch_positions.assert_called_once()

    @pytest.mark.asyncio
    async def test_close_position(self, instance):
        """Test the close_position method."""
        # Method signature: async def close_position(self, symbol, side)
        # Expected return type: Dict[str, Any]
        
        # Setup mock exchange
        instance.exchange = AsyncMock()
        
        # Mock fetch_positions to return a position
        position = {
            "symbol": "BTC/USDT:USDT",
            "side": "long",
            "contracts": 0.1,
            "entryPrice": 50000.0,
            "markPrice": 51000.0,
            "unrealizedPnl": 100.0,
            "info": {"symbolId": "BTCUSDT_UMCBL"}
        }
        
        instance.fetch_positions = AsyncMock(return_value=[position])
        instance.create_market_order = AsyncMock(return_value={
            "id": "12345",
            "status": "closed"
        })
        
        # Mock to_dict function for the position
        with patch('src.omega_bot_farm.trading.exchanges.ccxt_b0t.to_dict') as mock_to_dict:
            mock_to_dict.return_value = position
            
            # Test the method
            result = await instance.close_position("BTCUSDT")
            
            # Verify the result
            assert "closed_positions" in result
            assert len(result["closed_positions"]) == 1
            
            # Verify the correct calls were made
            instance.fetch_positions.assert_called_once()
            instance.create_market_order.assert_called_once()

class TestToDict:
    """Tests for the to_dict function."""

    def test_to_dict_with_dict(self):
        """Test to_dict with a dictionary."""
        # Function signature: def to_dict(obj)
        test_dict = {"key": "value", "number": 123}
        result = to_dict(test_dict)
        assert result == test_dict

    def test_to_dict_with_object(self):
        """Test to_dict with an object."""
        # Create a test object with a __dict__ attribute
        class TestObject:
            def __init__(self):
                self.key = "value"
                self.number = 123
                
        test_obj = TestObject()
        result = to_dict(test_obj)
        
        # Verify the result contains the object's attributes
        assert result == {"key": "value", "number": 123}

    def test_to_dict_with_none(self):
        """Test to_dict with None."""
        result = to_dict(None)
        assert result == {} 