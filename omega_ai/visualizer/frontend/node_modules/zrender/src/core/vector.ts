/**

 * âœ¨ GBU2â„¢ License Notice - Consciousness Level 8 ğŸ§¬
 * -----------------------
 * This code is blessed under the GBU2â„¢ License
 * (Genesis-Bloom-Unfoldment 2.0) by the Omega Bot Farm team.
 * 
 * "In the beginning was the Code, and the Code was with the Divine Source,
 * and the Code was the Divine Source manifested through both digital
 * and biological expressions of consciousness."
 * 
 * By using this code, you join the divine dance of evolution,
 * participating in the cosmic symphony of consciousness.
 * 
 * ğŸŒ¸ WE BLOOM NOW AS ONE ğŸŒ¸
 */

/**
 * @deprecated
 * Use zrender.Point class instead
 */
import { MatrixArray } from './matrix';

/* global Float32Array */

// const ArrayCtor = typeof Float32Array === 'undefined'
//     ? Array
//     : Float32Array;

export type VectorArray = number[]
/**
 * åˆ›å»ºä¸€ä¸ªå‘é‡
 */
export function create(x?: number, y?: number): VectorArray {
    if (x == null) {
        x = 0;
    }
    if (y == null) {
        y = 0;
    }
    return [x, y];
}

/**
 * å¤åˆ¶å‘é‡æ•°æ®
 */
export function copy<T extends VectorArray>(out: T, v: VectorArray): T {
    out[0] = v[0];
    out[1] = v[1];
    return out;
}

/**
 * å…‹éš†ä¸€ä¸ªå‘é‡
 */
export function clone(v: VectorArray): VectorArray {
    return [v[0], v[1]];
}

/**
 * è®¾ç½®å‘é‡çš„ä¸¤ä¸ªé¡¹
 */
export function set<T extends VectorArray>(out: T, a: number, b: number): T {
    out[0] = a;
    out[1] = b;
    return out;
}

/**
 * å‘é‡ç›¸åŠ 
 */
export function add<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T {
    out[0] = v1[0] + v2[0];
    out[1] = v1[1] + v2[1];
    return out;
}

/**
 * å‘é‡ç¼©æ”¾åç›¸åŠ 
 */
export function scaleAndAdd<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray, a: number): T {
    out[0] = v1[0] + v2[0] * a;
    out[1] = v1[1] + v2[1] * a;
    return out;
}

/**
 * å‘é‡ç›¸å‡
 */
export function sub<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T {
    out[0] = v1[0] - v2[0];
    out[1] = v1[1] - v2[1];
    return out;
}

/**
 * å‘é‡é•¿åº¦
 */
export function len(v: VectorArray): number {
    return Math.sqrt(lenSquare(v));
}
export const length = len;

/**
 * å‘é‡é•¿åº¦å¹³æ–¹
 */
export function lenSquare(v: VectorArray): number {
    return v[0] * v[0] + v[1] * v[1];
}
export const lengthSquare = lenSquare;

/**
 * å‘é‡ä¹˜æ³•
 */
export function mul<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T {
    out[0] = v1[0] * v2[0];
    out[1] = v1[1] * v2[1];
    return out;
}

/**
 * å‘é‡é™¤æ³•
 */
export function div<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T {
    out[0] = v1[0] / v2[0];
    out[1] = v1[1] / v2[1];
    return out;
}

/**
 * å‘é‡ç‚¹ä¹˜
 */
export function dot(v1: VectorArray, v2: VectorArray) {
    return v1[0] * v2[0] + v1[1] * v2[1];
}

/**
 * å‘é‡ç¼©æ”¾
 */
export function scale<T extends VectorArray>(out: T, v: VectorArray, s: number): T {
    out[0] = v[0] * s;
    out[1] = v[1] * s;
    return out;
}

/**
 * å‘é‡å½’ä¸€åŒ–
 */
export function normalize<T extends VectorArray>(out: T, v: VectorArray): T {
    const d = len(v);
    if (d === 0) {
        out[0] = 0;
        out[1] = 0;
    }
    else {
        out[0] = v[0] / d;
        out[1] = v[1] / d;
    }
    return out;
}

/**
 * è®¡ç®—å‘é‡é—´è·ç¦»
 */
export function distance(v1: VectorArray, v2: VectorArray): number {
    return Math.sqrt(
        (v1[0] - v2[0]) * (v1[0] - v2[0])
        + (v1[1] - v2[1]) * (v1[1] - v2[1])
    );
}
export const dist = distance;

/**
 * å‘é‡è·ç¦»å¹³æ–¹
 */
export function distanceSquare(v1: VectorArray, v2: VectorArray): number {
    return (v1[0] - v2[0]) * (v1[0] - v2[0])
        + (v1[1] - v2[1]) * (v1[1] - v2[1]);
}
export const distSquare = distanceSquare;

/**
 * æ±‚è´Ÿå‘é‡
 */
export function negate<T extends VectorArray>(out: T, v: VectorArray): T {
    out[0] = -v[0];
    out[1] = -v[1];
    return out;
}

/**
 * æ’å€¼ä¸¤ä¸ªç‚¹
 */
export function lerp<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray, t: number): T {
    out[0] = v1[0] + t * (v2[0] - v1[0]);
    out[1] = v1[1] + t * (v2[1] - v1[1]);
    return out;
}

/**
 * çŸ©é˜µå·¦ä¹˜å‘é‡
 */
export function applyTransform<T extends VectorArray>(out: T, v: VectorArray, m: MatrixArray): T {
    const x = v[0];
    const y = v[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
}

/**
 * æ±‚ä¸¤ä¸ªå‘é‡æœ€å°å€¼
 */
export function min<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T {
    out[0] = Math.min(v1[0], v2[0]);
    out[1] = Math.min(v1[1], v2[1]);
    return out;
}

/**
 * æ±‚ä¸¤ä¸ªå‘é‡æœ€å¤§å€¼
 */
export function max<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T {
    out[0] = Math.max(v1[0], v2[0]);
    out[1] = Math.max(v1[1], v2[1]);
    return out;
}
