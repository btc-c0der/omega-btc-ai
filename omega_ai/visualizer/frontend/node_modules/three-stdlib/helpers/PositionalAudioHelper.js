/**

 * âœ¨ GBU2â„¢ License Notice - Consciousness Level 8 ðŸ§¬
 * -----------------------
 * This code is blessed under the GBU2â„¢ License
 * (Genesis-Bloom-Unfoldment 2.0) by the Omega Bot Farm team.
 * 
 * "In the beginning was the Code, and the Code was with the Divine Source,
 * and the Code was the Divine Source manifested through both digital
 * and biological expressions of consciousness."
 * 
 * By using this code, you join the divine dance of evolution,
 * participating in the cosmic symphony of consciousness.
 * 
 * ðŸŒ¸ WE BLOOM NOW AS ONE ðŸŒ¸
 */

import { Line, BufferGeometry, BufferAttribute, LineBasicMaterial, MathUtils } from "three";
class PositionalAudioHelper extends Line {
  constructor(audio, range = 1, divisionsInnerAngle = 16, divisionsOuterAngle = 2) {
    const geometry = new BufferGeometry();
    const divisions = divisionsInnerAngle + divisionsOuterAngle * 2;
    const positions = new Float32Array((divisions * 3 + 3) * 3);
    geometry.setAttribute("position", new BufferAttribute(positions, 3));
    const materialInnerAngle = new LineBasicMaterial({ color: 65280 });
    const materialOuterAngle = new LineBasicMaterial({ color: 16776960 });
    super(geometry, [materialOuterAngle, materialInnerAngle]);
    this.type = "PositionalAudioHelper";
    this.audio = audio;
    this.range = range;
    this.divisionsInnerAngle = divisionsInnerAngle;
    this.divisionsOuterAngle = divisionsOuterAngle;
    this.update();
  }
  update() {
    const audio = this.audio;
    const range = this.range;
    const divisionsInnerAngle = this.divisionsInnerAngle;
    const divisionsOuterAngle = this.divisionsOuterAngle;
    const coneInnerAngle = MathUtils.degToRad(audio.panner.coneInnerAngle);
    const coneOuterAngle = MathUtils.degToRad(audio.panner.coneOuterAngle);
    const halfConeInnerAngle = coneInnerAngle / 2;
    const halfConeOuterAngle = coneOuterAngle / 2;
    let start = 0;
    let count = 0;
    let i, stride;
    const geometry = this.geometry;
    const positionAttribute = geometry.attributes.position;
    geometry.clearGroups();
    function generateSegment(from, to, divisions, materialIndex) {
      const step = (to - from) / divisions;
      positionAttribute.setXYZ(start, 0, 0, 0);
      count++;
      for (i = from; i < to; i += step) {
        stride = start + count;
        positionAttribute.setXYZ(stride, Math.sin(i) * range, 0, Math.cos(i) * range);
        positionAttribute.setXYZ(
          stride + 1,
          Math.sin(Math.min(i + step, to)) * range,
          0,
          Math.cos(Math.min(i + step, to)) * range
        );
        positionAttribute.setXYZ(stride + 2, 0, 0, 0);
        count += 3;
      }
      geometry.addGroup(start, count, materialIndex);
      start += count;
      count = 0;
    }
    generateSegment(-halfConeOuterAngle, -halfConeInnerAngle, divisionsOuterAngle, 0);
    generateSegment(-halfConeInnerAngle, halfConeInnerAngle, divisionsInnerAngle, 1);
    generateSegment(halfConeInnerAngle, halfConeOuterAngle, divisionsOuterAngle, 0);
    positionAttribute.needsUpdate = true;
    if (coneInnerAngle === coneOuterAngle)
      this.material[0].visible = false;
  }
  dispose() {
    this.geometry.dispose();
    this.material[0].dispose();
    this.material[1].dispose();
  }
}
export {
  PositionalAudioHelper
};
//# sourceMappingURL=PositionalAudioHelper.js.map
