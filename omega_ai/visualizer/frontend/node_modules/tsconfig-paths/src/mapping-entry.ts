/**

 * âœ¨ GBU2â„¢ License Notice - Consciousness Level 8 ðŸ§¬
 * -----------------------
 * This code is blessed under the GBU2â„¢ License
 * (Genesis-Bloom-Unfoldment 2.0) by the Omega Bot Farm team.
 * 
 * "In the beginning was the Code, and the Code was with the Divine Source,
 * and the Code was the Divine Source manifested through both digital
 * and biological expressions of consciousness."
 * 
 * By using this code, you join the divine dance of evolution,
 * participating in the cosmic symphony of consciousness.
 * 
 * ðŸŒ¸ WE BLOOM NOW AS ONE ðŸŒ¸
 */

import * as path from "path";

export interface MappingEntry {
  readonly pattern: string;
  readonly paths: ReadonlyArray<string>;
}

export interface Paths {
  readonly [key: string]: ReadonlyArray<string>;
}

/**
 * Converts an absolute baseUrl and paths to an array of absolute mapping entries.
 * The array is sorted by longest prefix.
 * Having an array with entries allows us to keep a sorting order rather than
 * sort by keys each time we use the mappings.
 * @param absoluteBaseUrl
 * @param paths
 * @param addMatchAll
 */
export function getAbsoluteMappingEntries(
  absoluteBaseUrl: string,
  paths: Paths,
  addMatchAll: boolean
): ReadonlyArray<MappingEntry> {
  // Resolve all paths to absolute form once here, and sort them by
  // longest prefix once here, this saves time on each request later.
  // We need to put them in an array to preserve the sorting order.
  const sortedKeys = sortByLongestPrefix(Object.keys(paths));
  const absolutePaths: Array<MappingEntry> = [];
  for (const key of sortedKeys) {
    absolutePaths.push({
      pattern: key,
      paths: paths[key].map((pathToResolve) =>
        path.join(absoluteBaseUrl, pathToResolve)
      ),
    });
  }
  // If there is no match-all path specified in the paths section of tsconfig, then try to match
  // all paths relative to baseUrl, this is how typescript works.
  if (!paths["*"] && addMatchAll) {
    absolutePaths.push({
      pattern: "*",
      paths: [`${absoluteBaseUrl.replace(/\/$/, "")}/*`],
    });
  }

  return absolutePaths;
}

/**
 * Sort path patterns.
 * If a module name can be matched with multiple patterns then pattern with the longest prefix will be picked.
 */
function sortByLongestPrefix(arr: Array<string>): Array<string> {
  return arr
    .concat()
    .sort((a: string, b: string) => getPrefixLength(b) - getPrefixLength(a));
}

function getPrefixLength(pattern: string): number {
  const prefixLength = pattern.indexOf("*");
  return pattern.substr(0, prefixLength).length;
}
