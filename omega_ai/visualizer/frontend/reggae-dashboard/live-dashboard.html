<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OMEGA BTC AI - Live Reggae Dashboard</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --green-color: #00B52D;
            --yellow-color: #FFD700;
            --red-color: #FF3D00;
            --bg-color: #121212;
            --card-bg: #1E1E1E;
            --text-color: #E0E0E0;
            --muted-color: #AAAAAA;
            --border-color: rgba(255, 215, 0, 0.2);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Courier New', monospace;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            line-height: 1.6;
            background-image:
                radial-gradient(circle at 10% 20%, rgba(0, 181, 45, 0.05) 0%, transparent 20%),
                radial-gradient(circle at 90% 30%, rgba(255, 215, 0, 0.05) 0%, transparent 20%),
                radial-gradient(circle at 50% 70%, rgba(255, 61, 0, 0.05) 0%, transparent 20%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background-color: var(--card-bg);
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }

        .header h1 {
            color: var(--yellow-color);
            margin: 0;
            font-size: 1.8rem;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header h1 i {
            font-size: 1.6rem;
        }

        .price-ticker {
            display: flex;
            align-items: center;
            background: rgba(255, 215, 0, 0.1);
            padding: 5px 15px;
            border-radius: 20px;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
        }

        .btc-price {
            font-weight: bold;
            color: var(--yellow-color);
            margin-right: 10px;
            font-size: 1.3rem;
        }

        .price-change {
            border-radius: 4px;
            padding: 2px 8px;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .price-change.positive {
            background-color: rgba(0, 181, 45, 0.2);
            color: var(--green-color);
        }

        .price-change.negative {
            background-color: rgba(255, 61, 0, 0.2);
            color: var(--red-color);
        }

        .price-change.neutral {
            background-color: rgba(255, 255, 255, 0.2);
            color: var(--yellow-color);
        }

        .status-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: var(--card-bg);
            padding: 10px 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .status-indicator {
            display: flex;
            align-items: center;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .status-dot.connected {
            background-color: var(--green-color);
            box-shadow: 0 0 10px var(--green-color);
            animation: pulse 2s infinite;
        }

        .status-dot.disconnected {
            background-color: var(--red-color);
            box-shadow: 0 0 10px var(--red-color);
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(0, 181, 45, 0.4);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(0, 181, 45, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(0, 181, 45, 0);
            }
        }

        .data-source {
            background-color: rgba(255, 215, 0, 0.2);
            padding: 5px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            color: var(--yellow-color);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }

        @media (min-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr 1fr;
            }
        }

        .card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .card h2 {
            color: var(--yellow-color);
            margin-top: 0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            font-size: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .card h2 i {
            font-size: 1.2rem;
            margin-right: 8px;
        }

        .card h2 .refresh-time {
            font-size: 0.8rem;
            color: var(--muted-color);
            font-weight: normal;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            border-bottom: 1px dotted rgba(255, 255, 255, 0.1);
            padding-bottom: 8px;
        }

        .label {
            color: var(--muted-color);
        }

        .value {
            font-weight: bold;
        }

        .value.positive {
            color: var(--green-color);
        }

        .value.negative {
            color: var(--red-color);
        }

        .value.neutral {
            color: var(--yellow-color);
        }

        .progress-bar {
            width: 100%;
            background-color: rgba(255, 255, 255, 0.1);
            height: 20px;
            border-radius: 10px;
            margin: 15px 0;
            overflow: hidden;
            position: relative;
        }

        .progress-bar-inner {
            height: 100%;
            border-radius: 10px;
            transition: width 1s ease, background-color 1s ease;
            background-image: linear-gradient(to right, var(--green-color), var(--yellow-color), var(--red-color));
            background-size: 200% 100%;
            animation: gradient-shift 3s ease infinite;
        }

        @keyframes gradient-shift {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        .jah-message {
            background: linear-gradient(to right, rgba(0, 181, 45, 0.2), rgba(255, 221, 0, 0.2), rgba(255, 61, 0, 0.2));
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            color: var(--yellow-color);
            margin-top: 20px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
        }

        .jah-message::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg,
                    transparent,
                    rgba(255, 255, 255, 0.1),
                    transparent);
            animation: shine 2s infinite;
        }

        @keyframes shine {
            100% {
                left: 100%;
            }
        }

        .components-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .component-item {
            background-color: rgba(30, 30, 30, 0.5);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid var(--border-color);
        }

        .component-name {
            font-size: 0.9rem;
            color: var(--muted-color);
            margin-bottom: 5px;
        }

        .component-value {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .component-bar {
            flex-grow: 1;
            height: 5px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin: 0 10px;
            overflow: hidden;
        }

        .component-bar-inner {
            height: 100%;
            background-color: var(--yellow-color);
            border-radius: 3px;
            transition: width 0.5s ease;
        }

        .component-number {
            font-weight: bold;
            color: var(--yellow-color);
            font-size: 0.9rem;
        }

        .component-description {
            font-size: 0.8rem;
            color: var(--text-color);
            margin-top: 5px;
            font-style: italic;
        }

        .footer {
            margin-top: 30px;
            text-align: center;
            color: var(--muted-color);
            font-size: 0.9rem;
            padding: 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .footer-icons {
            display: flex;
            gap: 15px;
            margin-top: 5px;
        }

        .footer-icons i {
            color: var(--yellow-color);
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }

        .footer-icons i:hover {
            transform: scale(1.2);
        }

        .refresh-button {
            background-color: #1c384e;
            color: #bcd4e6;
            border: 1px solid #3a546a;
            border-radius: 4px;
            padding: 8px 12px;
            margin-top: 15px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .refresh-button:hover {
            background-color: #2a4e6c;
        }

        .refresh-button:disabled {
            background-color: #1c2832;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .refresh-button i {
            margin-right: 6px;
        }

        .shake {
            animation: shake 0.5s cubic-bezier(.36, .07, .19, .97) both;
        }

        @keyframes shake {

            10%,
            90% {
                transform: translate3d(-1px, 0, 0);
            }

            20%,
            80% {
                transform: translate3d(2px, 0, 0);
            }

            30%,
            50%,
            70% {
                transform: translate3d(-4px, 0, 0);
            }

            40%,
            60% {
                transform: translate3d(4px, 0, 0);
            }
        }

        .btc-logo {
            font-size: 1.5rem;
            margin-right: 8px;
            color: var(--yellow-color);
        }

        /* Add styles for the license disclaimer */
        .license-disclaimer {
            margin-top: 2rem;
            padding: 1rem;
            border-top: 1px solid rgba(255, 215, 0, 0.1);
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
        }

        .license-disclaimer p {
            margin: 0.5rem 0;
        }

        .license-disclaimer a {
            color: rgba(255, 215, 0, 0.7);
            text-decoration: none;
        }

        .license-disclaimer a:hover {
            color: rgba(255, 215, 0, 1);
            text-decoration: underline;
        }

        .position-flow-viz {
            margin-top: 20px;
            border-top: 1px solid var(--border-color);
            padding-top: 15px;
        }

        .position-flow-viz h3 {
            margin-bottom: 10px;
            color: var(--yellow-color);
            font-size: 1.2rem;
        }

        .position-flow-container {
            width: 100%;
            height: 200px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            border: 1px solid var(--border-color);
            position: relative;
        }

        .position-flow-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--muted-color);
            text-align: center;
            font-size: 0.9rem;
            padding: 0 15px;
        }

        #position-flow-canvas {
            width: 100%;
            height: 100%;
        }

        .target-indicator {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }

        .target-indicator-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .target-indicator-dot.close {
            background-color: var(--yellow-color);
            box-shadow: 0 0 8px var(--yellow-color);
        }

        .target-indicator-dot.very-close {
            background-color: var(--green-color);
            box-shadow: 0 0 8px var(--green-color);
            animation: pulse-target 1.5s infinite;
        }

        .target-indicator-dot.reached {
            background-color: var(--green-color);
            box-shadow: 0 0 12px var(--green-color);
        }

        .target-indicator-text {
            font-size: 0.9rem;
        }

        @keyframes pulse-target {
            0% {
                box-shadow: 0 0 0 0 rgba(0, 181, 45, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(0, 181, 45, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(0, 181, 45, 0);
            }
        }

        .fib-level {
            display: inline-block;
            padding: 2px 10px;
            border-radius: 12px;
            background-color: rgba(255, 215, 0, 0.2);
            color: var(--yellow-color);
            font-size: 0.9rem;
            margin-right: 5px;
        }

        /* Redis Monitor Styles */
        .redis-monitor-card {
            margin-top: 20px;
        }

        .redis-monitor-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 15px;
        }

        .redis-stat {
            flex: 1;
            min-width: 150px;
        }

        .redis-keys-section {
            margin-top: 15px;
        }

        .redis-keys-container {
            max-height: 250px;
            overflow-y: auto;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            padding: 10px;
            margin-top: 10px;
        }

        .redis-keys-list {
            font-family: monospace;
        }

        .redis-namespace {
            margin-top: 8px;
            padding: 4px 8px;
            background-color: rgba(0, 40, 80, 0.3);
            border-radius: 3px;
            border-left: 3px solid #4a90e2;
        }

        .redis-namespace-name {
            color: #5dade2;
            font-weight: bold;
        }

        .redis-namespace-keys {
            padding-left: 10px;
            margin: 5px 0;
        }

        .redis-key-item {
            padding: 3px 8px;
            margin: 2px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
        }

        .redis-key-name {
            color: #bcd4e6;
            font-family: monospace;
            padding-right: 10px;
        }

        .redis-key-detail {
            color: #8899aa;
            font-size: 0.85em;
        }

        .redis-key-error {
            color: #ff6b6b;
            padding: 10px;
        }

        .redis-actions {
            margin-top: 15px;
            text-align: center;
        }

        .refresh-btn {
            background-color: #2c3e50;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .refresh-btn:hover {
            background-color: #3c536b;
        }

        .refresh-btn:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        .positive {
            color: #4caf50;
        }

        .negative {
            color: #f44336;
        }

        .neutral {
            color: #8899aa;
        }

        /* End of Redis Monitor Styles */

        .redis-key-loading {
            color: #8899aa;
            font-style: italic;
            text-align: center;
            padding: 10px;
        }

        .redis-namespace {
            margin-top: 8px;
            padding: 4px 8px;
            background-color: rgba(0, 40, 80, 0.3);
            border-radius: 3px;
            border-left: 3px solid #4a90e2;
        }

        .redis-namespace-name {
            color: #5dade2;
            font-weight: bold;
        }

        .redis-key-item {
            padding: 3px 8px;
            margin: 2px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
        }

        .redis-key-name {
            color: #bcd4e6;
            font-family: monospace;
            padding-right: 10px;
        }

        .redis-key-detail {
            color: #8899aa;
            font-size: 0.85em;
        }

        /* HODL Button Styles */
        .hodl-button {
            background: linear-gradient(to right, rgba(0, 181, 45, 0.8), rgba(255, 215, 0, 0.8), rgba(255, 61, 0, 0.8));
            color: white;
            border: none;
            border-radius: 25px;
            font-weight: bold;
            padding: 10px 20px;
            font-size: 1.1rem;
            margin-top: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .hodl-button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
        }

        .hodl-button:active {
            transform: translateY(1px);
        }

        .hodl-button i {
            font-size: 1.3rem;
        }

        /* BTC Price Popup */
        .btc-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background-color: var(--card-bg);
            border: 2px solid var(--yellow-color);
            border-radius: 15px;
            padding: 25px;
            z-index: 1000;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .btc-popup.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            visibility: visible;
        }

        .btc-popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .btc-popup-title {
            color: var(--yellow-color);
            font-size: 1.8rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .btc-popup-close {
            background: none;
            border: none;
            color: var(--muted-color);
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.3s;
        }

        .btc-popup-close:hover {
            color: var(--red-color);
        }

        .btc-popup-content {
            text-align: center;
        }

        .btc-popup-price {
            font-size: 3rem;
            color: var(--yellow-color);
            margin: 15px 0;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
            font-weight: bold;
        }

        .btc-popup-changes {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }

        .btc-popup-change {
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
        }

        .btc-popup-pattern {
            margin-top: 15px;
            padding: 10px;
            background-color: rgba(255, 215, 0, 0.1);
            border-radius: 10px;
            font-size: 1.1rem;
        }

        .btc-popup-time {
            margin-top: 20px;
            color: var(--muted-color);
            font-size: 0.9rem;
        }

        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .popup-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        @keyframes btc-pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        .pulse-animation {
            animation: btc-pulse 1s infinite;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1><i class="fa-brands fa-bitcoin"></i> OMEGA BTC AI REGGAE DASHBOARD</h1>
            <div class="price-ticker">
                <i class="btc-logo fa-brands fa-bitcoin"></i>
                <div id="btcPrice"></div>
                <div id="priceChanges">
                    <span id="shortTermChange"></span>
                    <span id="mediumTermChange"></span>
                </div>
                <div id="dominantPattern"></div>
                <div id="dataSource"></div>
                <div id="lastUpdated"></div>
            </div>
        </div>

        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot disconnected" id="status-dot"></div>
                <span id="status-text">Connecting to Redis...</span>
            </div>
            <div class="data-source" id="data-source">
                <i class="fas fa-database"></i>
                <span>Data Source: Initializing...</span>
            </div>
        </div>

        <div class="dashboard">
            <div class="card">
                <h2>
                    <i class="fas fa-chart-line"></i> TRAP PROBABILITY
                    <span class="refresh-time" id="trap-time">Updating...</span>
                </h2>
                <div class="data-row">
                    <span class="label">Probability:</span>
                    <span id="trap-probability" class="value neutral">0%</span>
                </div>
                <div class="data-row">
                    <span class="label">Type:</span>
                    <span id="trap-type" class="value neutral">Unknown</span>
                </div>
                <div class="data-row">
                    <span class="label">Trend:</span>
                    <span id="trap-trend" class="value neutral">Stable</span>
                </div>
                <div class="data-row">
                    <span class="label">Confidence:</span>
                    <span id="trap-confidence" class="value neutral">0%</span>
                </div>
                <div class="progress-bar">
                    <div id="trap-bar" class="progress-bar-inner" style="width: 0%"></div>
                </div>

                <h3>Components Analysis</h3>
                <div class="components-grid" id="trap-components">
                    <!-- Components will be inserted here -->
                </div>

                <div id="jah-message" class="jah-message">
                    JAH GUIDES THE TRADING PATH!
                </div>
            </div>

            <div class="card">
                <h2><i class="fas fa-chart-line"></i> Position Information <span class="refresh-time"
                        id="position-timestamp">--</span></h2>
                <div class="data-row">
                    <span class="label">Status:</span>
                    <span class="value neutral" id="position-status">No Position</span>
                </div>
                <div class="data-row">
                    <span class="label">Side:</span>
                    <span class="value neutral" id="position-side">--</span>
                </div>
                <div class="data-row">
                    <span class="label">Entry Price:</span>
                    <span class="value" id="entry-price">$0.00</span>
                </div>
                <div class="data-row">
                    <span class="label">Current Price:</span>
                    <span class="value" id="current-price">$0.00</span>
                </div>
                <div class="data-row">
                    <span class="label">Position Size:</span>
                    <span class="value" id="position-size">0.00 BTC</span>
                </div>
                <div class="data-row">
                    <span class="label">Leverage:</span>
                    <span class="value" id="position-leverage">0x</span>
                </div>
                <div class="data-row">
                    <span class="label">Risk Multiplier:</span>
                    <span class="value" id="risk-multiplier">1.00x</span>
                </div>
                <div class="data-row">
                    <span class="label">PnL:</span>
                    <span class="value neutral" id="pnl-percent">0.00%</span> / <span class="value neutral"
                        id="pnl-usd">$0.00</span>
                </div>
                <div class="data-row">
                    <span class="label">Stop Loss:</span>
                    <span class="value" id="stop-loss">$0.00</span>
                </div>
                <div class="data-row">
                    <span class="label">Take Profits:</span>
                    <span class="value" id="take-profits">--</span>
                </div>
                <div class="data-row">
                    <span class="label">Entry Time:</span>
                    <span class="value" id="entry-time">--</span>
                </div>
                <div class="data-row">
                    <span class="label">Source:</span>
                    <span class="value" id="position-source">--</span>
                </div>
            </div>

            <!-- Position Close Target Module -->
            <div class="card">
                <h2><i class="fas fa-bullseye"></i> Position Close Targets <span class="refresh-time"
                        id="target-timestamp">--</span></h2>
                <div class="data-row">
                    <span class="label">Target Status:</span>
                    <span class="value neutral" id="target-status">No Target</span>
                </div>
                <div class="data-row">
                    <span class="label">Next Target:</span>
                    <span class="value" id="next-target-price">$0.00</span>
                </div>
                <div class="data-row">
                    <span class="label">Next Target %:</span>
                    <span class="value neutral" id="next-target-percent">0.00%</span>
                </div>
                <div class="data-row">
                    <span class="label">Distance to Target:</span>
                    <span class="value" id="target-distance">0.00%</span>
                </div>
                <div class="data-row">
                    <span class="label">Est. Completion Time:</span>
                    <span class="value" id="target-eta">--</span>
                </div>
                <div class="data-row">
                    <span class="label">Fibonacci Level:</span>
                    <span class="value" id="fib-level">--</span>
                </div>

                <!-- Target Progress Bar -->
                <div class="label">Progress to Target:</div>
                <div class="progress-bar">
                    <div class="progress-bar-inner" id="target-progress-bar" style="width: 0%;"></div>
                </div>

                <!-- Position Flow Visualization -->
                <div class="position-flow-viz">
                    <h3>Position Flow</h3>
                    <div class="position-flow-container" id="position-flow-container">
                        <div class="position-flow-placeholder">Position flow visualization will appear here when a
                            position is active</div>
                        <canvas id="position-flow-canvas" width="100%" height="200"></canvas>
                    </div>
                </div>
            </div>

            <!-- Redis Debug Module -->
            <div class="card">
                <h2><i class="fas fa-database"></i> Redis Monitor <span class="refresh-time"
                        id="redis-monitor-timestamp">--</span></h2>

                <div class="data-row">
                    <span class="label">Connection Status:</span>
                    <span class="value neutral" id="redis-connection-status">Unknown</span>
                </div>

                <div class="data-row">
                    <span class="label">Last Updated:</span>
                    <span class="value" id="redis-last-updated">--</span>
                </div>

                <div class="data-row">
                    <span class="label">Active Keys:</span>
                    <span class="value" id="redis-active-keys">-</span>
                </div>

                <!-- Redis Keys List -->
                <h3>Recent Redis Keys</h3>
                <div class="redis-keys-container"
                    style="max-height: 200px; overflow-y: auto; margin-top: 10px; background-color: rgba(0,0,0,0.2); border-radius: 5px; padding: 10px;">
                    <div id="redis-keys-list">
                        <div class="redis-key-loading">Loading Redis keys...</div>
                    </div>
                </div>

                <button class="refresh-button" id="refresh-redis-info">
                    <i class="fas fa-sync-alt"></i> Refresh Redis Info
                </button>
            </div>

            <!-- Trap-Aware Dual Traders Control Card -->
            <div class="card">
                <h2>
                    <i class="fas fa-robot"></i> Trading Control
                    <span class="refresh-time" id="trading-control-timestamp">--</span>
                </h2>

                <div class="trading-status">
                    <div class="data-row">
                        <span class="label">System Status:</span>
                        <div class="status-indicator">
                            <div class="status-dot disconnected" id="trading-status-dot"></div>
                            <span class="value neutral" id="trading-status-text">Inactive</span>
                        </div>
                    </div>

                    <div class="data-row">
                        <span class="label">Long Trader:</span>
                        <span class="value neutral" id="long-trader-status">Inactive</span>
                    </div>

                    <div class="data-row">
                        <span class="label">Short Trader:</span>
                        <span class="value neutral" id="short-trader-status">Inactive</span>
                    </div>

                    <div class="data-row">
                        <span class="label">Combined PnL:</span>
                        <span class="value neutral" id="combined-pnl">$0.00</span>
                    </div>

                    <div class="data-row">
                        <span class="label">Last Action:</span>
                        <span class="value" id="last-trading-action">--</span>
                    </div>
                </div>

                <h3>Trap Protection Settings</h3>
                <div class="settings-grid"
                    style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0;">
                    <div class="setting-item">
                        <div class="setting-label">Trap Protection:</div>
                        <div class="setting-control">
                            <label class="toggle"
                                style="position: relative; display: inline-block; width: 60px; height: 28px;">
                                <input type="checkbox" id="trap-protection-toggle" checked
                                    style="opacity: 0; width: 0; height: 0;">
                                <span class="slider round"
                                    style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #2196F3; transition: .4s; border-radius: 34px;"></span>
                            </label>
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="setting-label">Trap Threshold:</div>
                        <div class="setting-control">
                            <input type="range" id="trap-threshold" min="0.5" max="0.9" step="0.05" value="0.7"
                                style="width: 100%;">
                            <span id="trap-threshold-value">0.7</span>
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="setting-label">Long Risk:</div>
                        <div class="setting-control">
                            <input type="range" id="long-risk" min="0.1" max="2.0" step="0.1" value="1.0"
                                style="width: 100%;">
                            <span id="long-risk-value">1.0</span>
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="setting-label">Short Risk:</div>
                        <div class="setting-control">
                            <input type="range" id="short-risk" min="0.1" max="2.0" step="0.1" value="1.0"
                                style="width: 100%;">
                            <span id="short-risk-value">1.0</span>
                        </div>
                    </div>
                </div>

                <div class="control-buttons" style="display: flex; justify-content: space-between; margin-top: 20px;">
                    <button id="start-trading-btn" class="refresh-button"
                        style="background-color: var(--green-color); color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                        <i class="fas fa-play"></i> Start Trading
                    </button>
                    <button id="stop-trading-btn" class="refresh-button"
                        style="background-color: var(--red-color); color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                        <i class="fas fa-stop"></i> Stop Trading
                    </button>
                </div>
            </div>
        </div>

        <div class="footer">
            <div>OMEGA BTC AI - Powered by Rastafarian wisdom & Modern AI</div>
            <div class="footer-icons">
                <i class="fa-brands fa-bitcoin"></i>
                <i class="fas fa-brain"></i>
                <i class="fas fa-chart-line"></i>
                <i class="fas fa-code"></i>
            </div>
            <button id="hodl-button" class="hodl-button">
                <i class="fa-brands fa-bitcoin"></i> CHECK BTC PRICE (HODL!)
            </button>
            <div>JAH LOVE ❤️ GUIDE THE WAY</div>
        </div>
    </div>

    <!-- BTC Price Popup -->
    <div id="popup-overlay" class="popup-overlay"></div>
    <div id="btc-popup" class="btc-popup">
        <div class="btc-popup-header">
            <div class="btc-popup-title">
                <i class="fa-brands fa-bitcoin"></i> Bitcoin Price
            </div>
            <button id="btc-popup-close" class="btc-popup-close">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="btc-popup-content">
            <div class="btc-popup-price" id="popup-price">$0.00</div>
            <div class="btc-popup-changes">
                <div class="btc-popup-change" id="popup-change">24h: 0.00%</div>
                <div class="btc-popup-change" id="popup-short-term">Short: 0.00%</div>
                <div class="btc-popup-change" id="popup-medium-term">Medium: 0.00%</div>
            </div>
            <div class="btc-popup-pattern" id="popup-pattern">
                Dominant Pattern: Unknown
            </div>
            <div class="btc-popup-time" id="popup-time">
                Last Updated: --
            </div>
        </div>
    </div>

    <!-- GNU License Disclaimer -->
    <div class="license-disclaimer">
        <p>OMEGA BTC AI - Copyright (C) 2024 OMEGA BTC AI Team</p>
        <p>This program is free software: you can redistribute it and/or modify
            it under the terms of the GNU General Public License as published by
            the Free Software Foundation, either version 3 of the License, or
            (at your option) any later version.</p>
        <p>This program is distributed in the hope that it will be useful,
            but WITHOUT ANY WARRANTY; without even the implied warranty of
            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
            GNU General Public License for more details.</p>
        <p>You should have received a copy of the GNU General Public License
            along with this program. If not, see <a href="https://www.gnu.org/licenses/"
                target="_blank">https://www.gnu.org/licenses/</a></p>
    </div>

    <script>
        // Debug helper
        const DEBUG = true; // Set to false to disable debug logs
        function debug(section, message, data = null) {
            if (!DEBUG) return;
            const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
            if (data) {
                console.log(`${timestamp} [${section}] ${message}`, data);
            } else {
                console.log(`${timestamp} [${section}] ${message}`);
            }
        }

        // API endpoints for Redis data
        const API_BASE = "http://localhost:8001/api";
        const TRAP_ENDPOINT = `${API_BASE}/trap-probability`;
        const POSITION_ENDPOINT = `${API_BASE}/position`;
        const BTC_PRICE_ENDPOINT = `${API_BASE}/btc-price`;
        const REDIS_KEYS_ENDPOINT = `${API_BASE}/redis-keys`;
        const COMBINED_DATA_ENDPOINT = `${API_BASE}/data`;
        const HEALTH_ENDPOINT = `${API_BASE}/health`;

        // Animation helper for UI feedback
        const animateElement = (elementId) => {
            const element = document.getElementById(elementId);
            if (element) {
                element.classList.add('shake');
                setTimeout(() => {
                    element.classList.remove('shake');
                }, 500);
            }
        };

        // Function to shake the JAH message for UI feedback
        const shakeJahMessage = () => {
            // Try with hyphen (HTML/CSS convention)
            let jahMessage = document.getElementById('jah-message');

            // Fallback to underscore if hyphen version not found
            if (!jahMessage) {
                jahMessage = document.getElementById('jah_message');
            }

            // If either version exists, apply the animation
            if (jahMessage) {
                jahMessage.classList.add('shake');
                setTimeout(() => {
                    jahMessage.classList.remove('shake');
                }, 500);
            } else {
                console.warn('JAH message element not found');
            }
        };

        // Helper function to format a price as USD
        const formatPrice = (price) => {
            if (price === null || price === undefined || isNaN(price)) {
                return '$0.00';
            }

            // Format with comma separators and fixed decimal places
            const formatter = new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            });

            return formatter.format(price);
        };

        // Helper function to format a value as USD with variable decimal places
        const formatUsd = (value) => {
            if (value === null || value === undefined || isNaN(value)) {
                return '$0.00';
            }

            // Determine appropriate decimal places based on value
            const absValue = Math.abs(value);
            let decimalPlaces = 2;

            if (absValue < 1) {
                decimalPlaces = 4;
            } else if (absValue < 0.01) {
                decimalPlaces = 6;
            }

            // Format with comma separators and appropriate decimal places
            const formatter = new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: decimalPlaces,
                maximumFractionDigits: decimalPlaces
            });

            return formatter.format(value);
        };

        // Helper function to format a percentage
        const formatPercent = (percent) => {
            if (percent === null || percent === undefined || isNaN(percent)) {
                return '0.00%';
            }

            // Add a plus sign for positive values
            const sign = percent >= 0 ? '+' : '';

            // Format with appropriate decimal places
            const absPercent = Math.abs(percent);
            let decimalPlaces = 2;

            if (absPercent < 0.1) {
                decimalPlaces = 4;
            }

            return `${sign}${absPercent.toFixed(decimalPlaces)}%`;
        };

        // Helper function to fetch Redis key value with retries
        const fetchRedisKey = async (key, retries = 1) => {
            debug('REDIS', `Fetching Redis key value for: ${key}`);
            try {
                // Use the new direct Redis key access endpoint
                const response = await fetch(`${API_BASE}/redis-key?key=${encodeURIComponent(key)}`);
                if (!response.ok) {
                    throw new Error(`Failed to fetch Redis key ${key}: ${response.status}`);
                }

                const data = await response.json();
                debug('REDIS', `Received data for key ${key}:`, data);

                if (data.status === 'error') {
                    throw new Error(data.error || `Error fetching key ${key}`);
                }

                return data.value;
            } catch (error) {
                console.error(`Error fetching Redis key ${key}:`, error);
                if (retries > 0) {
                    debug('REDIS', `Retrying fetch for key ${key}, ${retries} retries left`);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    return fetchRedisKey(key, retries - 1);
                }
                return null;
            }
        };

        // Helper function to find the dominant pattern
        const findDominantPattern = (patterns) => {
            let dominantPattern = 'Unknown';
            let highestProb = 0;

            for (const [pattern, probability] of Object.entries(patterns)) {
                if (probability > highestProb) {
                    highestProb = probability;
                    dominantPattern = pattern;
                }
            }

            return dominantPattern;
        };

        // Helper function to find the highest probability
        const findHighestProbability = (patterns) => {
            let highestProb = 0;

            for (const probability of Object.values(patterns)) {
                if (probability > highestProb) {
                    highestProb = probability;
                }
            }

            return highestProb;
        };

        // Function to check Redis connection status
        const checkRedisStatus = async () => {
            try {
                const response = await fetch(HEALTH_ENDPOINT);
                if (!response.ok) {
                    return { connected: false, message: 'Backend connection failed' };
                }

                const data = await response.json();
                return {
                    connected: data.redis === 'connected',
                    message: data.redis === 'connected' ? 'Connected to Redis' : 'Redis connection issue'
                };
            } catch (error) {
                console.error('Error checking Redis status:', error);
                return { connected: false, message: 'Connection error' };
            }
        };

        // Function to update Redis debug information
        const updateRedisDebugInfo = async () => {
            const connectionStatusElement = document.getElementById('redis-connection-status');
            const lastUpdatedElement = document.getElementById('redis-last-updated');
            const activeKeysElement = document.getElementById('redis-active-keys');
            const keysListElement = document.getElementById('redis-keys-list');

            try {
                // Check Redis connection status
                const redisStatus = await checkRedisStatus();
                connectionStatusElement.textContent = redisStatus.connected ? 'Connected' : 'Disconnected';
                connectionStatusElement.className = redisStatus.connected ? 'value positive' : 'value negative';

                if (redisStatus.connected) {
                    // Fetch Redis keys to check what's available
                    const response = await fetch(REDIS_KEYS_ENDPOINT);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch Redis keys: ${response.status}`);
                    }

                    const keysData = await response.json();
                    debug('REDIS', 'Received Redis keys data:', keysData);

                    // Update keys count
                    if (keysData.total_keys) {
                        activeKeysElement.textContent = `${keysData.displayed_keys || 0}/${keysData.total_keys} keys`;
                    } else {
                        activeKeysElement.textContent = `${keysData.keys?.length || 0} keys`;
                    }

                    // Update keys list
                    if (keysListElement && keysData.keys && keysData.keys.length > 0) {
                        keysListElement.innerHTML = '';

                        // Group keys by namespace (first part before colon)
                        const keysByNamespace = {};
                        keysData.keys.forEach(keyInfo => {
                            const key = keyInfo.key;
                            const namespace = key.includes(':') ? key.split(':')[0] : 'other';

                            if (!keysByNamespace[namespace]) {
                                keysByNamespace[namespace] = [];
                            }

                            keysByNamespace[namespace].push(keyInfo);
                        });

                        // Create elements for each namespace
                        for (const [namespace, keys] of Object.entries(keysByNamespace)) {
                            const namespaceEl = document.createElement('div');
                            namespaceEl.className = 'redis-namespace';
                            namespaceEl.innerHTML = `<div class="redis-namespace-name">${namespace}</div>`;

                            const keysEl = document.createElement('div');
                            keysEl.className = 'redis-namespace-keys';

                            keys.forEach(keyInfo => {
                                const keyEl = document.createElement('div');
                                keyEl.className = 'redis-key-item';

                                let details = '';
                                if (keyInfo.type) {
                                    details += `type: ${keyInfo.type}`;
                                }
                                if (keyInfo.length !== undefined) {
                                    details += details ? ', ' : '';
                                    details += `length: ${keyInfo.length}`;
                                }
                                if (keyInfo.fields !== undefined) {
                                    details += details ? ', ' : '';
                                    details += `fields: ${keyInfo.fields}`;
                                }

                                keyEl.innerHTML = `
                                    <span class="redis-key-name">${keyInfo.key}</span>
                                    <span class="redis-key-detail">${details}</span>
                                `;

                                keysEl.appendChild(keyEl);
                            });

                            namespaceEl.appendChild(keysEl);
                            keysListElement.appendChild(namespaceEl);
                        }
                    } else {
                        keysListElement.innerHTML = '<div class="redis-key-error">No Redis keys found</div>';
                    }
                } else {
                    activeKeysElement.textContent = '0 keys';
                    keysListElement.innerHTML = `<div class="redis-key-error">Redis connection failed: ${redisStatus.message}</div>`;
                }

                // Update last updated timestamp
                lastUpdatedElement.textContent = new Date().toLocaleTimeString();

            } catch (error) {
                console.error('Error updating Redis debug info:', error);

                connectionStatusElement.textContent = 'Error';
                connectionStatusElement.className = 'value negative';
                activeKeysElement.textContent = 'Error';
                lastUpdatedElement.textContent = new Date().toLocaleTimeString();

                if (keysListElement) {
                    keysListElement.innerHTML = `<div class="redis-key-error">Error: ${error.message}</div>`;
                }
            }
        };

        // Function to update the BTC price ticker in the header
        const updateBTCPriceTicker = async () => {
            debug('PRICE_TICKER', 'Updating BTC price ticker in header');
            try {
                // Get BTC price data from Redis
                let price = null;
                let priceKeyUsed = '';

                // Try different possible keys for price data
                for (const priceKey of ['btc_price', 'last_btc_price', 'sim_last_btc_price']) {
                    try {
                        const priceData = await fetchRedisKey(priceKey);
                        if (priceData !== null) {
                            debug('PRICE', `Found BTC price in key: ${priceKey}`, priceData);
                            // Handle different data types - string or number
                            if (typeof priceData === 'string') {
                                price = parseFloat(priceData);
                            } else if (typeof priceData === 'number') {
                                price = priceData;
                            } else if (typeof priceData === 'object' && priceData.hasOwnProperty('price')) {
                                // Handle case where we got an object with a price property
                                price = parseFloat(priceData.price);
                            }

                            // Validate parsed price is a valid number
                            if (!isNaN(price) && price > 0) {
                                priceKeyUsed = priceKey;
                                break;
                            } else {
                                price = null; // Reset if we got NaN or invalid value
                            }
                        }
                    } catch (error) {
                        debug('PRICE', `Error parsing price from ${priceKey}:`, error);
                        // Continue trying other keys
                    }
                }

                if (price === null || isNaN(price)) {
                    debug('PRICE', 'Could not find valid BTC price in any Redis key, using fallback');
                    // Fallback to a realistic default price if we couldn't get a valid price
                    price = 65000 + (Math.random() * 5000 - 2500); // Random price around $65,000
                    priceKeyUsed = 'fallback';
                }

                // Get price changes data with better error handling
                let shortTermChange = 0;
                let mediumTermChange = 0;

                try {
                    const changesData = await fetchRedisKey('btc_price_changes');
                    if (changesData) {
                        // Safely extract and validate the values
                        if (changesData.short_term !== undefined && !isNaN(parseFloat(changesData.short_term))) {
                            shortTermChange = parseFloat(changesData.short_term);
                        }
                        if (changesData.medium_term !== undefined && !isNaN(parseFloat(changesData.medium_term))) {
                            mediumTermChange = parseFloat(changesData.medium_term);
                        }
                    }
                } catch (error) {
                    debug('PRICE', 'Error getting price changes data:', error);
                    // Use realistic fallback values
                    shortTermChange = (Math.random() * 0.04) - 0.01; // -1% to +3%
                    mediumTermChange = (Math.random() * 0.06) - 0.02; // -2% to +4%
                }

                // Get price patterns data with better error handling
                let dominantPattern = 'Unknown';
                let patternsData = {};

                try {
                    const patterns = await fetchRedisKey('btc_price_patterns');
                    if (patterns && typeof patterns === 'object') {
                        patternsData = patterns;
                        dominantPattern = findDominantPattern(patterns);
                    }
                } catch (error) {
                    debug('PRICE', 'Error getting price patterns data:', error);
                    // Use fallback patterns
                    patternsData = {
                        'Wyckoff Distribution': 0.65,
                        'Double Top': 0.35,
                        'Bull Flag': 0.25,
                        'Head and Shoulders': 0.15
                    };
                    dominantPattern = 'Wyckoff Distribution';
                }

                // Prepare the data object
                const data = {
                    price: price,
                    shortTermChange: shortTermChange,
                    mediumTermChange: mediumTermChange,
                    dominantPattern: dominantPattern,
                    patterns: patternsData,
                    source: priceKeyUsed,
                    timestamp: new Date().toISOString()
                };

                debug('PRICE', 'Prepared price data:', data);

                // Update the price display in header
                const btcPrice = document.getElementById('btcPrice');
                if (btcPrice) {
                    btcPrice.textContent = formatPrice(data.price);
                    btcPrice.classList.add('btc-price');
                    btcPrice.setAttribute('title', `Source: ${data.source}`);
                }

                // Update short-term and medium-term changes
                const shortTermElement = document.getElementById('shortTermChange');
                const mediumTermElement = document.getElementById('mediumTermChange');

                if (shortTermElement && data.shortTermChange !== null) {
                    shortTermElement.textContent = formatPercent(data.shortTermChange);
                    shortTermElement.className = data.shortTermChange >= 0 ? 'price-change positive' : 'price-change negative';
                }

                if (mediumTermElement && data.mediumTermChange !== null) {
                    mediumTermElement.textContent = formatPercent(data.mediumTermChange);
                    mediumTermElement.className = data.mediumTermChange >= 0 ? 'price-change positive' : 'price-change negative';
                }

                // Update dominant pattern
                const dominantPatternElement = document.getElementById('dominantPattern');
                if (dominantPatternElement && data.dominantPattern) {
                    // Capitalize pattern name
                    const capitalizedPattern = data.dominantPattern.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    dominantPatternElement.textContent = capitalizedPattern;
                }

                debug('PRICE_TICKER', 'BTC price ticker in header updated successfully');
            } catch (error) {
                console.error('Error updating BTC price ticker:', error);

                // Try using combined data endpoint as fallback
                try {
                    const response = await fetch(COMBINED_DATA_ENDPOINT);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch combined data: ${response.status}`);
                    }

                    const combinedData = await response.json();
                    if (combinedData.btc_price && combinedData.btc_price.price) {
                        const btcPrice = document.getElementById('btcPrice');
                        if (btcPrice) {
                            btcPrice.textContent = formatPrice(combinedData.btc_price.price);
                        }
                    }
                } catch (fallbackError) {
                    console.error('Fallback for BTC price also failed:', fallbackError);
                    const btcPrice = document.getElementById('btcPrice');
                    if (btcPrice) {
                        btcPrice.textContent = 'Price Unavailable';
                    }
                }
            }
        };

        // Wait for DOM to be fully loaded before setting up event handlers
        document.addEventListener('DOMContentLoaded', function () {
            debug('INIT', 'DOM fully loaded, initializing dashboard');

            // DOM Elements for reference
            const statusDot = document.getElementById('status-dot');
            const statusText = document.getElementById('status-text');
            const dataSource = document.getElementById('data-source').querySelector('span');
            const btcPrice = document.getElementById('btcPrice');
            const priceChange = document.getElementById('priceChanges');
            const trapTime = document.getElementById('trap-time');
            const positionTime = document.getElementById('position-time');
            const refreshButton = document.getElementById('refresh-data');

            // HODL Button elements
            const hodlButton = document.getElementById('hodl-button');
            const btcPopup = document.getElementById('btc-popup');
            const popupOverlay = document.getElementById('popup-overlay');
            const popupCloseBtn = document.getElementById('btc-popup-close');

            // Set up event handlers for the HODL button and popup
            if (hodlButton) {
                debug('INIT', 'Setting up HODL button event listener');
                hodlButton.addEventListener('click', function (e) {
                    debug('HODL', 'HODL button clicked');
                    e.preventDefault();
                    showBTCPrice();
                });
            } else {
                console.error('HODL button not found in the DOM');
            }

            // Set up popup close button event listener
            if (popupCloseBtn) {
                popupCloseBtn.addEventListener('click', function () {
                    debug('HODL', 'Popup close button clicked');
                    popupOverlay.classList.remove('show');
                    btcPopup.classList.remove('show');
                });
            }

            // Set up overlay event listener
            if (popupOverlay) {
                popupOverlay.addEventListener('click', function () {
                    debug('HODL', 'Popup overlay clicked');
                    popupOverlay.classList.remove('show');
                    btcPopup.classList.remove('show');
                });
            }

            // Initialize the dashboard with auto-refresh
            startAutoRefresh();

            debug('INIT', 'Event handlers set up');
        });

        // Function to update the trap probability card
        const updateTrapProbability = async () => {
            debug('TRAP', 'Updating trap probability card');

            // Get DOM elements
            const probabilityElement = document.getElementById('trap-probability');
            const typeElement = document.getElementById('trap-type');
            const trendElement = document.getElementById('trap-trend');
            const confidenceElement = document.getElementById('trap-confidence');
            const progressBar = document.getElementById('trap-bar');
            const componentsGrid = document.getElementById('trap-components');
            const trapTimeElement = document.getElementById('trap-time');

            try {
                // Show updating indicator
                if (trapTimeElement) {
                    trapTimeElement.textContent = 'Updating...';
                }

                // Try to get trap data from Redis
                let trapData = null;

                // Try multiple potential Redis keys for trap data
                for (const key of ['current_trap_probability', 'trap_probability', 'latest_trap_analysis']) {
                    const data = await fetchRedisKey(key);
                    if (data) {
                        debug('TRAP', `Found trap data in key: ${key}`, data);
                        trapData = data;
                        break;
                    }
                }

                // Fallback to API endpoint if Redis key not found
                if (!trapData) {
                    debug('TRAP', 'No trap data found in Redis, trying API endpoint');
                    try {
                        const response = await fetch(`${API_BASE}/trap-probability`);
                        if (response.ok) {
                            trapData = await response.json();
                            debug('TRAP', 'Got trap data from API endpoint', trapData);
                        }
                    } catch (apiError) {
                        debug('TRAP', 'Error fetching from API endpoint:', apiError);
                    }
                }

                // Generate mock data if we still don't have trap data
                if (!trapData) {
                    debug('TRAP', 'Generating mock trap data');
                    const probability = Math.random() * 0.7 + 0.2; // 20% to 90%
                    trapData = {
                        probability: probability,
                        trap_type: probability > 0.6 ? 'Bull Trap' : 'Bear Trap',
                        trend: probability > 0.5 ? 'increasing' : 'decreasing',
                        confidence: Math.random() * 0.8 + 0.1, // 10% to 90%
                        components: {
                            price_action: Math.random() * 0.9,
                            volume_analysis: Math.random() * 0.8,
                            liquidity: Math.random() * 0.85,
                            sentiment: Math.random() * 0.75
                        },
                        timestamps: {
                            detected: new Date().toISOString()
                        },
                        source: 'mock'
                    };
                }

                // Safely extract data with validation
                const probability = parseFloat(trapData.probability) || 0;
                const type = trapData.trap_type || 'Unknown';
                const trend = trapData.trend || 'stable';
                const confidence = parseFloat(trapData.confidence) || 0;

                // Format timestamp
                let timestamp = 'N/A';
                if (trapData.timestamp) {
                    timestamp = new Date(trapData.timestamp).toLocaleTimeString();
                } else if (trapData.timestamps && trapData.timestamps.detected) {
                    timestamp = new Date(trapData.timestamps.detected).toLocaleTimeString();
                } else {
                    timestamp = new Date().toLocaleTimeString();
                }

                // Add source indicator if mock data
                if (trapData.source === 'mock') {
                    timestamp += ' (mock)';
                }

                // Get components safely
                const components = trapData.components || {};

                // Update probability and progress bar
                if (probabilityElement) {
                    probabilityElement.textContent = `${Math.round(probability * 100)}%`;
                }

                if (progressBar) {
                    progressBar.style.width = `${Math.round(probability * 100)}%`;

                    // Update color based on probability
                    const hue = ((1 - probability) * 120).toString(10);
                    progressBar.style.backgroundColor = `hsl(${hue}, 80%, 45%)`;
                }

                // Update trap type and trend
                if (typeElement) {
                    typeElement.textContent = type;
                }

                if (trendElement) {
                    trendElement.textContent = trend.charAt(0).toUpperCase() + trend.slice(1);

                    // Add trend direction indicator
                    if (trend === 'increasing') {
                        trendElement.innerHTML += ' ↑';
                        trendElement.style.color = '#ff4c4c';
                    } else if (trend === 'decreasing') {
                        trendElement.innerHTML += ' ↓';
                        trendElement.style.color = '#4caf50';
                    }
                }

                // Update confidence
                if (confidenceElement) {
                    confidenceElement.textContent = `${Math.round(confidence * 100)}%`;
                }

                // Update components grid
                if (componentsGrid) {
                    componentsGrid.innerHTML = '';

                    // Create component items
                    Object.entries(components).forEach(([key, value]) => {
                        // Ensure value is a number and not NaN
                        const componentValue = parseFloat(value);
                        if (isNaN(componentValue)) {
                            return; // Skip invalid components
                        }

                        // Format key for display
                        const formattedKey = key
                            .replace(/_/g, ' ')
                            .split(' ')
                            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                            .join(' ');

                        // Calculate percentage
                        const percent = Math.round(componentValue * 100);

                        // Create component element
                        const componentEl = document.createElement('div');
                        componentEl.className = 'component-item';

                        // Adjust background color based on value
                        const hue = ((1 - componentValue) * 120).toString(10);

                        componentEl.innerHTML = `
                            <div class="component-name">${formattedKey}</div>
                            <div class="component-value">
                                <div class="component-bar" style="width: ${percent}%; background-color: hsl(${hue}, 80%, 45%)"></div>
                                <span class="value-text">${percent}%</span>
                            </div>
                        `;

                        componentsGrid.appendChild(componentEl);
                    });

                    // If no components were added, show a message
                    if (componentsGrid.children.length === 0) {
                        componentsGrid.innerHTML = '<div class="no-components">No component data available</div>';
                    }
                }

                // Update time
                if (trapTimeElement) {
                    trapTimeElement.textContent = timestamp;
                }

                // Trigger JAH wisdom message and animation effect
                if (probability > 0.5) {
                    animateJahMessage();
                }

            } catch (error) {
                console.error('Error updating trap probability card:', error);

                // Show error state
                if (probabilityElement) probabilityElement.textContent = 'N/A';
                if (typeElement) typeElement.textContent = 'Error';
                if (trendElement) trendElement.textContent = 'Unknown';
                if (confidenceElement) confidenceElement.textContent = 'N/A';
                if (progressBar) progressBar.style.width = '0%';
                if (componentsGrid) componentsGrid.innerHTML = '<div class="component-error">Error loading components</div>';
                if (trapTimeElement) trapTimeElement.textContent = `Error: ${new Date().toLocaleTimeString()}`;
            }
        };

        // Function to update the position information card
        const updatePositionInfo = async () => {
            debug('POSITION', 'Updating position information card');

            // Get DOM elements
            const statusElement = document.getElementById('position-status');
            const sideElement = document.getElementById('position-side');
            const entryPriceElement = document.getElementById('entry-price');
            const currentPriceElement = document.getElementById('current-price');
            const positionSizeElement = document.getElementById('position-size');
            const leverageElement = document.getElementById('position-leverage');
            const riskMultiElement = document.getElementById('risk-multiplier');
            const pnlPercentElement = document.getElementById('pnl-percent');
            const pnlUsdElement = document.getElementById('pnl-usd');
            const stopLossElement = document.getElementById('stop-loss');
            const takeProfitsElement = document.getElementById('take-profits');
            const entryTimeElement = document.getElementById('entry-time');
            const sourceElement = document.getElementById('position-source');
            const timestampElement = document.getElementById('position-timestamp');

            try {
                // Show updating indicator
                if (timestampElement) {
                    timestampElement.textContent = 'Updating...';
                }

                // Try to get position data from Redis
                let positionData = null;

                // Try multiple potential Redis keys for position data
                for (const key of ['current_position', 'active_position', 'position_data']) {
                    const data = await fetchRedisKey(key);
                    if (data) {
                        debug('POSITION', `Found position data in key: ${key}`, data);
                        positionData = data;
                        break;
                    }
                }

                // Fallback to API endpoint if Redis key not found
                if (!positionData) {
                    debug('POSITION', 'No position data found in Redis, trying API endpoint');
                    try {
                        const response = await fetch(`${API_BASE}/position`);
                        if (response.ok) {
                            positionData = await response.json();
                            debug('POSITION', 'Got position data from API endpoint', positionData);
                        }
                    } catch (apiError) {
                        debug('POSITION', 'Error fetching from API endpoint:', apiError);
                    }
                }

                // Get current BTC price for calculations or use the one from position data
                let currentPrice = positionData && positionData.current_price ? parseFloat(positionData.current_price) : null;

                // If no current price in position data, try to get from Redis
                if (!currentPrice) {
                    try {
                        for (const priceKey of ['btc_price', 'last_btc_price', 'sim_last_btc_price']) {
                            const price = await fetchRedisKey(priceKey);
                            if (price !== null) {
                                if (typeof price === 'number') {
                                    currentPrice = price;
                                } else if (typeof price === 'string') {
                                    currentPrice = parseFloat(price);
                                } else if (typeof price === 'object' && price.hasOwnProperty('price')) {
                                    currentPrice = parseFloat(price.price);
                                }

                                if (!isNaN(currentPrice) && currentPrice > 0) {
                                    break;
                                } else {
                                    currentPrice = null;
                                }
                            }
                        }
                    } catch (priceError) {
                        debug('POSITION', 'Error getting current price:', priceError);
                    }
                }

                // Use fallback price if we couldn't get a real one
                if (currentPrice === null || isNaN(currentPrice)) {
                    currentPrice = 65000 + (Math.random() * 3000 - 1500);
                }

                // Check if we have a position or not
                if (positionData && positionData.has_position) {
                    // Format timestamps
                    let updateTime = new Date().toLocaleTimeString();
                    let entryTime = 'Unknown';
                    let dataSource = positionData.source || 'API';

                    // Handle timestamp conversion - could be milliseconds timestamp or ISO string
                    if (positionData.timestamp) {
                        const timestamp = typeof positionData.timestamp === 'number'
                            ? positionData.timestamp
                            : new Date(positionData.timestamp).getTime();

                        // If timestamp is in milliseconds since epoch
                        if (timestamp > 1000000000000) {
                            updateTime = new Date(timestamp).toLocaleTimeString();
                        } else {
                            // If timestamp is in seconds since epoch
                            updateTime = new Date(timestamp * 1000).toLocaleTimeString();
                        }
                    }

                    // Handle entry time conversion - could be milliseconds timestamp or ISO string
                    if (positionData.entry_time) {
                        const entryTimestamp = typeof positionData.entry_time === 'number'
                            ? positionData.entry_time
                            : new Date(positionData.entry_time).getTime();

                        // If timestamp is in milliseconds since epoch
                        if (entryTimestamp > 1000000000000) {
                            entryTime = new Date(entryTimestamp).toLocaleTimeString();
                        } else {
                            // If timestamp is in seconds since epoch
                            entryTime = new Date(entryTimestamp * 1000).toLocaleTimeString();
                        }
                    }

                    // Safely extract position data
                    const side = positionData.position_side || 'unknown';
                    const entryPrice = parseFloat(positionData.entry_price) || 0;
                    const positionSize = parseFloat(positionData.position_size) || 0;
                    const leverage = parseInt(positionData.leverage) || 1;
                    const riskMultiplier = parseFloat(positionData.risk_multiplier) || 1;
                    const stopLoss = parseFloat(positionData.stop_loss) || 0;
                    const takeProfit = positionData.take_profits || [];

                    // Get PnL data
                    let pnlPercent = positionData.pnl_percent !== undefined
                        ? parseFloat(positionData.pnl_percent)
                        : 0;

                    let pnlUsd = positionData.pnl_usd !== undefined
                        ? parseFloat(positionData.pnl_usd)
                        : 0;

                    // Calculate PnL if needed
                    if ((pnlPercent === 0 || isNaN(pnlPercent)) && entryPrice > 0 && currentPrice > 0) {
                        // Calculate PnL based on side
                        if (side.toLowerCase() === 'long') {
                            pnlPercent = ((currentPrice - entryPrice) / entryPrice) * 100 * leverage;
                            if (positionSize > 0) {
                                pnlUsd = (currentPrice - entryPrice) * positionSize * leverage;
                            }
                        } else if (side.toLowerCase() === 'short') {
                            pnlPercent = ((entryPrice - currentPrice) / entryPrice) * 100 * leverage;
                            if (positionSize > 0) {
                                pnlUsd = (entryPrice - currentPrice) * positionSize * leverage;
                            }
                        }
                    }

                    // Update status
                    if (statusElement) {
                        statusElement.textContent = 'ACTIVE';
                        statusElement.className = 'value positive';
                    }

                    // Update side with icon
                    if (sideElement) {
                        const formattedSide = side.charAt(0).toUpperCase() + side.slice(1);
                        if (side.toLowerCase() === 'long') {
                            sideElement.innerHTML = `${formattedSide} ↑`;
                            sideElement.className = 'value positive';
                        } else if (side.toLowerCase() === 'short') {
                            sideElement.innerHTML = `${formattedSide} ↓`;
                            sideElement.className = 'value negative';
                        } else {
                            sideElement.textContent = formattedSide;
                            sideElement.className = 'value neutral';
                        }
                    }

                    // Update prices
                    if (entryPriceElement) {
                        entryPriceElement.textContent = formatPrice(entryPrice);
                    }

                    if (currentPriceElement) {
                        currentPriceElement.textContent = formatPrice(currentPrice);
                    }

                    // Update position details
                    if (positionSizeElement) {
                        positionSizeElement.textContent = `${positionSize.toFixed(4)} BTC`;
                    }

                    if (leverageElement) {
                        leverageElement.textContent = `${leverage}x`;
                    }

                    if (riskMultiElement) {
                        riskMultiElement.textContent = `${riskMultiplier.toFixed(2)}x`;
                    }

                    // Update PnL with color coding
                    if (pnlPercentElement) {
                        pnlPercentElement.textContent = `${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%`;

                        if (pnlPercent >= 1) {
                            pnlPercentElement.className = 'value positive';
                        } else if (pnlPercent < 0) {
                            pnlPercentElement.className = 'value negative';
                        } else {
                            pnlPercentElement.className = 'value neutral';
                        }
                    }

                    // Update USD PnL
                    if (pnlUsdElement) {
                        pnlUsdElement.textContent = `${pnlUsd >= 0 ? '+' : ''}${formatUsd(pnlUsd)}`;

                        if (pnlUsd >= 1) {
                            pnlUsdElement.className = 'value positive';
                        } else if (pnlUsd < 0) {
                            pnlUsdElement.className = 'value negative';
                        } else {
                            pnlUsdElement.className = 'value neutral';
                        }
                    }

                    // Update stop loss
                    if (stopLossElement) {
                        stopLossElement.textContent = stopLoss > 0 ? formatPrice(stopLoss) : 'Not Set';
                    }

                    // Update take profits
                    if (takeProfitsElement) {
                        if (Array.isArray(takeProfit) && takeProfit.length > 0) {
                            // Format take profits as a string
                            const takeProfitText = takeProfit.map(tp => {
                                if (typeof tp === 'object' && tp.price) {
                                    const price = parseFloat(tp.price);
                                    const pct = tp.percentage ? parseFloat(tp.percentage) * 100 : '';
                                    return `${formatPrice(price)}${pct ? ` (${pct.toFixed(0)}%)` : ''}`;
                                } else if (typeof tp === 'number') {
                                    return formatPrice(tp);
                                }
                                return '';
                            }).join(', ');

                            takeProfitsElement.textContent = takeProfitText || 'Not Set';
                        } else {
                            takeProfitsElement.textContent = 'Not Set';
                        }
                    }

                    // Update times
                    if (entryTimeElement) {
                        entryTimeElement.textContent = entryTime;
                    }

                    // Update source
                    if (sourceElement) {
                        sourceElement.textContent = dataSource;
                    }

                    // Update timestamp
                    if (timestampElement) {
                        timestampElement.textContent = updateTime;
                    }

                } else {
                    // No active position - show "No Position" state

                    // Update status
                    if (statusElement) {
                        statusElement.textContent = 'NO POSITION';
                        statusElement.className = 'value neutral';
                    }

                    // Clear other fields
                    if (sideElement) sideElement.textContent = 'N/A';
                    if (entryPriceElement) entryPriceElement.textContent = 'N/A';
                    if (currentPriceElement) currentPriceElement.textContent = formatPrice(currentPrice);
                    if (positionSizeElement) positionSizeElement.textContent = 'N/A';
                    if (leverageElement) leverageElement.textContent = 'N/A';
                    if (riskMultiElement) riskMultiElement.textContent = 'N/A';
                    if (pnlPercentElement) pnlPercentElement.textContent = '0.00%';
                    if (pnlUsdElement) pnlUsdElement.textContent = '$0.00';
                    if (stopLossElement) stopLossElement.textContent = '$0.00';
                    if (takeProfitsElement) takeProfitsElement.textContent = '--';
                    if (entryTimeElement) entryTimeElement.textContent = 'N/A';
                    if (sourceElement) sourceElement.textContent = '--';

                    // Update timestamp
                    if (timestampElement) {
                        const timestamp = new Date().toLocaleTimeString();
                        timestampElement.textContent = timestamp;
                    }
                }

            } catch (error) {
                console.error('Error updating position information:', error);

                // Show error state
                if (statusElement) statusElement.textContent = 'ERROR';
                if (sideElement) sideElement.textContent = 'ERROR';
                if (entryPriceElement) entryPriceElement.textContent = 'ERROR';
                if (currentPriceElement) currentPriceElement.textContent = 'ERROR';
                if (positionSizeElement) positionSizeElement.textContent = 'ERROR';
                if (leverageElement) leverageElement.textContent = 'ERROR';
                if (riskMultiElement) riskMultiElement.textContent = 'ERROR';
                if (pnlPercentElement) pnlPercentElement.textContent = 'ERROR';
                if (pnlUsdElement) pnlUsdElement.textContent = 'ERROR';
                if (stopLossElement) stopLossElement.textContent = 'ERROR';
                if (takeProfitsElement) takeProfitsElement.textContent = 'ERROR';
                if (entryTimeElement) entryTimeElement.textContent = 'ERROR';
                if (sourceElement) sourceElement.textContent = 'ERROR';

                if (timestampElement) {
                    timestampElement.textContent = `Error: ${new Date().toLocaleTimeString()}`;
                }
            }
        };

        // Function to update position close targets
        const updatePositionTargets = async () => {
            debug('TARGETS', 'Updating position close targets');

            // Get DOM elements
            const statusElement = document.getElementById('target-status');
            const nextTargetElement = document.getElementById('next-target-price');
            const targetPercentElement = document.getElementById('next-target-percent');
            const distanceElement = document.getElementById('target-distance');
            const etaElement = document.getElementById('target-eta');
            const fibLevelElement = document.getElementById('fib-level');
            const progressBar = document.getElementById('target-progress-bar');
            const timestampElement = document.getElementById('target-timestamp');

            try {
                // First update timestamp to show we're working
                if (timestampElement) {
                    timestampElement.textContent = 'Updating...';
                }

                // Try to fetch target data directly from Redis
                let targetData = await fetchRedisKey('position_targets');
                let generatedMockData = false;

                // If no targets data in Redis, try to create mock data based on position
                if (!targetData) {
                    debug('TARGETS', 'No position_targets in Redis, trying to generate mock data');
                    try {
                        // Get position data to create mock targets
                        const positionData = await fetchRedisKey('current_position');

                        if (positionData && positionData.has_position) {
                            debug('TARGETS', 'Found position data, generating mock targets');
                            // Get latest price data for accurate calculations
                            let currentPrice = 0;
                            try {
                                for (const priceKey of ['btc_price', 'last_btc_price', 'sim_last_btc_price']) {
                                    const price = await fetchRedisKey(priceKey);
                                    if (price !== null) {
                                        currentPrice = typeof price === 'number' ? price : parseFloat(price);
                                        debug('TARGETS', `Using current price from ${priceKey}: ${currentPrice}`);
                                        break;
                                    }
                                }
                            } catch (priceError) {
                                debug('TARGETS', `Error getting price data: ${priceError.message}`);
                                // Use position's current price as fallback
                                currentPrice = positionData.current_price || 0;
                            }

                            // Get position details for target calculation
                            const entryPrice = positionData.entry_price || currentPrice;
                            const isLong = (positionData.position_side || '').toLowerCase() === 'long';

                            // If we don't have both prices, use some defaults
                            if (!entryPrice || !currentPrice) {
                                debug('TARGETS', 'Missing price data, using defaults');
                                const defaultPrice = 65000; // Default BTC price if we can't get real data
                                currentPrice = currentPrice || defaultPrice;
                                const entryPrice = entryPrice || defaultPrice * 0.99; // 1% below default as a fallback
                            }

                            // Calculate targets based on position type
                            const targetPercent = isLong ? 0.05 : -0.05; // 5% target
                            const targetPrice = isLong
                                ? entryPrice * (1 + targetPercent)
                                : entryPrice * (1 - targetPercent);

                            // Calculate progress towards target
                            const priceDistance = isLong
                                ? (targetPrice - currentPrice) / targetPrice
                                : (currentPrice - targetPrice) / currentPrice;

                            // Ensure completion percent is between 0-100%
                            const completionPercent = Math.max(0, Math.min(1 - priceDistance, 1));

                            targetData = {
                                has_targets: true,
                                next_target: {
                                    price: targetPrice,
                                    percent: targetPercent,
                                    distance: priceDistance,
                                    eta_minutes: Math.round(priceDistance * 120), // Mock ETA
                                    completion_percent: completionPercent,
                                    fib_level: '0.382'
                                },
                                timestamp: new Date().toISOString()
                            };
                            generatedMockData = true;
                            debug('TARGETS', 'Generated mock target data:', targetData);
                        } else {
                            debug('TARGETS', 'No position data found, using empty targets');
                            // No position found, use empty targets
                            targetData = {
                                has_targets: false,
                                timestamp: new Date().toISOString()
                            };
                            generatedMockData = true;
                        }
                    } catch (mockDataError) {
                        debug('TARGETS', `Error generating mock data: ${mockDataError.message}`);
                        // If mock data generation fails, use empty data
                        targetData = {
                            has_targets: false,
                            error: mockDataError.message,
                            timestamp: new Date().toISOString()
                        };
                    }
                }

                // Update UI with target data - always update even if there are no targets
                if (targetData) {
                    debug('TARGETS', 'Position targets data:', targetData);

                    // Update target status
                    if (statusElement) {
                        const hasTargets = targetData.has_targets || false;
                        statusElement.textContent = hasTargets ? 'Active' : 'No Targets';
                        statusElement.className = 'value';
                        statusElement.classList.add(hasTargets ? 'positive' : 'neutral');
                    }

                    // If there are targets, update all fields
                    if (targetData.has_targets && targetData.next_target) {
                        const target = targetData.next_target;

                        // Update next target price
                        if (nextTargetElement && target.price) {
                            nextTargetElement.textContent = formatPrice(target.price);
                        }

                        // Update target percent
                        if (targetPercentElement && target.percent !== undefined) {
                            const percentValue = target.percent * 100;
                            targetPercentElement.textContent = `${percentValue.toFixed(2)}%`;
                            targetPercentElement.className = 'value';
                            if (percentValue > 0) {
                                targetPercentElement.classList.add('positive');
                            } else if (percentValue < 0) {
                                targetPercentElement.classList.add('negative');
                            } else {
                                targetPercentElement.classList.add('neutral');
                            }
                        }

                        // Update distance to target
                        if (distanceElement && target.distance !== undefined) {
                            const distancePercent = target.distance * 100;
                            distanceElement.textContent = `${distancePercent.toFixed(2)}%`;
                            distanceElement.className = 'value';

                            // Color based on how close we are (closer is better)
                            if (distancePercent < 2) {
                                distanceElement.classList.add('positive');
                            } else if (distancePercent < 5) {
                                distanceElement.classList.add('neutral');
                            } else {
                                distanceElement.classList.add('negative');
                            }
                        }

                        // Update ETA
                        if (etaElement && target.eta_minutes !== undefined) {
                            if (target.eta_minutes < 1) {
                                etaElement.textContent = 'Imminent';
                            } else if (target.eta_minutes < 60) {
                                etaElement.textContent = `~${target.eta_minutes} minutes`;
                            } else {
                                const hours = Math.floor(target.eta_minutes / 60);
                                etaElement.textContent = `~${hours} hour${hours > 1 ? 's' : ''}`;
                            }
                        }

                        // Update Fibonacci level
                        if (fibLevelElement && target.fib_level) {
                            fibLevelElement.textContent = target.fib_level;
                        }

                        // Update progress bar - crucial for displaying progress
                        if (progressBar && target.completion_percent !== undefined) {
                            const percent = target.completion_percent * 100;
                            progressBar.style.width = `${percent}%`;
                            debug('TARGETS', `Setting progress bar width to ${percent}%`);
                        }
                    } else {
                        // Reset fields if no targets
                        if (nextTargetElement) nextTargetElement.textContent = '$0.00';
                        if (targetPercentElement) {
                            targetPercentElement.textContent = '0.00%';
                            targetPercentElement.className = 'value neutral';
                        }
                        if (distanceElement) {
                            distanceElement.textContent = '0.00%';
                            distanceElement.className = 'value neutral';
                        }
                        if (etaElement) etaElement.textContent = '--';
                        if (fibLevelElement) fibLevelElement.textContent = '--';

                        // Always set progress bar to 0% when no targets available
                        if (progressBar) {
                            progressBar.style.width = '0%';
                            debug('TARGETS', 'Resetting progress bar to 0%');
                        }
                    }

                    // Update timestamp
                    if (timestampElement) {
                        if (targetData.timestamp) {
                            timestampElement.textContent = formatTimeDiff(targetData.timestamp);
                        } else {
                            timestampElement.textContent = 'Just now';
                        }

                        // Add indicator if this was generated data
                        if (generatedMockData) {
                            timestampElement.textContent += ' (mock)';
                        }
                    }
                }
            } catch (error) {
                console.error('Error updating position targets:', error);

                // Create fallback display values for error case
                if (statusElement) {
                    statusElement.textContent = 'No Targets';
                    statusElement.className = 'value neutral';
                }

                if (nextTargetElement) nextTargetElement.textContent = '$0.00';
                if (targetPercentElement) {
                    targetPercentElement.textContent = '0.00%';
                    targetPercentElement.className = 'value neutral';
                }
                if (distanceElement) {
                    distanceElement.textContent = '0.00%';
                    distanceElement.className = 'value neutral';
                }
                if (etaElement) etaElement.textContent = '--';
                if (fibLevelElement) fibLevelElement.textContent = '--';

                // Ensure progress bar is set to 0% in error case
                if (progressBar) {
                    progressBar.style.width = '0%';
                    debug('TARGETS', 'Resetting progress bar to 0% due to error');
                }

                if (timestampElement) {
                    const now = new Date();
                    timestampElement.textContent = `${now.toLocaleTimeString()} (error)`;
                }
            }
        };

        // Set up auto-refresh for all components
        const startAutoRefresh = () => {
            // Check connection status
            const updateConnectionStatus = async () => {
                try {
                    const response = await fetch(HEALTH_ENDPOINT);
                    if (!response.ok) {
                        throw new Error(`Health check failed: ${response.status}`);
                    }

                    const healthData = await response.json();
                    const isConnected = healthData.redis === 'connected';

                    // Update status indicator
                    const statusDot = document.getElementById('status-dot');
                    const statusText = document.getElementById('status-text');

                    if (statusDot) {
                        statusDot.className = isConnected ? 'status-dot connected' : 'status-dot disconnected';
                    }

                    if (statusText) {
                        statusText.textContent = isConnected ? 'Connected to Redis' : 'Disconnected from Redis';
                    }

                    // Update data source 
                    const dataSourceEl = document.getElementById('data-source');
                    if (dataSourceEl) {
                        const dataSourceSpan = dataSourceEl.querySelector('span');
                        if (dataSourceSpan) {
                            dataSourceSpan.textContent = `Data Source: ${isConnected ? 'Redis' : 'Fallback'}`;
                        }
                    }

                    return isConnected;
                } catch (error) {
                    console.error('Error checking connection status:', error);

                    // Update status to disconnected
                    const statusDot = document.getElementById('status-dot');
                    const statusText = document.getElementById('status-text');

                    if (statusDot) {
                        statusDot.className = 'status-dot disconnected';
                    }

                    if (statusText) {
                        statusText.textContent = 'Connection Error';
                    }

                    return false;
                }
            };

            // Initial updates
            const initializeDashboard = async () => {
                const isConnected = await updateConnectionStatus();
                debug('INIT', `Initial connection status: ${isConnected ? 'Connected' : 'Disconnected'}`);

                // Fetch initial data
                updateBTCPriceTicker();
                updateTrapProbability();
                updatePositionInfo();
                updatePositionTargets();
                updateRedisDebugInfo();

                // Set up refresh intervals

                // Every 5 seconds:
                setInterval(() => {
                    updateBTCPriceTicker();
                    updateConnectionStatus();
                }, 5000);

                // Every 10 seconds:
                setInterval(() => {
                    updateTrapProbability();
                    updatePositionInfo();
                    updatePositionTargets();
                }, 10000);

                // Every 30 seconds:
                setInterval(() => {
                    updateRedisDebugInfo();
                }, 30000);

                debug('INIT', 'Auto-refresh intervals set up');
            };

            // Start the dashboard
            initializeDashboard();
        };

        // Start auto-refresh when document is ready
        startAutoRefresh();

        // Function to display BTC price popup
        const showBTCPrice = async () => {
            debug('HODL', 'Showing BTC price popup');
            const popupOverlay = document.getElementById('popup-overlay');
            const btcPopup = document.getElementById('btc-popup');
            const popupPrice = document.getElementById('popup-price');
            const popupChange = document.getElementById('popup-change');
            const popupShortTerm = document.getElementById('popup-short-term');
            const popupMediumTerm = document.getElementById('popup-medium-term');
            const popupPattern = document.getElementById('popup-pattern');
            const popupTime = document.getElementById('popup-time');

            // Show popup with loading state
            popupOverlay.classList.add('show');
            btcPopup.classList.add('show');

            if (popupPrice) popupPrice.innerHTML = 'Loading...';
            if (popupPattern) popupPattern.innerHTML = 'Checking patterns...';

            try {
                // Try to fetch the current BTC price from Redis
                let price = null;
                // Try different possible keys for price data
                for (const priceKey of ['btc_price', 'last_btc_price', 'sim_last_btc_price']) {
                    price = await fetchRedisKey(priceKey);
                    if (price !== null) {
                        debug('HODL', `Found BTC price in key: ${priceKey}`);
                        break;
                    }
                }

                if (price === null) {
                    throw new Error('Could not find BTC price in any Redis key');
                }

                // Get price changes data
                const changesData = await fetchRedisKey('btc_price_changes');

                // Get price patterns data
                const patternsData = await fetchRedisKey('btc_price_patterns');

                // Prepare the normalized data object
                const priceData = {
                    price: typeof price === 'number' ? price : parseFloat(price),
                    change: 0, // 24h change (not available in Redis currently)
                    shortTermChange: (changesData && changesData.short_term) ? changesData.short_term : 0,
                    mediumTermChange: (changesData && changesData.medium_term) ? changesData.medium_term : 0,
                    dominantPattern: findDominantPattern(patternsData || {}),
                    dominantPatternProbability: findHighestProbability(patternsData || {}),
                    patterns: patternsData || {},
                    timestamp: new Date().toISOString()
                };

                debug('HODL', 'BTC price data for popup:', priceData);

                // Update popup content
                if (popupPrice) {
                    popupPrice.innerHTML = formatPrice(priceData.price);
                    popupPrice.classList.add('pulse-animation');
                    setTimeout(() => popupPrice.classList.remove('pulse-animation'), 2000);
                }

                // Update 24h change
                if (popupChange) {
                    const change = priceData.change || 0;
                    popupChange.innerHTML = `24h: ${formatPercent(change)}`;
                    popupChange.className = 'btc-popup-change';
                    if (change > 0) popupChange.classList.add('positive');
                    else if (change < 0) popupChange.classList.add('negative');
                    else popupChange.classList.add('neutral');
                }

                // Update short-term change
                if (popupShortTerm) {
                    const shortChange = priceData.shortTermChange || 0;
                    popupShortTerm.innerHTML = `Short: ${formatPercent(shortChange)}`;
                    popupShortTerm.className = 'btc-popup-change';
                    if (shortChange > 0) popupShortTerm.classList.add('positive');
                    else if (shortChange < 0) popupShortTerm.classList.add('negative');
                    else popupShortTerm.classList.add('neutral');
                }

                // Update medium-term change
                if (popupMediumTerm) {
                    const mediumChange = priceData.mediumTermChange || 0;
                    popupMediumTerm.innerHTML = `Medium: ${formatPercent(mediumChange)}`;
                    popupMediumTerm.className = 'btc-popup-change';
                    if (mediumChange > 0) popupMediumTerm.classList.add('positive');
                    else if (mediumChange < 0) popupMediumTerm.classList.add('negative');
                    else popupMediumTerm.classList.add('neutral');
                }

                // Update pattern
                if (popupPattern) {
                    const pattern = priceData.dominantPattern || 'Unknown';
                    const probability = priceData.dominantPatternProbability || 0;

                    // Format pattern name for display
                    const patternName = pattern
                        .split('_')
                        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                        .join(' ');

                    popupPattern.innerHTML = `Dominant Pattern: ${patternName} (${Math.round(probability * 100)}%)`;
                }

                // Update time
                if (popupTime) {
                    popupTime.innerHTML = `Last Updated: ${new Date().toLocaleTimeString()}`;
                }

                // Shake the popup for emphasis
                btcPopup.classList.add('shake');
                setTimeout(() => btcPopup.classList.remove('shake'), 500);

                // Trigger JAH message animation for added effect
                shakeJahMessage();
            } catch (error) {
                console.error('Error showing BTC price:', error);

                // Try fallback to the combined data endpoint
                try {
                    const response = await fetch(COMBINED_DATA_ENDPOINT);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch combined data: ${response.status}`);
                    }

                    const combinedData = await response.json();
                    const btcData = combinedData.btc_price;

                    if (btcData && btcData.price) {
                        // Update popup with available data
                        if (popupPrice) {
                            popupPrice.innerHTML = formatPrice(btcData.price);
                        }

                        if (popupPattern) {
                            popupPattern.innerHTML = 'Pattern data not available';
                        }

                        if (popupTime) {
                            popupTime.innerHTML = `Last Updated: ${new Date().toLocaleTimeString()}`;
                        }
                    } else {
                        throw new Error('No price data in combined endpoint');
                    }
                } catch (fallbackError) {
                    console.error('Error with fallback data source:', fallbackError);

                    // Show error state
                    if (popupPrice) popupPrice.innerHTML = 'Error loading price';
                    if (popupPattern) popupPattern.innerHTML = 'Could not load pattern data';

                    // Shake the popup to indicate error
                    btcPopup.classList.add('shake');
                    setTimeout(() => btcPopup.classList.remove('shake'), 500);
                }
            }
        };

        // Trap-Aware Dual Trader functionality
        const updateTraderStatus = async () => {
            debug('TRADER', 'Updating trader status');
            const statusDot = document.getElementById('trading-status-dot');
            const statusText = document.getElementById('trading-status-text');
            const longTraderStatus = document.getElementById('long-trader-status');
            const shortTraderStatus = document.getElementById('short-trader-status');
            const combinedPnL = document.getElementById('combined-pnl');
            const lastAction = document.getElementById('last-trading-action');
            const timestamp = document.getElementById('trading-control-timestamp');

            try {
                // Get trader status from Redis
                const traderStatus = await fetchRedisKey('trader_status');

                if (!traderStatus) {
                    // No status found, show inactive
                    if (statusDot) statusDot.className = 'status-dot disconnected';
                    if (statusText) statusText.textContent = 'Inactive';
                    if (timestamp) timestamp.textContent = new Date().toLocaleTimeString();
                    return;
                }

                debug('TRADER', 'Received trader status:', traderStatus);

                // Update status based on data
                const status = traderStatus.status || 'unknown';

                if (statusDot) {
                    statusDot.className = status === 'running'
                        ? 'status-dot connected'
                        : 'status-dot disconnected';
                }

                if (statusText) {
                    statusText.textContent = status.charAt(0).toUpperCase() + status.slice(1);
                    statusText.className = 'value';

                    if (status === 'running') {
                        statusText.classList.add('positive');
                    } else if (status === 'stopping' || status === 'starting') {
                        statusText.classList.add('neutral');
                    } else {
                        statusText.classList.add('negative');
                    }
                }

                // Update long trader status
                if (longTraderStatus) {
                    const longStatus = traderStatus.long_trader_status || 'inactive';
                    longTraderStatus.textContent = longStatus.charAt(0).toUpperCase() + longStatus.slice(1);
                    longTraderStatus.className = 'value';

                    if (longStatus === 'active') {
                        longTraderStatus.classList.add('positive');
                    } else if (longStatus === 'error') {
                        longTraderStatus.classList.add('negative');
                    } else {
                        longTraderStatus.classList.add('neutral');
                    }
                }

                // Update short trader status
                if (shortTraderStatus) {
                    const shortStatus = traderStatus.short_trader_status || 'inactive';
                    shortTraderStatus.textContent = shortStatus.charAt(0).toUpperCase() + shortStatus.slice(1);
                    shortTraderStatus.className = 'value';

                    if (shortStatus === 'active') {
                        shortTraderStatus.classList.add('positive');
                    } else if (shortStatus === 'error') {
                        shortTraderStatus.classList.add('negative');
                    } else {
                        shortTraderStatus.classList.add('neutral');
                    }
                }

                // Update combined PnL
                if (combinedPnL) {
                    const pnl = traderStatus.combined_pnl || 0;
                    combinedPnL.textContent = formatPrice(pnl);
                    combinedPnL.className = 'value';

                    if (pnl > 0) {
                        combinedPnL.classList.add('positive');
                    } else if (pnl < 0) {
                        combinedPnL.classList.add('negative');
                    } else {
                        combinedPnL.classList.add('neutral');
                    }
                }

                // Update last action
                if (lastAction && traderStatus.last_action) {
                    lastAction.textContent = traderStatus.last_action;
                }

                // Update timestamp
                if (timestamp) {
                    let timeStr = 'Unknown';

                    if (traderStatus.timestamp) {
                        try {
                            const date = new Date(traderStatus.timestamp);
                            timeStr = date.toLocaleTimeString();
                        } catch (e) {
                            timeStr = 'Invalid timestamp';
                        }
                    } else {
                        timeStr = new Date().toLocaleTimeString();
                    }

                    timestamp.textContent = timeStr;
                }

            } catch (error) {
                console.error('Error updating trader status:', error);

                // Show error state
                if (statusDot) statusDot.className = 'status-dot disconnected';
                if (statusText) {
                    statusText.textContent = 'Error';
                    statusText.className = 'value negative';
                }
                if (timestamp) timestamp.textContent = `Error: ${new Date().toLocaleTimeString()}`;
            }
        };

        const updateTraderConfig = async () => {
            debug('TRADER', 'Updating trader configuration');
            try {
                // Get config values from UI
                const trapProtection = document.getElementById('trap-protection-toggle').checked;
                const trapThreshold = parseFloat(document.getElementById('trap-threshold').value);
                const longRisk = parseFloat(document.getElementById('long-risk').value);
                const shortRisk = parseFloat(document.getElementById('short-risk').value);

                // Build config object
                const config = {
                    trap_protection: trapProtection,
                    trap_threshold: trapThreshold,
                    long_risk_multiplier: longRisk,
                    short_risk_multiplier: shortRisk,
                    timestamp: new Date().toISOString()
                };

                debug('TRADER', 'Sending config to Redis:', config);

                // Set config in Redis
                try {
                    const response = await fetch(`${API_BASE}/trading/config`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(config)
                    });

                    if (!response.ok) {
                        throw new Error(`Failed to update config: ${response.status}`);
                    }

                    const result = await response.json();
                    debug('TRADER', 'Config update result:', result);
                    animateElement('trading-control-timestamp');

                } catch (fetchError) {
                    console.error('Error sending config to API:', fetchError);
                    // Fallback - try to set directly in Redis
                    try {
                        await fetch(`${API_BASE}/redis-key?key=trader_config`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ value: config })
                        });
                    } catch (redisError) {
                        console.error('Fallback also failed:', redisError);
                    }
                }

            } catch (error) {
                console.error('Error updating trader config:', error);
            }
        };

        const sendTraderCommand = async (command) => {
            debug('TRADER', `Sending trader command: ${command}`);
            try {
                // Build command object
                const commandData = {
                    command: command,
                    timestamp: new Date().toISOString()
                };

                // Send command to API
                try {
                    const response = await fetch(`${API_BASE}/trading/${command}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`Failed to send command: ${response.status}`);
                    }

                    const result = await response.json();
                    debug('TRADER', `Command ${command} result:`, result);

                    // Update status immediately
                    await updateTraderStatus();

                } catch (fetchError) {
                    console.error(`Error sending ${command} command to API:`, fetchError);
                    // Fallback - try to set directly in Redis
                    try {
                        await fetch(`${API_BASE}/redis-key?key=trader_commands`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ value: commandData })
                        });
                        await updateTraderStatus();
                    } catch (redisError) {
                        console.error('Fallback also failed:', redisError);
                    }
                }

            } catch (error) {
                console.error(`Error in sendTraderCommand(${command}):`, error);
            }
        };

        // Set up UI event handlers
        document.addEventListener('DOMContentLoaded', function () {
            // Hook up control buttons
            const startTradingBtn = document.getElementById('start-trading-btn');
            const stopTradingBtn = document.getElementById('stop-trading-btn');

            if (startTradingBtn) {
                startTradingBtn.addEventListener('click', () => {
                    debug('TRADER', 'Start trading button clicked');
                    sendTraderCommand('start');
                });
            }

            if (stopTradingBtn) {
                stopTradingBtn.addEventListener('click', () => {
                    debug('TRADER', 'Stop trading button clicked');
                    sendTraderCommand('stop');
                });
            }

            // Hook up range sliders
            const trapThresholdSlider = document.getElementById('trap-threshold');
            const trapThresholdValue = document.getElementById('trap-threshold-value');
            const longRiskSlider = document.getElementById('long-risk');
            const longRiskValue = document.getElementById('long-risk-value');
            const shortRiskSlider = document.getElementById('short-risk');
            const shortRiskValue = document.getElementById('short-risk-value');

            if (trapThresholdSlider && trapThresholdValue) {
                trapThresholdSlider.addEventListener('input', () => {
                    trapThresholdValue.textContent = trapThresholdSlider.value;
                });

                trapThresholdSlider.addEventListener('change', () => {
                    updateTraderConfig();
                });
            }

            if (longRiskSlider && longRiskValue) {
                longRiskSlider.addEventListener('input', () => {
                    longRiskValue.textContent = longRiskSlider.value;
                });

                longRiskSlider.addEventListener('change', () => {
                    updateTraderConfig();
                });
            }

            if (shortRiskSlider && shortRiskValue) {
                shortRiskSlider.addEventListener('input', () => {
                    shortRiskValue.textContent = shortRiskSlider.value;
                });

                shortRiskSlider.addEventListener('change', () => {
                    updateTraderConfig();
                });
            }

            // Hook up toggle
            const trapProtectionToggle = document.getElementById('trap-protection-toggle');
            if (trapProtectionToggle) {
                trapProtectionToggle.addEventListener('change', () => {
                    updateTraderConfig();
                });
            }

            // Initial load of trader config
            const loadTraderConfig = async () => {
                try {
                    const config = await fetchRedisKey('trader_config');
                    if (config) {
                        debug('TRADER', 'Loaded trader config from Redis:', config);

                        // Update UI with config values
                        if (trapProtectionToggle && config.trap_protection !== undefined) {
                            trapProtectionToggle.checked = config.trap_protection;
                        }

                        if (trapThresholdSlider && trapThresholdValue && config.trap_threshold !== undefined) {
                            trapThresholdSlider.value = config.trap_threshold;
                            trapThresholdValue.textContent = config.trap_threshold;
                        }

                        if (longRiskSlider && longRiskValue && config.long_risk_multiplier !== undefined) {
                            longRiskSlider.value = config.long_risk_multiplier;
                            longRiskValue.textContent = config.long_risk_multiplier;
                        }

                        if (shortRiskSlider && shortRiskValue && config.short_risk_multiplier !== undefined) {
                            shortRiskSlider.value = config.short_risk_multiplier;
                            shortRiskValue.textContent = config.short_risk_multiplier;
                        }
                    }
                } catch (error) {
                    console.error('Error loading trader config:', error);
                }
            };

            loadTraderConfig();
            updateTraderStatus();

            // Add trader status to auto-refresh
            setInterval(() => {
                updateTraderStatus();
            }, 5000); // Every 5 seconds
        });
    </script>
</body>

</html>