<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OMEGA BTC AI - Live Reggae Dashboard</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --green-color: #00B52D;
            --yellow-color: #FFD700;
            --red-color: #FF3D00;
            --bg-color: #121212;
            --card-bg: #1E1E1E;
            --text-color: #E0E0E0;
            --muted-color: #AAAAAA;
            --border-color: rgba(255, 215, 0, 0.2);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Courier New', monospace;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            line-height: 1.6;
            background-image:
                radial-gradient(circle at 10% 20%, rgba(0, 181, 45, 0.05) 0%, transparent 20%),
                radial-gradient(circle at 90% 30%, rgba(255, 215, 0, 0.05) 0%, transparent 20%),
                radial-gradient(circle at 50% 70%, rgba(255, 61, 0, 0.05) 0%, transparent 20%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background-color: var(--card-bg);
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }

        .header h1 {
            color: var(--yellow-color);
            margin: 0;
            font-size: 1.8rem;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header h1 i {
            font-size: 1.6rem;
        }

        .price-ticker {
            display: flex;
            align-items: center;
            background: rgba(255, 215, 0, 0.1);
            padding: 5px 15px;
            border-radius: 20px;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
        }

        .btc-price {
            font-weight: bold;
            color: var(--yellow-color);
            margin-right: 10px;
            font-size: 1.3rem;
        }

        .price-change {
            border-radius: 4px;
            padding: 2px 8px;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .price-change.positive {
            background-color: rgba(0, 181, 45, 0.2);
            color: var(--green-color);
        }

        .price-change.negative {
            background-color: rgba(255, 61, 0, 0.2);
            color: var(--red-color);
        }

        .price-change.neutral {
            background-color: rgba(255, 255, 255, 0.2);
            color: var(--yellow-color);
        }

        .status-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: var(--card-bg);
            padding: 10px 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .status-indicator {
            display: flex;
            align-items: center;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .status-dot.connected {
            background-color: var(--green-color);
            box-shadow: 0 0 10px var(--green-color);
            animation: pulse 2s infinite;
        }

        .status-dot.disconnected {
            background-color: var(--red-color);
            box-shadow: 0 0 10px var(--red-color);
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(0, 181, 45, 0.4);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(0, 181, 45, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(0, 181, 45, 0);
            }
        }

        .data-source {
            background-color: rgba(255, 215, 0, 0.2);
            padding: 5px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            color: var(--yellow-color);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }

        @media (min-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr 1fr;
            }
        }

        .card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .card h2 {
            color: var(--yellow-color);
            margin-top: 0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            font-size: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .card h2 i {
            font-size: 1.2rem;
            margin-right: 8px;
        }

        .card h2 .refresh-time {
            font-size: 0.8rem;
            color: var(--muted-color);
            font-weight: normal;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            border-bottom: 1px dotted rgba(255, 255, 255, 0.1);
            padding-bottom: 8px;
        }

        .label {
            color: var(--muted-color);
        }

        .value {
            font-weight: bold;
        }

        .value.positive {
            color: var(--green-color);
        }

        .value.negative {
            color: var(--red-color);
        }

        .value.neutral {
            color: var(--yellow-color);
        }

        .progress-bar {
            width: 100%;
            background-color: rgba(255, 255, 255, 0.1);
            height: 20px;
            border-radius: 10px;
            margin: 15px 0;
            overflow: hidden;
            position: relative;
        }

        .progress-bar-inner {
            height: 100%;
            border-radius: 10px;
            transition: width 1s ease, background-color 1s ease;
            background-image: linear-gradient(to right, var(--green-color), var(--yellow-color), var(--red-color));
            background-size: 200% 100%;
            animation: gradient-shift 3s ease infinite;
        }

        @keyframes gradient-shift {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        .jah-message {
            background: linear-gradient(to right, rgba(0, 181, 45, 0.2), rgba(255, 221, 0, 0.2), rgba(255, 61, 0, 0.2));
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            color: var(--yellow-color);
            margin-top: 20px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
        }

        .jah-message::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg,
                    transparent,
                    rgba(255, 255, 255, 0.1),
                    transparent);
            animation: shine 2s infinite;
        }

        @keyframes shine {
            100% {
                left: 100%;
            }
        }

        .components-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .component-item {
            background-color: rgba(30, 30, 30, 0.5);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid var(--border-color);
        }

        .component-name {
            font-size: 0.9rem;
            color: var(--muted-color);
            margin-bottom: 5px;
        }

        .component-value {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .component-bar {
            flex-grow: 1;
            height: 5px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin: 0 10px;
            overflow: hidden;
        }

        .component-bar-inner {
            height: 100%;
            background-color: var(--yellow-color);
            border-radius: 3px;
            transition: width 0.5s ease;
        }

        .component-number {
            font-weight: bold;
            color: var(--yellow-color);
            font-size: 0.9rem;
        }

        .component-description {
            font-size: 0.8rem;
            color: var(--text-color);
            margin-top: 5px;
            font-style: italic;
        }

        .footer {
            margin-top: 30px;
            text-align: center;
            color: var(--muted-color);
            font-size: 0.9rem;
            padding: 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .footer-icons {
            display: flex;
            gap: 15px;
            margin-top: 5px;
        }

        .footer-icons i {
            color: var(--yellow-color);
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }

        .footer-icons i:hover {
            transform: scale(1.2);
        }

        .refresh-button {
            background-color: #1c384e;
            color: #bcd4e6;
            border: 1px solid #3a546a;
            border-radius: 4px;
            padding: 8px 12px;
            margin-top: 15px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .refresh-button:hover {
            background-color: #2a4e6c;
        }

        .refresh-button:disabled {
            background-color: #1c2832;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .refresh-button i {
            margin-right: 6px;
        }

        .shake {
            animation: shake 0.5s cubic-bezier(.36, .07, .19, .97) both;
        }

        @keyframes shake {

            10%,
            90% {
                transform: translate3d(-1px, 0, 0);
            }

            20%,
            80% {
                transform: translate3d(2px, 0, 0);
            }

            30%,
            50%,
            70% {
                transform: translate3d(-4px, 0, 0);
            }

            40%,
            60% {
                transform: translate3d(4px, 0, 0);
            }
        }

        .btc-logo {
            font-size: 1.5rem;
            margin-right: 8px;
            color: var(--yellow-color);
        }

        /* Add styles for the license disclaimer */
        .license-disclaimer {
            margin-top: 2rem;
            padding: 1rem;
            border-top: 1px solid rgba(255, 215, 0, 0.1);
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
        }

        .license-disclaimer p {
            margin: 0.5rem 0;
        }

        .license-disclaimer a {
            color: rgba(255, 215, 0, 0.7);
            text-decoration: none;
        }

        .license-disclaimer a:hover {
            color: rgba(255, 215, 0, 1);
            text-decoration: underline;
        }

        .position-flow-viz {
            margin-top: 20px;
            border-top: 1px solid var(--border-color);
            padding-top: 15px;
        }

        .position-flow-viz h3 {
            margin-bottom: 10px;
            color: var(--yellow-color);
            font-size: 1.2rem;
        }

        .position-flow-container {
            width: 100%;
            height: 200px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            border: 1px solid var(--border-color);
            position: relative;
        }

        .position-flow-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--muted-color);
            text-align: center;
            font-size: 0.9rem;
            padding: 0 15px;
        }

        #position-flow-canvas {
            width: 100%;
            height: 100%;
        }

        /* Enhanced TP/SL styles */
        .tp-sl-value {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .tp-sl-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .tp-indicator {
            background-color: var(--green-color);
        }

        .sl-indicator {
            background-color: var(--red-color);
        }

        .tp-sl-distance {
            font-size: 0.85em;
            opacity: 0.85;
            margin-left: 8px;
        }

        .tp-sl-active {
            animation: pulse-target 1.5s infinite;
        }

        .tp-sl-close {
            font-weight: bold;
        }

        /* Existing target indicator styles */
        .target-indicator {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }

        .target-indicator-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .target-indicator-dot.close {
            background-color: var(--yellow-color);
            box-shadow: 0 0 8px var(--yellow-color);
        }

        .target-indicator-dot.very-close {
            background-color: var(--green-color);
            box-shadow: 0 0 8px var(--green-color);
            animation: pulse-target 1.5s infinite;
        }

        .target-indicator-dot.reached {
            background-color: var(--green-color);
            box-shadow: 0 0 12px var(--green-color);
        }

        .target-indicator-text {
            font-size: 0.9rem;
        }

        @keyframes pulse-target {
            0% {
                box-shadow: 0 0 0 0 rgba(0, 181, 45, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(0, 181, 45, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(0, 181, 45, 0);
            }
        }

        .fib-level {
            display: inline-block;
            padding: 2px 10px;
            border-radius: 12px;
            background-color: rgba(255, 215, 0, 0.2);
            color: var(--yellow-color);
            font-size: 0.9rem;
            margin-right: 5px;
        }

        /* Redis Monitor Styles */
        .redis-monitor-card {
            margin-top: 20px;
        }

        .redis-monitor-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 15px;
        }

        .redis-stat {
            flex: 1;
            min-width: 150px;
        }

        .redis-keys-section {
            margin-top: 15px;
        }

        .redis-keys-container {
            max-height: 250px;
            overflow-y: auto;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            padding: 10px;
            margin-top: 10px;
        }

        .redis-keys-list {
            font-family: monospace;
        }

        .redis-namespace {
            margin-top: 8px;
            padding: 4px 8px;
            background-color: rgba(0, 40, 80, 0.3);
            border-radius: 3px;
            border-left: 3px solid #4a90e2;
        }

        .redis-namespace-name {
            color: #5dade2;
            font-weight: bold;
        }

        .redis-namespace-keys {
            padding-left: 10px;
            margin: 5px 0;
        }

        .redis-key-item {
            padding: 3px 8px;
            margin: 2px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
        }

        .redis-key-name {
            color: #bcd4e6;
            font-family: monospace;
            padding-right: 10px;
        }

        .redis-key-detail {
            color: #8899aa;
            font-size: 0.85em;
        }

        .redis-key-error {
            color: #ff6b6b;
            padding: 10px;
        }

        .redis-actions {
            margin-top: 15px;
            text-align: center;
        }

        .refresh-btn {
            background-color: #2c3e50;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .refresh-btn:hover {
            background-color: #3c536b;
        }

        .refresh-btn:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        .positive {
            color: #4caf50;
        }

        .negative {
            color: #f44336;
        }

        .neutral {
            color: #8899aa;
        }

        /* End of Redis Monitor Styles */

        .redis-key-loading {
            color: #8899aa;
            font-style: italic;
            text-align: center;
            padding: 10px;
        }

        .redis-namespace {
            margin-top: 8px;
            padding: 4px 8px;
            background-color: rgba(0, 40, 80, 0.3);
            border-radius: 3px;
            border-left: 3px solid #4a90e2;
        }

        .redis-namespace-name {
            color: #5dade2;
            font-weight: bold;
        }

        .redis-key-item {
            padding: 3px 8px;
            margin: 2px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
        }

        .redis-key-name {
            color: #bcd4e6;
            font-family: monospace;
            padding-right: 10px;
        }

        .redis-key-detail {
            color: #8899aa;
            font-size: 0.85em;
        }

        /* HODL Button Styles */
        .hodl-button {
            background: linear-gradient(to right, rgba(0, 181, 45, 0.8), rgba(255, 215, 0, 0.8), rgba(255, 61, 0, 0.8));
            color: white;
            border: none;
            border-radius: 25px;
            font-weight: bold;
            padding: 10px 20px;
            font-size: 1.1rem;
            margin-top: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .hodl-button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
        }

        .hodl-button:active {
            transform: translateY(1px);
        }

        .hodl-button i {
            font-size: 1.3rem;
        }

        /* BTC Price Popup */
        .btc-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background-color: var(--card-bg);
            border: 2px solid var(--yellow-color);
            border-radius: 15px;
            padding: 25px;
            z-index: 1000;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .btc-popup.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            visibility: visible;
        }

        .btc-popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .btc-popup-title {
            color: var(--yellow-color);
            font-size: 1.8rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .btc-popup-close {
            background: none;
            border: none;
            color: var(--muted-color);
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.3s;
        }

        .btc-popup-close:hover {
            color: var(--red-color);
        }

        .btc-popup-content {
            text-align: center;
        }

        .btc-popup-price {
            font-size: 3rem;
            color: var(--yellow-color);
            margin: 15px 0;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
            font-weight: bold;
        }

        .btc-popup-changes {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }

        .btc-popup-change {
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
        }

        .btc-popup-pattern {
            margin-top: 15px;
            padding: 10px;
            background-color: rgba(255, 215, 0, 0.1);
            border-radius: 10px;
            font-size: 1.1rem;
        }

        .btc-popup-time {
            margin-top: 20px;
            color: var(--muted-color);
            font-size: 0.9rem;
        }

        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .popup-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        @keyframes btc-pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        .pulse-animation {
            animation: btc-pulse 1s infinite;
        }

        /* Animation keyframes */
        @keyframes gradient-shift {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        /* BitGet Trader Styles */
        .bitget-card {
            background: linear-gradient(145deg, #1a1a1a, #262626);
            border: 1px solid rgba(76, 175, 80, 0.2);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            padding: 18px;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
        }

        .bitget-card h2 {
            background: linear-gradient(to right, #76b852, #ffeb3b, #ff6d00);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 15px;
            font-weight: 700;
            font-size: 1.4rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .bitget-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(to right, #76b852, #ffeb3b, #ff6d00);
            z-index: 1;
        }

        .position-badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 1px;
            margin-left: 10px;
            display: inline-flex;
            align-items: center;
        }

        .position-badge.long {
            background: rgba(76, 175, 80, 0.15);
            color: #76b852;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .position-badge.short {
            background: rgba(244, 67, 54, 0.15);
            color: #ff6d00;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        .position-badge i {
            margin-right: 5px;
        }

        .bitget-stats {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .bitget-stat-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .bitget-stat-label {
            font-size: 0.7rem;
            color: var(--muted-color);
            margin-bottom: 3px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .bitget-stat-value {
            font-size: 1rem;
            font-weight: bold;
            color: #fff;
            font-family: 'Montserrat', sans-serif;
        }

        .bitget-stat-box.highlight {
            border: 1px solid rgba(76, 175, 80, 0.3);
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.1);
        }

        .bitget-pnl-box {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .bitget-pnl-item {
            text-align: center;
            flex: 1;
        }

        .bitget-pnl-label {
            font-size: 0.8rem;
            color: var(--muted-color);
            margin-bottom: 5px;
        }

        .bitget-pnl-value {
            font-size: 1.5rem;
            font-weight: bold;
            font-family: 'Montserrat', sans-serif;
        }

        .bitget-pnl-value.positive {
            color: #76b852;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .bitget-pnl-value.negative {
            color: #ff6d00;
            text-shadow: 0 0 10px rgba(244, 67, 54, 0.5);
        }

        .bitget-pnl-value.neutral {
            color: #ffeb3b;
            text-shadow: 0 0 10px rgba(255, 235, 59, 0.5);
        }

        .bitget-detail-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .bitget-detail-row {
            padding: 8px 10px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid rgba(255, 255, 255, 0.03);
        }

        .bitget-detail-label {
            font-size: 0.75rem;
            color: var(--muted-color);
        }

        .bitget-detail-value {
            font-size: 0.85rem;
            font-weight: bold;
            color: #fff;
        }

        .bitget-take-profit {
            padding: 10px;
            background: rgba(76, 175, 80, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(76, 175, 80, 0.2);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .bitget-stop-loss {
            padding: 10px;
            background: rgba(244, 67, 54, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(244, 67, 54, 0.2);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .bitget-order-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
            display: inline-block;
        }

        .bitget-order-dot.tp {
            background-color: #76b852;
            box-shadow: 0 0 5px #76b852;
        }

        .bitget-order-dot.sl {
            background-color: #ff6d00;
            box-shadow: 0 0 5px #ff6d00;
        }

        .bitget-actions {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin-top: 10px;
        }

        .bitget-action-btn {
            padding: 8px 0;
            border-radius: 6px;
            text-align: center;
            flex: 1;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .bitget-action-btn.close {
            background: linear-gradient(135deg, #ff6d00, #ff9800);
            color: #000;
        }

        .bitget-action-btn.edit {
            background: linear-gradient(135deg, #ffeb3b, #ffc107);
            color: #000;
        }

        .bitget-action-btn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .liquidation-meter {
            margin-top: 15px;
            position: relative;
        }

        .liquidation-bar {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .liquidation-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: var(--muted-color);
            margin-bottom: 5px;
        }

        .liquidation-progress {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            border-radius: 3px;
            background: linear-gradient(to right, #76b852, #ffeb3b, #ff6d00);
            transition: width 0.5s ease;
        }

        .price-marker {
            position: absolute;
            top: -5px;
            transform: translateX(-50%);
            height: 16px;
            width: 2px;
        }

        .price-marker::after {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .price-marker.current-price::after {
            background: #fff;
            box-shadow: 0 0 5px #fff;
        }

        .price-marker.entry-price::after {
            background: #ffeb3b;
            box-shadow: 0 0 5px #ffeb3b;
        }

        .price-marker-label {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            white-space: nowrap;
        }

        .bitget-timestamp {
            text-align: right;
            font-size: 0.7rem;
            color: var(--muted-color);
            margin-top: 15px;
            font-style: italic;
        }

        @keyframes pulse-price {
            0% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.5);
                opacity: 0.7;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .price-marker.pulsing::after {
            animation: pulse-price 2s infinite;
        }

        .rasta-divider {
            height: 3px;
            background: linear-gradient(to right, #76b852, #ffeb3b, #ff6d00);
            margin: 15px 0;
            border-radius: 3px;
        }

        /* Market Trends Analysis Panel Styles */
        .trends-panel {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .trends-pane {
            background: linear-gradient(145deg, #1a1a1a, #262626);
            border: 1px solid rgba(76, 175, 80, 0.2);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
        }

        .trends-pane::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(to right, #76b852, #ffeb3b, #ff6d00);
            z-index: 1;
        }

        .trends-pane h3 {
            background: linear-gradient(to right, #76b852, #ffeb3b, #ff6d00);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 12px;
            font-weight: 700;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
        }

        .trends-pane h3 i {
            margin-right: 8px;
        }

        .trend-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .trend-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .trend-timeframe {
            font-size: 0.8rem;
            font-weight: bold;
            color: var(--muted-color);
            margin-bottom: 5px;
        }

        .trend-value {
            font-size: 0.9rem;
            font-weight: bold;
        }

        .trend-value.bullish {
            color: var(--green-color);
        }

        .trend-value.bearish {
            color: var(--red-color);
        }

        .trend-value.neutral {
            color: var(--yellow-color);
        }

        .trend-pct {
            font-size: 0.8rem;
            float: right;
        }

        .trend-description {
            font-size: 0.75rem;
            color: var(--muted-color);
            margin-top: 5px;
            font-style: italic;
        }

        .fib-level {
            display: flex;
            justify-content: space-between;
            padding: 5px;
            margin-bottom: 5px;
            border-bottom: 1px dotted rgba(255, 255, 255, 0.1);
        }

        .fib-level-name {
            font-size: 0.85rem;
            font-weight: bold;
        }

        .fib-level-price {
            font-size: 0.85rem;
        }

        .fib-level.active {
            background: rgba(76, 175, 80, 0.15);
            border-radius: 5px;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .trap-indicator {
            display: flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 10px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .trap-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .trap-dot.bull {
            background-color: var(--green-color);
            box-shadow: 0 0 5px var(--green-color);
        }

        .trap-dot.bear {
            background-color: var(--red-color);
            box-shadow: 0 0 5px var(--red-color);
        }

        .trap-info {
            flex: 1;
        }

        .trap-type {
            font-size: 0.85rem;
            font-weight: bold;
            margin-right: 5px;
        }

        .trap-confidence {
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.5);
        }

        .trap-timeframe {
            font-size: 0.75rem;
            color: var(--muted-color);
        }

        .market-regime {
            background: linear-gradient(45deg, rgba(0, 0, 0, 0.3), rgba(30, 30, 30, 0.3));
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .regime-label {
            font-size: 0.75rem;
            color: var(--muted-color);
            margin-bottom: 5px;
        }

        .regime-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #fff;
        }

        .regime-value.high-volatility {
            color: var(--red-color);
        }

        .regime-value.moderate-volatility {
            color: var(--yellow-color);
        }

        .regime-value.low-volatility {
            color: var(--green-color);
        }

        .schumann-resonance {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(45deg, rgba(0, 0, 0, 0.3), rgba(30, 30, 30, 0.3));
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .schumann-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--yellow-color);
            margin: 10px 0;
        }

        .schumann-description {
            font-size: 0.8rem;
            color: var(--muted-color);
        }

        /* Full-width timeframe bar chart */
        .timeframe-chart {
            margin-top: 15px;
            width: 100%;
        }

        .timeframe-bars {
            display: flex;
            height: 40px;
            margin-bottom: 5px;
        }

        .timeframe-bar {
            flex: 1;
            height: 100%;
            margin: 0 2px;
            position: relative;
        }

        .timeframe-bar-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            border-radius: 3px 3px 0 0;
            transition: height 0.3s ease;
        }

        .timeframe-bar-fill.positive {
            background-color: var(--green-color);
        }

        .timeframe-bar-fill.negative {
            background-color: var(--red-color);
        }

        .timeframe-labels {
            display: flex;
            justify-content: space-between;
        }

        .timeframe-label {
            font-size: 0.7rem;
            color: var(--muted-color);
            text-align: center;
            flex: 1;
        }

        /* Trap Analysis Dashboard Panel Styles */
        #trap-analysis-panel {
            position: relative;
            transition: all 0.3s ease;
        }

        .panel-controls {
            display: flex;
            gap: 10px;
        }

        .panel-control-btn,
        .modal-control-btn {
            background: none;
            border: none;
            color: var(--yellow-color);
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 1rem;
        }

        .panel-control-btn:hover,
        .modal-control-btn:hover {
            background-color: rgba(255, 215, 0, 0.2);
            transform: scale(1.1);
        }

        .trap-analysis-content {
            min-height: 300px;
            max-height: 500px;
            overflow: auto;
            position: relative;
        }

        #trap-analysis-container {
            width: 100%;
            height: 100%;
        }

        .loading-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 300px;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 215, 0, 0.3);
            border-radius: 50%;
            border-top-color: var(--yellow-color);
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            color: var(--yellow-color);
            font-size: 1rem;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.show {
            display: flex;
            opacity: 1;
        }

        .modal-content {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            width: 95%;
            height: 95%;
            margin: auto;
            display: flex;
            flex-direction: column;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            color: var(--yellow-color);
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.5rem;
        }

        .modal-controls {
            display: flex;
            gap: 10px;
        }

        .modal-body {
            flex: 1;
            padding: 20px;
            overflow: auto;
        }

        .panel-footer {
            margin-top: 15px;
            text-align: center;
        }

        /* End of Trap Analysis Styles */
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1><i class="fa-brands fa-bitcoin"></i> OMEGA BTC AI REGGAE DASHBOARD</h1>
            <div class="price-ticker">
                <i class="btc-logo fa-brands fa-bitcoin"></i>
                <div id="btcPrice"></div>
                <div id="priceChanges">
                    <span id="shortTermChange"></span>
                    <span id="mediumTermChange"></span>
                </div>
                <div id="dominantPattern"></div>
                <div id="dataSource"></div>
                <div id="lastUpdated"></div>
            </div>
        </div>

        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot disconnected" id="status-dot"></div>
                <span id="status-text">Connecting to Redis...</span>
            </div>
            <div class="data-source" id="data-source">
                <i class="fas fa-database"></i>
                <span>Data Source: Initializing...</span>
            </div>
        </div>

        <div class="dashboard">
            <div class="card">
                <h2>
                    <i class="fas fa-chart-line"></i> TRAP PROBABILITY
                    <span class="refresh-time" id="trap-time">Updating...</span>
                </h2>
                <div class="data-row">
                    <span class="label">Probability:</span>
                    <span id="trap-probability" class="value neutral">0%</span>
                </div>
                <div class="data-row">
                    <span class="label">Type:</span>
                    <span id="trap-type" class="value neutral">Unknown</span>
                </div>
                <div class="data-row">
                    <span class="label">Trend:</span>
                    <span id="trap-trend" class="value neutral">Stable</span>
                </div>
                <div class="data-row">
                    <span class="label">Confidence:</span>
                    <span id="trap-confidence" class="value neutral">0%</span>
                </div>
                <div class="progress-bar">
                    <div id="trap-bar" class="progress-bar-inner" style="width: 0%"></div>
                </div>

                <h3>Components Analysis</h3>
                <div class="components-grid" id="trap-components">
                    <!-- Components will be inserted here -->
                </div>

                <div id="jah-message" class="jah-message">
                    JAH GUIDES THE TRADING PATH!
                </div>
            </div>

            <div class="card">
                <h2><i class="fas fa-chart-line"></i> Position Information <span class="refresh-time"
                        id="position-timestamp">--</span></h2>
                <div class="data-row">
                    <span class="label">Status:</span>
                    <span class="value neutral" id="position-status">No Position</span>
                </div>
                <div class="data-row">
                    <span class="label">Side:</span>
                    <span class="value neutral" id="position-side">--</span>
                </div>
                <div class="data-row">
                    <span class="label">Entry Price:</span>
                    <span class="value" id="entry-price">$0.00</span>
                </div>
                <div class="data-row">
                    <span class="label">Current Price:</span>
                    <span class="value" id="current-price">$0.00</span>
                </div>
                <div class="data-row">
                    <span class="label">Position Size:</span>
                    <span class="value" id="position-size">0.00 BTC</span>
                </div>
                <div class="data-row">
                    <span class="label">Leverage:</span>
                    <span class="value" id="position-leverage">0x</span>
                </div>
                <div class="data-row">
                    <span class="label">Risk Multiplier:</span>
                    <span class="value" id="risk-multiplier">1.00x</span>
                </div>
                <div class="data-row">
                    <span class="label">PnL:</span>
                    <span class="value neutral" id="pnl-percent">0.00%</span> / <span class="value neutral"
                        id="pnl-usd">$0.00</span>
                </div>
                <div class="data-row">
                    <span class="label">Stop Loss:</span>
                    <span class="value" id="stop-loss">$0.00</span>
                </div>
                <div class="data-row">
                    <span class="label">Take Profits:</span>
                    <span class="value" id="take-profits">--</span>
                </div>
                <div class="data-row">
                    <span class="label">Entry Time:</span>
                    <span class="value" id="entry-time">--</span>
                </div>
                <div class="data-row">
                    <span class="label">Source:</span>
                    <span class="value" id="position-source">--</span>
                </div>
            </div>

            <div class="bitget-card">
                <h2>
                    <span><i class="fas fa-rocket"></i> RASTA OMEGA TRADER</span>
                    <span class="position-badge short" id="bg-position-badge">
                        <i class="fas fa-arrow-down"></i> SHORT
                    </span>
                </h2>

                <!-- Position PnL Box -->
                <div class="bitget-pnl-box">
                    <div class="bitget-pnl-item">
                        <div class="bitget-pnl-label">PNL %</div>
                        <div class="bitget-pnl-value negative" id="bg-pnl-percent">-0.66%</div>
                    </div>
                    <div class="bitget-pnl-item">
                        <div class="bitget-pnl-label">PNL $</div>
                        <div class="bitget-pnl-value negative" id="bg-pnl-usd">-$0.32</div>
                    </div>
                </div>

                <!-- Position Stats Grid -->
                <div class="bitget-stats">
                    <div class="bitget-stat-box highlight">
                        <div class="bitget-stat-label">SIZE</div>
                        <div class="bitget-stat-value" id="bg-position-size">0.0113 BTC</div>
                    </div>
                    <div class="bitget-stat-box">
                        <div class="bitget-stat-label">LEVERAGE</div>
                        <div class="bitget-stat-value" id="bg-leverage">20x</div>
                    </div>
                    <div class="bitget-stat-box">
                        <div class="bitget-stat-label">MARGIN</div>
                        <div class="bitget-stat-value" id="bg-margin">$47.58</div>
                    </div>
                </div>

                <!-- Position Details Grid -->
                <div class="bitget-detail-grid">
                    <div class="bitget-detail-row">
                        <div class="bitget-detail-label">ENTRY PRICE</div>
                        <div class="bitget-detail-value" id="bg-entry-price">$84,205.22</div>
                    </div>
                    <div class="bitget-detail-row">
                        <div class="bitget-detail-label">CURRENT PRICE</div>
                        <div class="bitget-detail-value" id="bg-current-price">$84,233.20</div>
                    </div>
                    <div class="bitget-detail-row">
                        <div class="bitget-detail-label">BREAK-EVEN</div>
                        <div class="bitget-detail-value" id="bg-breakeven">$83,798.22</div>
                    </div>
                    <div class="bitget-detail-row">
                        <div class="bitget-detail-label">LIQUIDATION</div>
                        <div class="bitget-detail-value" id="bg-liquidation">$180,264.42</div>
                    </div>
                    <div class="bitget-detail-row">
                        <div class="bitget-detail-label">MARGIN MODE</div>
                        <div class="bitget-detail-value" id="bg-margin-mode">CROSSED</div>
                    </div>
                    <div class="bitget-detail-row">
                        <div class="bitget-detail-label">POSITION MODE</div>
                        <div class="bitget-detail-value" id="bg-position-mode">ONE-WAY</div>
                    </div>
                </div>

                <!-- Take Profit & Stop Loss -->
                <div class="bitget-take-profit" id="bg-tp-container">
                    <div>
                        <span class="bitget-order-dot tp"></span>
                        <span class="bitget-detail-label">TAKE PROFIT</span>
                    </div>
                    <div class="bitget-detail-value" id="bg-take-profit">$83,500.00</div>
                </div>

                <div class="bitget-stop-loss" id="bg-sl-container" style="display: none;">
                    <div>
                        <span class="bitget-order-dot sl"></span>
                        <span class="bitget-detail-label">STOP LOSS</span>
                    </div>
                    <div class="bitget-detail-value" id="bg-stop-loss">NOT SET</div>
                </div>

                <!-- Liquidation Distance Meter -->
                <div class="liquidation-meter">
                    <div class="liquidation-label">
                        <span>Entry</span>
                        <span>Liquidation</span>
                    </div>
                    <div class="liquidation-bar">
                        <div class="liquidation-progress" id="bg-liquidation-progress" style="width: 2%;"></div>
                        <div class="price-marker entry-price" id="bg-entry-marker" style="left: 0%;">
                            <div class="price-marker-label">$84,205</div>
                        </div>
                        <div class="price-marker current-price pulsing" id="bg-current-marker" style="left: 0.1%;">
                            <div class="price-marker-label">$84,233</div>
                        </div>
                    </div>
                </div>

                <!-- Additional Details -->
                <div class="rasta-divider"></div>

                <div class="bitget-stats">
                    <div class="bitget-stat-box">
                        <div class="bitget-stat-label">MARGIN RATIO</div>
                        <div class="bitget-stat-value" id="bg-margin-ratio">0.4%</div>
                    </div>
                    <div class="bitget-stat-box">
                        <div class="bitget-stat-label">TOTAL FEE</div>
                        <div class="bitget-stat-value" id="bg-total-fee">$0.04</div>
                    </div>
                    <div class="bitget-stat-box">
                        <div class="bitget-stat-label">REALIZED PNL</div>
                        <div class="bitget-stat-value positive" id="bg-realized-pnl">$0.08</div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="bitget-actions">
                    <div class="bitget-action-btn close" id="bg-close-position">CLOSE POSITION</div>
                    <div class="bitget-action-btn edit" id="bg-edit-position">EDIT POSITION</div>
                </div>

                <!-- Timestamp -->
                <div class="bitget-timestamp" id="bg-position-timestamp">Updated: Mar 21, 2025 09:38:51 UTC</div>
            </div>

            <!-- Market Trends Analysis Panel -->
            <div class="bitget-card">
                <h2>
                    <span><i class="fas fa-chart-line"></i> MARKET TRENDS ANALYSIS</span>
                    <span class="refresh-time" id="trends-timestamp">--</span>
                </h2>

                <div class="trends-panel">
                    <!-- Timeframe Trends Pane -->
                    <div class="trends-pane">
                        <h3><i class="fas fa-hourglass-half"></i> Timeframe Trends</h3>
                        <div class="trend-grid" id="timeframe-trends">
                            <!-- Trend cards will be added dynamically -->
                            <div class="trend-card">
                                <div class="trend-timeframe">1min</div>
                                <div class="trend-value neutral">Neutral <span class="trend-pct">0.00%</span></div>
                                <div class="trend-description">Waiting for data...</div>
                            </div>
                            <div class="trend-card">
                                <div class="trend-timeframe">5min</div>
                                <div class="trend-value neutral">Neutral <span class="trend-pct">0.00%</span></div>
                                <div class="trend-description">Waiting for data...</div>
                            </div>
                            <div class="trend-card">
                                <div class="trend-timeframe">15min</div>
                                <div class="trend-value neutral">Neutral <span class="trend-pct">0.00%</span></div>
                                <div class="trend-description">Waiting for data...</div>
                            </div>
                            <div class="trend-card">
                                <div class="trend-timeframe">1h</div>
                                <div class="trend-value neutral">Neutral <span class="trend-pct">0.00%</span></div>
                                <div class="trend-description">Waiting for data...</div>
                            </div>
                        </div>

                        <!-- Timeframe Bar Chart -->
                        <div class="timeframe-chart">
                            <div class="timeframe-bars" id="timeframe-bars">
                                <!-- Bars will be added dynamically -->
                            </div>
                            <div class="timeframe-labels" id="timeframe-labels">
                                <!-- Labels will be added dynamically -->
                            </div>
                        </div>
                    </div>

                    <!-- Fibonacci Levels Pane -->
                    <div class="trends-pane">
                        <h3><i class="fas fa-project-diagram"></i> Fibonacci Levels</h3>
                        <div id="fibonacci-levels">
                            <!-- Fibonacci levels will be added dynamically -->
                            <div class="fib-level">
                                <div class="fib-level-name">0.236</div>
                                <div class="fib-level-price">$--</div>
                            </div>
                            <div class="fib-level">
                                <div class="fib-level-name">0.382</div>
                                <div class="fib-level-price">$--</div>
                            </div>
                            <div class="fib-level active">
                                <div class="fib-level-name">0.5</div>
                                <div class="fib-level-price">$--</div>
                            </div>
                            <div class="fib-level">
                                <div class="fib-level-name">0.618</div>
                                <div class="fib-level-price">$--</div>
                            </div>
                            <div class="fib-level">
                                <div class="fib-level-name">0.786</div>
                                <div class="fib-level-price">$--</div>
                            </div>
                        </div>
                    </div>

                    <!-- Market Maker Traps Pane -->
                    <div class="trends-pane">
                        <h3><i class="fas fa-spider"></i> Market Maker Traps</h3>
                        <div id="mm-traps">
                            <!-- Trap indicators will be added dynamically -->
                            <div class="trap-indicator">
                                <div class="trap-dot bull"></div>
                                <div class="trap-info">
                                    <span class="trap-type">Bull Trap</span>
                                    <span class="trap-confidence">70%</span>
                                    <div class="trap-timeframe">15min timeframe</div>
                                </div>
                            </div>
                            <div class="trap-indicator">
                                <div class="trap-dot bear"></div>
                                <div class="trap-info">
                                    <span class="trap-type">Bear Trap</span>
                                    <span class="trap-confidence">85%</span>
                                    <div class="trap-timeframe">1h timeframe</div>
                                </div>
                            </div>
                        </div>
                        <div id="no-traps-message" style="display: none;">
                            <p class="trend-description">No market maker traps detected at this time.</p>
                        </div>
                    </div>

                    <!-- Market Conditions Pane -->
                    <div class="trends-pane">
                        <h3><i class="fas fa-tachometer-alt"></i> Market Conditions</h3>

                        <!-- Market Regime -->
                        <div class="market-regime">
                            <div class="regime-label">MARKET REGIME</div>
                            <div class="regime-value moderate-volatility" id="market-regime">Moderate Volatility Bullish
                            </div>
                        </div>

                        <!-- Volatility -->
                        <div class="market-regime">
                            <div class="regime-label">VOLATILITY</div>
                            <div class="regime-value" id="market-volatility">0.85%</div>
                        </div>

                        <!-- Schumann Resonance -->
                        <div class="schumann-resonance">
                            <div class="regime-label">SCHUMANN RESONANCE</div>
                            <div class="schumann-value" id="schumann-value">7.83 Hz</div>
                            <div class="schumann-description" id="schumann-desc">Aligned with planetary consciousness
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Action buttons -->
                <div class="bitget-actions">
                    <div class="bitget-action-btn edit" id="refresh-trends">REFRESH ANALYSIS</div>
                </div>
            </div>

            <!-- Redis Debug Module -->
            <div class="card">
                <h2><i class="fas fa-database"></i> Redis Monitor <span class="refresh-time"
                        id="redis-monitor-timestamp">--</span></h2>

                <div class="data-row">
                    <span class="label">Connection Status:</span>
                    <span class="value neutral" id="redis-connection-status">Unknown</span>
                </div>

                <div class="data-row">
                    <span class="label">Last Updated:</span>
                    <span class="value" id="redis-last-updated">--</span>
                </div>

                <div class="data-row">
                    <span class="label">Active Keys:</span>
                    <span class="value" id="redis-active-keys">-</span>
                </div>

                <!-- Redis Keys List -->
                <h3>Recent Redis Keys</h3>
                <div class="redis-keys-container"
                    style="max-height: 200px; overflow-y: auto; margin-top: 10px; background-color: rgba(0,0,0,0.2); border-radius: 5px; padding: 10px;">
                    <div id="redis-keys-list">
                        <div class="redis-key-loading">Loading Redis keys...</div>
                    </div>
                </div>

                <button class="refresh-button" id="refresh-redis-info">
                    <i class="fas fa-sync-alt"></i> Refresh Redis Info
                </button>
            </div>

            <!-- Trap-Aware Dual Traders Control Card -->
            <div class="card">
                <h2>
                    <i class="fas fa-robot"></i> Trading Control
                    <span class="refresh-time" id="trading-control-timestamp">--</span>
                </h2>

                <div class="trading-status">
                    <div class="data-row">
                        <span class="label">System Status:</span>
                        <div class="status-indicator">
                            <div class="status-dot disconnected" id="trading-status-dot"></div>
                            <span class="value neutral" id="trading-status-text">Inactive</span>
                        </div>
                    </div>

                    <div class="data-row">
                        <span class="label">Long Trader:</span>
                        <span class="value neutral" id="long-trader-status">Inactive</span>
                    </div>

                    <div class="data-row">
                        <span class="label">Short Trader:</span>
                        <span class="value neutral" id="short-trader-status">Inactive</span>
                    </div>

                    <div class="data-row">
                        <span class="label">Combined PnL:</span>
                        <span class="value neutral" id="combined-pnl">$0.00</span>
                    </div>

                    <div class="data-row">
                        <span class="label">Last Action:</span>
                        <span class="value" id="last-trading-action">--</span>
                    </div>
                </div>

                <h3>Trap Protection Settings</h3>
                <div class="settings-grid"
                    style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0;">
                    <div class="setting-item">
                        <div class="setting-label">Trap Protection:</div>
                        <div class="setting-control">
                            <label class="toggle"
                                style="position: relative; display: inline-block; width: 60px; height: 28px;">
                                <input type="checkbox" id="trap-protection-toggle" checked
                                    style="opacity: 0; width: 0; height: 0;">
                                <span class="slider round"
                                    style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #2196F3; transition: .4s; border-radius: 34px;"></span>
                            </label>
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="setting-label">Trap Threshold:</div>
                        <div class="setting-control">
                            <input type="range" id="trap-threshold" min="0.5" max="0.9" step="0.05" value="0.7"
                                style="width: 100%;">
                            <span id="trap-threshold-value">0.7</span>
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="setting-label">Long Risk:</div>
                        <div class="setting-control">
                            <input type="range" id="long-risk" min="0.1" max="2.0" step="0.1" value="1.0"
                                style="width: 100%;">
                            <span id="long-risk-value">1.0</span>
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="setting-label">Short Risk:</div>
                        <div class="setting-control">
                            <input type="range" id="short-risk" min="0.1" max="2.0" step="0.1" value="1.0"
                                style="width: 100%;">
                            <span id="short-risk-value">1.0</span>
                        </div>
                    </div>
                </div>

                <div class="control-buttons" style="display: flex; justify-content: space-between; margin-top: 20px;">
                    <button id="start-trading-btn" class="refresh-button"
                        style="background-color: var(--green-color); color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                        <i class="fas fa-play"></i> Start Trading
                    </button>
                    <button id="stop-trading-btn" class="refresh-button"
                        style="background-color: var(--red-color); color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                        <i class="fas fa-stop"></i> Stop Trading
                    </button>
                </div>
            </div>
        </div>

        <div class="footer">
            <div>OMEGA BTC AI - Powered by Rastafarian wisdom & Modern AI</div>
            <div class="footer-icons">
                <i class="fa-brands fa-bitcoin"></i>
                <i class="fas fa-brain"></i>
                <i class="fas fa-chart-line"></i>
                <i class="fas fa-code"></i>
            </div>
            <button id="hodl-button" class="hodl-button">
                <i class="fa-brands fa-bitcoin"></i> CHECK BTC PRICE (HODL!)
            </button>
            <div>JAH LOVE ❤️ GUIDE THE WAY</div>
        </div>
    </div>

    <!-- BTC Price Popup -->
    <div id="popup-overlay" class="popup-overlay"></div>
    <div id="btc-popup" class="btc-popup">
        <div class="btc-popup-header">
            <div class="btc-popup-title">
                <i class="fa-brands fa-bitcoin"></i> Bitcoin Price
            </div>
            <button id="btc-popup-close" class="btc-popup-close">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="btc-popup-content">
            <div class="btc-popup-price" id="popup-price">$0.00</div>
            <div class="btc-popup-changes">
                <div class="btc-popup-change" id="popup-change">24h: 0.00%</div>
                <div class="btc-popup-change" id="popup-short-term">Short: 0.00%</div>
                <div class="btc-popup-change" id="popup-medium-term">Medium: 0.00%</div>
            </div>
            <div class="btc-popup-pattern" id="popup-pattern">
                Dominant Pattern: Unknown
            </div>
            <div class="btc-popup-time" id="popup-time">
                Last Updated: --
            </div>
        </div>
    </div>

    <!-- GNU License Disclaimer -->
    <div class="license-disclaimer">
        <p>OMEGA BTC AI - Copyright (C) 2024 OMEGA BTC AI Team</p>
        <p>This program is free software: you can redistribute it and/or modify
            it under the terms of the GNU General Public License as published by
            the Free Software Foundation, either version 3 of the License, or
            (at your option) any later version.</p>
        <p>This program is distributed in the hope that it will be useful,
            but WITHOUT ANY WARRANTY; without even the implied warranty of
            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
            GNU General Public License for more details.</p>
        <p>You should have received a copy of the GNU General Public License
            along with this program. If not, see <a href="https://www.gnu.org/licenses/"
                target="_blank">https://www.gnu.org/licenses/</a></p>
    </div>

    <!-- Trap Analysis Dashboard Panel -->
    <div class="card" id="trap-analysis-panel">
        <h2>
            <i class="fas fa-spider"></i> TRAP ANALYSIS DASHBOARD
            <div class="panel-controls">
                <button class="panel-control-btn" id="expand-trap-btn" title="Expand Panel">
                    <i class="fas fa-expand-alt"></i>
                </button>
                <button class="panel-control-btn" id="fullscreen-trap-btn" title="Full Screen Mode">
                    <i class="fas fa-external-link-alt"></i>
                </button>
            </div>
        </h2>
        <div class="trap-analysis-content">
            <div id="trap-analysis-container">
                <div class="loading-container">
                    <div class="loading-spinner"></div>
                    <div class="loading-text">Loading Trap Analysis Dashboard...</div>
                </div>
            </div>
        </div>
        <div class="panel-footer">
            <button class="refresh-button" id="refresh-trap-analysis">
                <i class="fas fa-sync-alt"></i> Refresh Analysis
            </button>
        </div>
    </div>

    <!-- Trap Analysis Fullscreen Modal -->
    <div id="trap-analysis-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2><i class="fas fa-spider"></i> TRAP ANALYSIS DASHBOARD</h2>
                <div class="modal-controls">
                    <button class="modal-control-btn" id="minimize-trap-btn" title="Minimize Panel">
                        <i class="fas fa-compress-alt"></i>
                    </button>
                    <button class="modal-control-btn" id="close-trap-btn" title="Close Panel">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </div>
            <div class="modal-body" id="trap-analysis-modal-content">
                <!-- Trap analysis will be loaded here -->
            </div>
        </div>
    </div>

    <script>
        // Debug helper
        const DEBUG = true; // Set to false to disable debug logs
        function debug(section, message, data = null) {
            if (!DEBUG) return;
            const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
            if (data) {
                console.log(`${timestamp} [${section}] ${message}`, data);
            } else {
                console.log(`${timestamp} [${section}] ${message}`);
            }
        }

        // API endpoints for Redis data
        const API_BASE = "http://localhost:8001/api";
        const TRAP_ENDPOINT = `${API_BASE}/trap-probability`;
        const POSITION_ENDPOINT = `${API_BASE}/position`;
        const BTC_PRICE_ENDPOINT = `${API_BASE}/btc-price`;
        const REDIS_KEYS_ENDPOINT = `${API_BASE}/redis-keys`;
        const COMBINED_DATA_ENDPOINT = `${API_BASE}/data`;
        const HEALTH_ENDPOINT = `${API_BASE}/health`;

        // Animation helper for UI feedback
        const animateElement = (elementId) => {
            const element = document.getElementById(elementId);
            if (element) {
                element.classList.add('shake');
                setTimeout(() => {
                    element.classList.remove('shake');
                }, 500);
            }
        };

        // Function to shake the JAH message for UI feedback
        const shakeJahMessage = () => {
            // Try with hyphen (HTML/CSS convention)
            let jahMessage = document.getElementById('jah-message');

            // Fallback to underscore if hyphen version not found
            if (!jahMessage) {
                jahMessage = document.getElementById('jah_message');
            }

            // If either version exists, apply the animation
            if (jahMessage) {
                jahMessage.classList.add('shake');
                setTimeout(() => {
                    jahMessage.classList.remove('shake');
                }, 500);
            } else {
                console.warn('JAH message element not found');
            }
        };

        // Alias for shakeJahMessage to maintain compatibility with existing code
        const animateJahMessage = shakeJahMessage;

        // Helper function to format a price as USD
        const formatPrice = (price) => {
            if (price === null || price === undefined || isNaN(price)) {
                return '$0.00';
            }

            // Format with comma separators and fixed decimal places
            const formatter = new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            });

            return formatter.format(price);
        };

        // Helper function to format a value as USD with variable decimal places
        const formatUsd = (value) => {
            if (value === null || value === undefined || isNaN(value)) {
                return '$0.00';
            }

            // Determine appropriate decimal places based on value
            const absValue = Math.abs(value);
            let decimalPlaces = 2;

            if (absValue < 1) {
                decimalPlaces = 4;
            } else if (absValue < 0.01) {
                decimalPlaces = 6;
            }

            // Format with comma separators and appropriate decimal places
            const formatter = new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: decimalPlaces,
                maximumFractionDigits: decimalPlaces
            });

            return formatter.format(value);
        };

        // Helper function to format a percentage
        const formatPercent = (percent) => {
            if (percent === null || percent === undefined || isNaN(percent)) {
                return '0.00%';
            }

            // Add a plus sign for positive values
            const sign = percent >= 0 ? '+' : '';

            // Format with appropriate decimal places
            const absPercent = Math.abs(percent);
            let decimalPlaces = 2;

            if (absPercent < 0.1) {
                decimalPlaces = 4;
            }

            return `${sign}${absPercent.toFixed(decimalPlaces)}%`;
        };

        // Helper function to format a timestamp as a relative time difference
        const formatTimeDiff = (timestamp) => {
            if (!timestamp) return 'Just now';

            try {
                const now = new Date();
                const time = new Date(timestamp);

                // If invalid date, return the raw timestamp
                if (isNaN(time.getTime())) {
                    return String(timestamp);
                }

                const diffMs = now - time;
                const diffSec = Math.floor(diffMs / 1000);

                if (diffSec < 60) {
                    return diffSec <= 5 ? 'Just now' : `${diffSec} seconds ago`;
                }

                const diffMin = Math.floor(diffSec / 60);
                if (diffMin < 60) {
                    return `${diffMin} minute${diffMin > 1 ? 's' : ''} ago`;
                }

                const diffHour = Math.floor(diffMin / 60);
                if (diffHour < 24) {
                    return `${diffHour} hour${diffHour > 1 ? 's' : ''} ago`;
                }

                // Just return the time if it's more than a day old
                return time.toLocaleTimeString();

            } catch (error) {
                console.error('Error formatting time difference:', error);
                return 'Unknown time';
            }
        };

        // Helper function to fetch Redis key value with retries
        const fetchRedisKey = async (key, retries = 1) => {
            debug('REDIS', `Fetching Redis key value for: ${key}`);
            try {
                // Use the new direct Redis key access endpoint
                const response = await fetch(`${API_BASE}/redis-key?key=${encodeURIComponent(key)}`);
                if (!response.ok) {
                    throw new Error(`Failed to fetch Redis key ${key}: ${response.status}`);
                }

                const data = await response.json();
                debug('REDIS', `Received data for key ${key}:`, data);

                if (data.status === 'error') {
                    throw new Error(data.error || `Error fetching key ${key}`);
                }

                return data.value;
            } catch (error) {
                console.error(`Error fetching Redis key ${key}:`, error);
                if (retries > 0) {
                    debug('REDIS', `Retrying fetch for key ${key}, ${retries} retries left`);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    return fetchRedisKey(key, retries - 1);
                }
                return null;
            }
        };

        // Helper function to find the dominant pattern
        const findDominantPattern = (patterns) => {
            let dominantPattern = 'Unknown';
            let highestProb = 0;

            for (const [pattern, probability] of Object.entries(patterns)) {
                if (probability > highestProb) {
                    highestProb = probability;
                    dominantPattern = pattern;
                }
            }

            return dominantPattern;
        };

        // Helper function to find the highest probability
        const findHighestProbability = (patterns) => {
            let highestProb = 0;

            for (const probability of Object.values(patterns)) {
                if (probability > highestProb) {
                    highestProb = probability;
                }
            }

            return highestProb;
        };

        // Function to check Redis connection status
        const checkRedisStatus = async () => {
            try {
                const response = await fetch(HEALTH_ENDPOINT);
                if (!response.ok) {
                    return { connected: false, message: 'Backend connection failed' };
                }

                const data = await response.json();
                return {
                    connected: data.redis === 'connected',
                    message: data.redis === 'connected' ? 'Connected to Redis' : 'Redis connection issue'
                };
            } catch (error) {
                console.error('Error checking Redis status:', error);
                return { connected: false, message: 'Connection error' };
            }
        };

        // Function to update Redis debug information
        const updateRedisDebugInfo = async () => {
            const connectionStatusElement = document.getElementById('redis-connection-status');
            const lastUpdatedElement = document.getElementById('redis-last-updated');
            const activeKeysElement = document.getElementById('redis-active-keys');
            const keysListElement = document.getElementById('redis-keys-list');

            try {
                // Check Redis connection status
                const redisStatus = await checkRedisStatus();
                connectionStatusElement.textContent = redisStatus.connected ? 'Connected' : 'Disconnected';
                connectionStatusElement.className = redisStatus.connected ? 'value positive' : 'value negative';

                if (redisStatus.connected) {
                    // Fetch Redis keys to check what's available
                    const response = await fetch(REDIS_KEYS_ENDPOINT);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch Redis keys: ${response.status}`);
                    }

                    const keysData = await response.json();
                    debug('REDIS', 'Received Redis keys data:', keysData);

                    // Update keys count
                    if (keysData.total_keys) {
                        activeKeysElement.textContent = `${keysData.displayed_keys || 0}/${keysData.total_keys} keys`;
                    } else {
                        activeKeysElement.textContent = `${keysData.keys?.length || 0} keys`;
                    }

                    // Update keys list
                    if (keysListElement && keysData.keys && keysData.keys.length > 0) {
                        keysListElement.innerHTML = '';

                        // Group keys by namespace (first part before colon)
                        const keysByNamespace = {};
                        keysData.keys.forEach(keyInfo => {
                            const key = keyInfo.key;
                            const namespace = key.includes(':') ? key.split(':')[0] : 'other';

                            if (!keysByNamespace[namespace]) {
                                keysByNamespace[namespace] = [];
                            }

                            keysByNamespace[namespace].push(keyInfo);
                        });

                        // Create elements for each namespace
                        for (const [namespace, keys] of Object.entries(keysByNamespace)) {
                            const namespaceEl = document.createElement('div');
                            namespaceEl.className = 'redis-namespace';
                            namespaceEl.innerHTML = `<div class="redis-namespace-name">${namespace}</div>`;

                            const keysEl = document.createElement('div');
                            keysEl.className = 'redis-namespace-keys';

                            keys.forEach(keyInfo => {
                                const keyEl = document.createElement('div');
                                keyEl.className = 'redis-key-item';

                                let details = '';
                                if (keyInfo.type) {
                                    details += `type: ${keyInfo.type}`;
                                }
                                if (keyInfo.length !== undefined) {
                                    details += details ? ', ' : '';
                                    details += `length: ${keyInfo.length}`;
                                }
                                if (keyInfo.fields !== undefined) {
                                    details += details ? ', ' : '';
                                    details += `fields: ${keyInfo.fields}`;
                                }

                                keyEl.innerHTML = `
                                    <span class="redis-key-name">${keyInfo.key}</span>
                                    <span class="redis-key-detail">${details}</span>
                                `;

                                keysEl.appendChild(keyEl);
                            });

                            namespaceEl.appendChild(keysEl);
                            keysListElement.appendChild(namespaceEl);
                        }
                    } else {
                        keysListElement.innerHTML = '<div class="redis-key-error">No Redis keys found</div>';
                    }
                } else {
                    activeKeysElement.textContent = '0 keys';
                    keysListElement.innerHTML = `<div class="redis-key-error">Redis connection failed: ${redisStatus.message}</div>`;
                }

                // Update last updated timestamp
                lastUpdatedElement.textContent = new Date().toLocaleTimeString();

            } catch (error) {
                console.error('Error updating Redis debug info:', error);

                connectionStatusElement.textContent = 'Error';
                connectionStatusElement.className = 'value negative';
                activeKeysElement.textContent = 'Error';
                lastUpdatedElement.textContent = new Date().toLocaleTimeString();

                if (keysListElement) {
                    keysListElement.innerHTML = `<div class="redis-key-error">Error: ${error.message}</div>`;
                }
            }
        };

        // Function to update the BTC price ticker in the header
        const updateBTCPriceTicker = async () => {
            debug('PRICE_TICKER', 'Updating BTC price ticker in header');
            try {
                // Get BTC price data from Redis
                let price = null;
                let priceKeyUsed = '';

                // Try different possible keys for price data
                for (const priceKey of ['btc_price', 'last_btc_price', 'sim_last_btc_price']) {
                    try {
                        const priceData = await fetchRedisKey(priceKey);
                        if (priceData !== null) {
                            debug('PRICE', `Found BTC price in key: ${priceKey}`, priceData);
                            // Handle different data types - string or number
                            if (typeof priceData === 'string') {
                                price = parseFloat(priceData);
                            } else if (typeof priceData === 'number') {
                                price = priceData;
                            } else if (typeof priceData === 'object' && priceData.hasOwnProperty('price')) {
                                // Handle case where we got an object with a price property
                                price = parseFloat(priceData.price);
                            }

                            // Validate parsed price is a valid number
                            if (!isNaN(price) && price > 0) {
                                priceKeyUsed = priceKey;
                                break;
                            } else {
                                price = null; // Reset if we got NaN or invalid value
                            }
                        }
                    } catch (error) {
                        debug('PRICE', `Error parsing price from ${priceKey}:`, error);
                        // Continue trying other keys
                    }
                }

                if (price === null || isNaN(price)) {
                    debug('PRICE', 'Could not find valid BTC price in any Redis key, using fallback');
                    // Fallback to a realistic default price if we couldn't get a valid price
                    price = 65000 + (Math.random() * 5000 - 2500); // Random price around $65,000
                    priceKeyUsed = 'fallback';
                }

                // Get price changes data with better error handling
                let shortTermChange = 0;
                let mediumTermChange = 0;

                try {
                    const changesData = await fetchRedisKey('btc_price_changes');
                    if (changesData) {
                        // Safely extract and validate the values
                        if (changesData.short_term !== undefined && !isNaN(parseFloat(changesData.short_term))) {
                            shortTermChange = parseFloat(changesData.short_term);
                        }
                        if (changesData.medium_term !== undefined && !isNaN(parseFloat(changesData.medium_term))) {
                            mediumTermChange = parseFloat(changesData.medium_term);
                        }
                    }
                } catch (error) {
                    debug('PRICE', 'Error getting price changes data:', error);
                    // Use realistic fallback values
                    shortTermChange = (Math.random() * 0.04) - 0.01; // -1% to +3%
                    mediumTermChange = (Math.random() * 0.06) - 0.02; // -2% to +4%
                }

                // Get price patterns data with better error handling
                let dominantPattern = 'Unknown';
                let patternsData = {};

                try {
                    const patterns = await fetchRedisKey('btc_price_patterns');
                    if (patterns && typeof patterns === 'object') {
                        patternsData = patterns;
                        dominantPattern = findDominantPattern(patterns);
                    }
                } catch (error) {
                    debug('PRICE', 'Error getting price patterns data:', error);
                    // Use fallback patterns
                    patternsData = {
                        'Wyckoff Distribution': 0.65,
                        'Double Top': 0.35,
                        'Bull Flag': 0.25,
                        'Head and Shoulders': 0.15
                    };
                    dominantPattern = 'Wyckoff Distribution';
                }

                // Prepare the data object
                const data = {
                    price: price,
                    shortTermChange: shortTermChange,
                    mediumTermChange: mediumTermChange,
                    dominantPattern: dominantPattern,
                    patterns: patternsData,
                    source: priceKeyUsed,
                    timestamp: new Date().toISOString()
                };

                debug('PRICE', 'Prepared price data:', data);

                // Update the price display in header
                const btcPrice = document.getElementById('btcPrice');
                if (btcPrice) {
                    btcPrice.textContent = formatPrice(data.price);
                    btcPrice.classList.add('btc-price');
                    btcPrice.setAttribute('title', `Source: ${data.source}`);
                }

                // Update short-term and medium-term changes
                const shortTermElement = document.getElementById('shortTermChange');
                const mediumTermElement = document.getElementById('mediumTermChange');

                if (shortTermElement && data.shortTermChange !== null) {
                    shortTermElement.textContent = formatPercent(data.shortTermChange);
                    shortTermElement.className = data.shortTermChange >= 0 ? 'price-change positive' : 'price-change negative';
                }

                if (mediumTermElement && data.mediumTermChange !== null) {
                    mediumTermElement.textContent = formatPercent(data.mediumTermChange);
                    mediumTermElement.className = data.mediumTermChange >= 0 ? 'price-change positive' : 'price-change negative';
                }

                // Update dominant pattern
                const dominantPatternElement = document.getElementById('dominantPattern');
                if (dominantPatternElement && data.dominantPattern) {
                    // Capitalize pattern name
                    const capitalizedPattern = data.dominantPattern.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    dominantPatternElement.textContent = capitalizedPattern;
                }

                debug('PRICE_TICKER', 'BTC price ticker in header updated successfully');
            } catch (error) {
                console.error('Error updating BTC price ticker:', error);

                // Try using combined data endpoint as fallback
                try {
                    const response = await fetch(COMBINED_DATA_ENDPOINT);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch combined data: ${response.status}`);
                    }

                    const combinedData = await response.json();
                    if (combinedData.btc_price && combinedData.btc_price.price) {
                        const btcPrice = document.getElementById('btcPrice');
                        if (btcPrice) {
                            btcPrice.textContent = formatPrice(combinedData.btc_price.price);
                        }
                    }
                } catch (fallbackError) {
                    console.error('Fallback for BTC price also failed:', fallbackError);
                    const btcPrice = document.getElementById('btcPrice');
                    if (btcPrice) {
                        btcPrice.textContent = 'Price Unavailable';
                    }
                }
            }
        };

        // Wait for DOM to be fully loaded before setting up event handlers
        document.addEventListener('DOMContentLoaded', function () {
            debug('INIT', 'DOM fully loaded, initializing dashboard');

            // DOM Elements for reference
            const statusDot = document.getElementById('status-dot');
            const statusText = document.getElementById('status-text');
            const dataSource = document.getElementById('data-source').querySelector('span');
            const btcPrice = document.getElementById('btcPrice');
            const priceChange = document.getElementById('priceChanges');
            const trapTime = document.getElementById('trap-time');
            const positionTime = document.getElementById('position-time');
            const refreshButton = document.getElementById('refresh-data');

            // HODL Button elements
            const hodlButton = document.getElementById('hodl-button');
            const btcPopup = document.getElementById('btc-popup');
            const popupOverlay = document.getElementById('popup-overlay');
            const popupCloseBtn = document.getElementById('btc-popup-close');

            // Set up event handlers for the HODL button and popup
            if (hodlButton) {
                debug('INIT', 'Setting up HODL button event listener');
                hodlButton.addEventListener('click', function (e) {
                    debug('HODL', 'HODL button clicked');
                    e.preventDefault();
                    showBTCPrice();
                });
            } else {
                console.error('HODL button not found in the DOM');
            }

            // Set up popup close button event listener
            if (popupCloseBtn) {
                popupCloseBtn.addEventListener('click', function () {
                    debug('HODL', 'Popup close button clicked');
                    popupOverlay.classList.remove('show');
                    btcPopup.classList.remove('show');
                });
            }

            // Set up overlay event listener
            if (popupOverlay) {
                popupOverlay.addEventListener('click', function () {
                    debug('HODL', 'Popup overlay clicked');
                    popupOverlay.classList.remove('show');
                    btcPopup.classList.remove('show');
                });
            }

            // Initialize the dashboard with auto-refresh
            startAutoRefresh();

            debug('INIT', 'Event handlers set up');
        });

        // Function to update the trap probability card
        const updateTrapProbability = async () => {
            debug('TRAP', 'Updating trap probability card');

            // Get DOM elements
            const probabilityElement = document.getElementById('trap-probability');
            const typeElement = document.getElementById('trap-type');
            const trendElement = document.getElementById('trap-trend');
            const confidenceElement = document.getElementById('trap-confidence');
            const progressBar = document.getElementById('trap-bar');
            const componentsGrid = document.getElementById('trap-components');
            const trapTimeElement = document.getElementById('trap-time');

            try {
                // Show updating indicator
                if (trapTimeElement) {
                    trapTimeElement.textContent = 'Updating...';
                }

                // Try to get trap data from Redis
                let trapData = null;

                // Try multiple potential Redis keys for trap data
                for (const key of ['current_trap_probability', 'trap_probability', 'latest_trap_analysis']) {
                    const data = await fetchRedisKey(key);
                    if (data) {
                        debug('TRAP', `Found trap data in key: ${key}`, data);
                        trapData = data;
                        break;
                    }
                }

                // Fallback to API endpoint if Redis key not found
                if (!trapData) {
                    debug('TRAP', 'No trap data found in Redis, trying API endpoint');
                    try {
                        const response = await fetch(`${API_BASE}/trap-probability`);
                        if (response.ok) {
                            trapData = await response.json();
                            debug('TRAP', 'Got trap data from API endpoint', trapData);
                        }
                    } catch (apiError) {
                        debug('TRAP', 'Error fetching from API endpoint:', apiError);
                    }
                }

                // Generate mock data if we still don't have trap data
                if (!trapData) {
                    debug('TRAP', 'Generating mock trap data');
                    const probability = Math.random() * 0.7 + 0.2; // 20% to 90%
                    trapData = {
                        probability: probability,
                        trap_type: probability > 0.6 ? 'Bull Trap' : 'Bear Trap',
                        trend: probability > 0.5 ? 'increasing' : 'decreasing',
                        confidence: Math.random() * 0.8 + 0.1, // 10% to 90%
                        components: {
                            price_action: Math.random() * 0.9,
                            volume_analysis: Math.random() * 0.8,
                            liquidity: Math.random() * 0.85,
                            sentiment: Math.random() * 0.75
                        },
                        timestamps: {
                            detected: new Date().toISOString()
                        },
                        source: 'mock'
                    };
                }

                // Safely extract data with validation
                const probability = parseFloat(trapData.probability) || 0;
                const type = trapData.trap_type || 'Unknown';
                const trend = trapData.trend || 'stable';
                const confidence = parseFloat(trapData.confidence) || 0;

                // Format timestamp
                let timestamp = 'N/A';
                if (trapData.timestamp) {
                    timestamp = new Date(trapData.timestamp).toLocaleTimeString();
                } else if (trapData.timestamps && trapData.timestamps.detected) {
                    timestamp = new Date(trapData.timestamps.detected).toLocaleTimeString();
                } else {
                    timestamp = new Date().toLocaleTimeString();
                }

                // Add source indicator if mock data
                if (trapData.source === 'mock') {
                    timestamp += ' (mock)';
                }

                // Get components safely
                const components = trapData.components || {};

                // Update probability and progress bar
                if (probabilityElement) {
                    probabilityElement.textContent = `${Math.round(probability * 100)}%`;
                }

                if (progressBar) {
                    progressBar.style.width = `${Math.round(probability * 100)}%`;

                    // Update color based on probability
                    const hue = ((1 - probability) * 120).toString(10);
                    progressBar.style.backgroundColor = `hsl(${hue}, 80%, 45%)`;
                }

                // Update trap type and trend
                if (typeElement) {
                    typeElement.textContent = type;
                }

                if (trendElement) {
                    trendElement.textContent = trend.charAt(0).toUpperCase() + trend.slice(1);

                    // Add trend direction indicator
                    if (trend === 'increasing') {
                        trendElement.innerHTML += ' ↑';
                        trendElement.style.color = '#ff4c4c';
                    } else if (trend === 'decreasing') {
                        trendElement.innerHTML += ' ↓';
                        trendElement.style.color = '#4caf50';
                    }
                }

                // Update confidence
                if (confidenceElement) {
                    confidenceElement.textContent = `${Math.round(confidence * 100)}%`;
                }

                // Update components grid
                if (componentsGrid) {
                    componentsGrid.innerHTML = '';

                    // Create component items
                    Object.entries(components).forEach(([key, value]) => {
                        // Ensure value is a number and not NaN
                        const componentValue = parseFloat(value);
                        if (isNaN(componentValue)) {
                            return; // Skip invalid components
                        }

                        // Format key for display
                        const formattedKey = key
                            .replace(/_/g, ' ')
                            .split(' ')
                            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                            .join(' ');

                        // Calculate percentage
                        const percent = Math.round(componentValue * 100);

                        // Create component element
                        const componentEl = document.createElement('div');
                        componentEl.className = 'component-item';

                        // Adjust background color based on value
                        const hue = ((1 - componentValue) * 120).toString(10);

                        componentEl.innerHTML = `
                            <div class="component-name">${formattedKey}</div>
                            <div class="component-value">
                                <div class="component-bar" style="width: ${percent}%; background-color: hsl(${hue}, 80%, 45%)"></div>
                                <span class="value-text">${percent}%</span>
                            </div>
                        `;

                        componentsGrid.appendChild(componentEl);
                    });

                    // If no components were added, show a message
                    if (componentsGrid.children.length === 0) {
                        componentsGrid.innerHTML = '<div class="no-components">No component data available</div>';
                    }
                }

                // Update time
                if (trapTimeElement) {
                    trapTimeElement.textContent = timestamp;
                }

                // Trigger JAH wisdom message and animation effect
                if (probability > 0.5) {
                    animateJahMessage();
                }

            } catch (error) {
                console.error('Error updating trap probability card:', error);

                // Show error state
                if (probabilityElement) probabilityElement.textContent = 'N/A';
                if (typeElement) typeElement.textContent = 'Error';
                if (trendElement) trendElement.textContent = 'Unknown';
                if (confidenceElement) confidenceElement.textContent = 'N/A';
                if (progressBar) progressBar.style.width = '0%';
                if (componentsGrid) componentsGrid.innerHTML = '<div class="component-error">Error loading components</div>';
                if (trapTimeElement) trapTimeElement.textContent = `Error: ${new Date().toLocaleTimeString()}`;
            }
        };

        // Function to update the position information card
        const updatePositionInfo = async () => {
            debug('POSITION', 'Updating position information card');

            // Get DOM elements
            const statusElement = document.getElementById('position-status');
            const sideElement = document.getElementById('position-side');
            const entryPriceElement = document.getElementById('entry-price');
            const currentPriceElement = document.getElementById('current-price');
            const positionSizeElement = document.getElementById('position-size');
            const leverageElement = document.getElementById('position-leverage');
            const riskMultiElement = document.getElementById('risk-multiplier');
            const pnlPercentElement = document.getElementById('pnl-percent');
            const pnlUsdElement = document.getElementById('pnl-usd');
            const stopLossElement = document.getElementById('stop-loss');
            const takeProfitsElement = document.getElementById('take-profits');
            const entryTimeElement = document.getElementById('entry-time');
            const sourceElement = document.getElementById('position-source');
            const timestampElement = document.getElementById('position-timestamp');

            try {
                // Show updating indicator
                if (timestampElement) {
                    timestampElement.textContent = 'Updating...';
                }

                // Try to get position data from Redis
                let positionData = null;

                // Try multiple potential Redis keys for position data
                for (const key of ['current_position', 'active_position', 'position_data']) {
                    const data = await fetchRedisKey(key);
                    if (data) {
                        debug('POSITION', `Found position data in key: ${key}`, data);
                        positionData = data;
                        break;
                    }
                }

                // Fallback to API endpoint if Redis key not found
                if (!positionData) {
                    debug('POSITION', 'No position data found in Redis, trying API endpoint');
                    try {
                        const response = await fetch(`${API_BASE}/position`);
                        if (response.ok) {
                            positionData = await response.json();
                            debug('POSITION', 'Got position data from API endpoint', positionData);
                        }
                    } catch (apiError) {
                        debug('POSITION', 'Error fetching from API endpoint:', apiError);
                    }
                }

                // Get current BTC price for calculations or use the one from position data
                let currentPrice = positionData && positionData.current_price ? parseFloat(positionData.current_price) : null;

                // If no current price in position data, try to get from Redis
                if (!currentPrice) {
                    try {
                        for (const priceKey of ['btc_price', 'last_btc_price', 'sim_last_btc_price']) {
                            const price = await fetchRedisKey(priceKey);
                            if (price !== null) {
                                if (typeof price === 'number') {
                                    currentPrice = price;
                                } else if (typeof price === 'string') {
                                    currentPrice = parseFloat(price);
                                } else if (typeof price === 'object' && price.hasOwnProperty('price')) {
                                    currentPrice = parseFloat(price.price);
                                }

                                if (!isNaN(currentPrice) && currentPrice > 0) {
                                    break;
                                } else {
                                    currentPrice = null;
                                }
                            }
                        }
                    } catch (priceError) {
                        debug('POSITION', 'Error getting current price:', priceError);
                    }
                }

                // Use fallback price if we couldn't get a real one
                if (currentPrice === null || isNaN(currentPrice)) {
                    currentPrice = 65000 + (Math.random() * 3000 - 1500);
                }

                // Check if we have a position or not
                if (positionData && positionData.has_position) {
                    // Format timestamps
                    let updateTime = new Date().toLocaleTimeString();
                    let entryTime = 'Unknown';
                    let dataSource = positionData.source || 'API';

                    // Handle timestamp conversion - could be milliseconds timestamp or ISO string
                    if (positionData.timestamp) {
                        const timestamp = typeof positionData.timestamp === 'number'
                            ? positionData.timestamp
                            : new Date(positionData.timestamp).getTime();

                        // If timestamp is in milliseconds since epoch
                        if (timestamp > 1000000000000) {
                            updateTime = new Date(timestamp).toLocaleTimeString();
                        } else {
                            // If timestamp is in seconds since epoch
                            updateTime = new Date(timestamp * 1000).toLocaleTimeString();
                        }
                    }

                    // Handle entry time conversion - could be milliseconds timestamp or ISO string
                    if (positionData.entry_time) {
                        const entryTimestamp = typeof positionData.entry_time === 'number'
                            ? positionData.entry_time
                            : new Date(positionData.entry_time).getTime();

                        // If timestamp is in milliseconds since epoch
                        if (entryTimestamp > 1000000000000) {
                            entryTime = new Date(entryTimestamp).toLocaleTimeString();
                        } else {
                            // If timestamp is in seconds since epoch
                            entryTime = new Date(entryTimestamp * 1000).toLocaleTimeString();
                        }
                    }

                    // Safely extract position data
                    const side = positionData.position_side || 'unknown';
                    const entryPrice = parseFloat(positionData.entry_price) || 0;
                    const positionSize = parseFloat(positionData.position_size) || 0;
                    const leverage = parseInt(positionData.leverage) || 1;
                    const riskMultiplier = parseFloat(positionData.risk_multiplier) || 1;
                    const stopLoss = parseFloat(positionData.stop_loss) || 0;
                    const takeProfit = positionData.take_profits || [];

                    // Get PnL data
                    let pnlPercent = positionData.pnl_percent !== undefined
                        ? parseFloat(positionData.pnl_percent)
                        : 0;

                    let pnlUsd = positionData.pnl_usd !== undefined
                        ? parseFloat(positionData.pnl_usd)
                        : 0;

                    // Calculate PnL if needed
                    if ((pnlPercent === 0 || isNaN(pnlPercent)) && entryPrice > 0 && currentPrice > 0) {
                        // Calculate PnL based on side
                        if (side.toLowerCase() === 'long') {
                            pnlPercent = ((currentPrice - entryPrice) / entryPrice) * 100 * leverage;
                            if (positionSize > 0) {
                                pnlUsd = (currentPrice - entryPrice) * positionSize * leverage;
                            }
                        } else if (side.toLowerCase() === 'short') {
                            pnlPercent = ((entryPrice - currentPrice) / entryPrice) * 100 * leverage;
                            if (positionSize > 0) {
                                pnlUsd = (entryPrice - currentPrice) * positionSize * leverage;
                            }
                        }
                    }

                    // Update status
                    if (statusElement) {
                        statusElement.textContent = 'ACTIVE';
                        statusElement.className = 'value positive';
                    }

                    // Update side with icon
                    if (sideElement) {
                        const formattedSide = side.charAt(0).toUpperCase() + side.slice(1);
                        if (side.toLowerCase() === 'long') {
                            sideElement.innerHTML = `${formattedSide} ↑`;
                            sideElement.className = 'value positive';
                        } else if (side.toLowerCase() === 'short') {
                            sideElement.innerHTML = `${formattedSide} ↓`;
                            sideElement.className = 'value negative';
                        } else {
                            sideElement.textContent = formattedSide;
                            sideElement.className = 'value neutral';
                        }
                    }

                    // Update prices
                    if (entryPriceElement) {
                        entryPriceElement.textContent = formatPrice(entryPrice);
                    }

                    if (currentPriceElement) {
                        currentPriceElement.textContent = formatPrice(currentPrice);
                    }

                    // Update position details
                    if (positionSizeElement) {
                        positionSizeElement.textContent = `${positionSize.toFixed(4)} BTC`;
                    }

                    if (leverageElement) {
                        // Check if there's expected_leverage data
                        if (positionData.expected_leverage !== undefined && positionData.leverage_mismatch) {
                            // Display both values with a warning if they don't match
                            leverageElement.innerHTML = `${leverage}x <span class="warning" title="Expected: ${positionData.expected_leverage}x">⚠️</span>`;
                            leverageElement.style.color = '#ff9900'; // Warning color
                        } else {
                            // Just display the actual leverage
                            leverageElement.textContent = `${leverage}x`;
                            leverageElement.style.color = ''; // Reset color
                        }
                    }

                    if (riskMultiElement) {
                        riskMultiElement.textContent = `${riskMultiplier.toFixed(2)}x`;
                    }

                    // Update PnL with color coding
                    if (pnlPercentElement) {
                        pnlPercentElement.textContent = `${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%`;

                        if (pnlPercent >= 1) {
                            pnlPercentElement.className = 'value positive';
                        } else if (pnlPercent < 0) {
                            pnlPercentElement.className = 'value negative';
                        } else {
                            pnlPercentElement.className = 'value neutral';
                        }
                    }

                    // Update USD PnL
                    if (pnlUsdElement) {
                        pnlUsdElement.textContent = `${pnlUsd >= 0 ? '+' : ''}${formatUsd(pnlUsd)}`;

                        if (pnlUsd >= 1) {
                            pnlUsdElement.className = 'value positive';
                        } else if (pnlUsd < 0) {
                            pnlUsdElement.className = 'value negative';
                        } else {
                            pnlUsdElement.className = 'value neutral';
                        }
                    }

                    // Update stop loss
                    if (stopLossElement) {
                        if (stopLoss > 0) {
                            // Enhanced SL display with distance indicator
                            let slDistance = '';
                            let slClass = '';

                            // Add distance information if available
                            if (positionData.stop_loss_distance !== undefined && positionData.stop_loss_distance !== null) {
                                const distance = parseFloat(positionData.stop_loss_distance);
                                slDistance = `<span class="tp-sl-distance">(${distance >= 0 ? '+' : ''}${distance.toFixed(2)}%)</span>`;

                                // Add visual indicators based on distance
                                if (distance < 1) {
                                    slClass = 'tp-sl-close tp-sl-active';
                                } else if (distance < 3) {
                                    slClass = 'tp-sl-close';
                                }
                            }

                            stopLossElement.innerHTML = `
                                <span class="tp-sl-value">
                                    <span class="tp-sl-indicator sl-indicator ${slClass}"></span>
                                    ${formatPrice(stopLoss)}
                                    ${slDistance}
                                </span>
                            `;
                        } else {
                            stopLossElement.textContent = 'Not Set';
                        }
                    }

                    // Update take profits
                    if (takeProfitsElement) {
                        const takeProfit = positionData.take_profit || 0;

                        if (takeProfit > 0) {
                            // Enhanced TP display with distance indicator
                            let tpDistance = '';
                            let tpClass = '';

                            // Add distance information if available
                            if (positionData.take_profit_distance !== undefined && positionData.take_profit_distance !== null) {
                                const distance = parseFloat(positionData.take_profit_distance);
                                tpDistance = `<span class="tp-sl-distance">(${distance >= 0 ? '+' : ''}${distance.toFixed(2)}%)</span>`;

                                // Add visual indicators based on distance
                                if (distance < 0.5) {
                                    tpClass = 'tp-sl-close tp-sl-active';
                                } else if (distance < 2) {
                                    tpClass = 'tp-sl-close';
                                }
                            }

                            takeProfitsElement.innerHTML = `
                                <span class="tp-sl-value">
                                    <span class="tp-sl-indicator tp-indicator ${tpClass}"></span>
                                    ${formatPrice(takeProfit)}
                                    ${tpDistance}
                                </span>
                            `;
                        } else if (Array.isArray(takeProfit) && takeProfit.length > 0) {
                            // Format take profits as a string
                            const takeProfitText = takeProfit.map(tp => {
                                if (typeof tp === 'object' && tp.price) {
                                    const price = parseFloat(tp.price);
                                    const pct = tp.percentage ? parseFloat(tp.percentage) * 100 : '';
                                    return `${formatPrice(price)}${pct ? ` (${pct.toFixed(0)}%)` : ''}`;
                                } else if (typeof tp === 'number') {
                                    return formatPrice(tp);
                                }
                                return '';
                            }).join(', ');

                            takeProfitsElement.textContent = takeProfitText || 'Not Set';
                        } else {
                            takeProfitsElement.textContent = 'Not Set';
                        }
                    }

                    // Update times
                    if (entryTimeElement) {
                        entryTimeElement.textContent = entryTime;
                    }

                    // Update source
                    if (sourceElement) {
                        sourceElement.textContent = dataSource;
                    }

                    // Update timestamp
                    if (timestampElement) {
                        timestampElement.textContent = updateTime;
                    }

                } else {
                    // No active position - show "No Position" state
                    if (statusElement) {
                        statusElement.textContent = 'NO POSITION';
                        statusElement.className = 'value neutral';
                    }

                    // Clear other fields
                    if (sideElement) sideElement.textContent = 'N/A';
                    if (entryPriceElement) entryPriceElement.textContent = 'N/A';
                    if (currentPriceElement) currentPriceElement.textContent = formatPrice(currentPrice);
                    if (positionSizeElement) positionSizeElement.textContent = 'N/A';
                    if (leverageElement) leverageElement.textContent = 'N/A';
                    if (riskMultiElement) riskMultiElement.textContent = 'N/A';
                    if (pnlPercentElement) pnlPercentElement.textContent = '0.00%';
                    if (pnlUsdElement) pnlUsdElement.textContent = '$0.00';
                    if (stopLossElement) stopLossElement.textContent = '$0.00';
                    if (takeProfitsElement) takeProfitsElement.textContent = '--';
                    if (entryTimeElement) entryTimeElement.textContent = 'N/A';
                    if (sourceElement) sourceElement.textContent = '--';

                    // Update timestamp
                    if (timestampElement) {
                        const timestamp = new Date().toLocaleTimeString();
                        timestampElement.textContent = timestamp;
                    }
                }

                // Call our enhanced BitGet trader UI update function
                // Pass the position data to display in the Rasta Omega Trader UI
                await updateBitGetTraderUI(positionData);

            } catch (error) {
                console.error('Error updating position information:', error);

                // Show error state
                if (statusElement) statusElement.textContent = 'ERROR';
                if (sideElement) sideElement.textContent = 'ERROR';
                if (entryPriceElement) entryPriceElement.textContent = 'ERROR';
                if (currentPriceElement) currentPriceElement.textContent = 'ERROR';
                if (positionSizeElement) positionSizeElement.textContent = 'ERROR';
                if (leverageElement) leverageElement.textContent = 'ERROR';
                if (riskMultiElement) riskMultiElement.textContent = 'ERROR';
                if (pnlPercentElement) pnlPercentElement.textContent = 'ERROR';
                if (pnlUsdElement) pnlUsdElement.textContent = 'ERROR';
                if (stopLossElement) stopLossElement.textContent = 'ERROR';
                if (takeProfitsElement) takeProfitsElement.textContent = 'ERROR';
                if (entryTimeElement) entryTimeElement.textContent = 'ERROR';
                if (sourceElement) sourceElement.textContent = 'ERROR';

                if (timestampElement) {
                    timestampElement.textContent = `Error: ${new Date().toLocaleTimeString()}`;
                }
            }
        };

        // Function to update position close targets
        const updatePositionTargets = async () => {
            debug('TARGETS', 'Updating position close targets');

            // Get DOM elements
            const statusElement = document.getElementById('target-status');
            const nextTargetElement = document.getElementById('next-target-price');
            const targetPercentElement = document.getElementById('next-target-percent');
            const distanceElement = document.getElementById('target-distance');
            const etaElement = document.getElementById('target-eta');
            const fibLevelElement = document.getElementById('fib-level');
            const progressBar = document.getElementById('target-progress-bar');
            const timestampElement = document.getElementById('target-timestamp');

            try {
                // First update timestamp to show we're working
                if (timestampElement) {
                    timestampElement.textContent = 'Updating...';
                }

                // Try to fetch target data directly from Redis
                let targetData = await fetchRedisKey('position_targets');
                let generatedMockData = false;

                // If no targets data in Redis, try to create mock data based on position
                if (!targetData) {
                    debug('TARGETS', 'No position_targets in Redis, trying to generate mock data');
                    try {
                        // Get position data to create mock targets
                        const positionData = await fetchRedisKey('current_position');

                        if (positionData && positionData.has_position) {
                            debug('TARGETS', 'Found position data, generating mock targets');
                            // Get latest price data for accurate calculations
                            let currentPrice = 0;
                            try {
                                for (const priceKey of ['btc_price', 'last_btc_price', 'sim_last_btc_price']) {
                                    const price = await fetchRedisKey(priceKey);
                                    if (price !== null) {
                                        currentPrice = typeof price === 'number' ? price : parseFloat(price);
                                        debug('TARGETS', `Using current price from ${priceKey}: ${currentPrice}`);
                                        break;
                                    }
                                }
                            } catch (priceError) {
                                debug('TARGETS', `Error getting price data: ${priceError.message}`);
                                // Use position's current price as fallback
                                currentPrice = positionData.current_price || 0;
                            }

                            // Get position details for target calculation
                            const entryPrice = positionData.entry_price || currentPrice;
                            const isLong = (positionData.position_side || '').toLowerCase() === 'long';

                            // If we don't have both prices, use some defaults
                            if (!entryPrice || !currentPrice) {
                                debug('TARGETS', 'Missing price data, using defaults');
                                const defaultPrice = 65000; // Default BTC price if we can't get real data
                                currentPrice = currentPrice || defaultPrice;
                                const entryPrice = entryPrice || defaultPrice * 0.99; // 1% below default as a fallback
                            }

                            // Calculate targets based on position type
                            const targetPercent = isLong ? 0.05 : -0.05; // 5% target
                            const targetPrice = isLong
                                ? entryPrice * (1 + targetPercent)
                                : entryPrice * (1 - targetPercent);

                            // Calculate progress towards target
                            const priceDistance = isLong
                                ? (targetPrice - currentPrice) / targetPrice
                                : (currentPrice - targetPrice) / currentPrice;

                            // Ensure completion percent is between 0-100%
                            const completionPercent = Math.max(0, Math.min(1 - priceDistance, 1));

                            targetData = {
                                has_targets: true,
                                next_target: {
                                    price: targetPrice,
                                    percent: targetPercent,
                                    distance: priceDistance,
                                    eta_minutes: Math.round(priceDistance * 120), // Mock ETA
                                    completion_percent: completionPercent,
                                    fib_level: '0.382'
                                },
                                timestamp: new Date().toISOString()
                            };
                            generatedMockData = true;
                            debug('TARGETS', 'Generated mock target data:', targetData);
                        } else {
                            debug('TARGETS', 'No position data found, using empty targets');
                            // No position found, use empty targets
                            targetData = {
                                has_targets: false,
                                timestamp: new Date().toISOString()
                            };
                            generatedMockData = true;
                        }
                    } catch (mockDataError) {
                        debug('TARGETS', `Error generating mock data: ${mockDataError.message}`);
                        // If mock data generation fails, use empty data
                        targetData = {
                            has_targets: false,
                            error: mockDataError.message,
                            timestamp: new Date().toISOString()
                        };
                    }
                }

                // Update UI with target data - always update even if there are no targets
                if (targetData) {
                    debug('TARGETS', 'Position targets data:', targetData);

                    // Update target status
                    if (statusElement) {
                        const hasTargets = targetData.has_targets || false;
                        statusElement.textContent = hasTargets ? 'Active' : 'No Targets';
                        statusElement.className = 'value';
                        statusElement.classList.add(hasTargets ? 'positive' : 'neutral');
                    }

                    // If there are targets, update all fields
                    if (targetData.has_targets && targetData.next_target) {
                        const target = targetData.next_target;

                        // Update next target price
                        if (nextTargetElement && target.price) {
                            nextTargetElement.textContent = formatPrice(target.price);
                        }

                        // Update target percent
                        if (targetPercentElement && target.percent !== undefined) {
                            const percentValue = target.percent * 100;
                            targetPercentElement.textContent = `${percentValue.toFixed(2)}%`;
                            targetPercentElement.className = 'value';
                            if (percentValue > 0) {
                                targetPercentElement.classList.add('positive');
                            } else if (percentValue < 0) {
                                targetPercentElement.classList.add('negative');
                            } else {
                                targetPercentElement.classList.add('neutral');
                            }
                        }

                        // Update distance to target
                        if (distanceElement && target.distance !== undefined) {
                            const distancePercent = target.distance * 100;
                            distanceElement.textContent = `${distancePercent.toFixed(2)}%`;
                            distanceElement.className = 'value';

                            // Color based on how close we are (closer is better)
                            if (distancePercent < 2) {
                                distanceElement.classList.add('positive');
                            } else if (distancePercent < 5) {
                                distanceElement.classList.add('neutral');
                            } else {
                                distanceElement.classList.add('negative');
                            }
                        }

                        // Update ETA
                        if (etaElement && target.eta_minutes !== undefined) {
                            if (target.eta_minutes < 1) {
                                etaElement.textContent = 'Imminent';
                            } else if (target.eta_minutes < 60) {
                                etaElement.textContent = `~${target.eta_minutes} minutes`;
                            } else {
                                const hours = Math.floor(target.eta_minutes / 60);
                                etaElement.textContent = `~${hours} hour${hours > 1 ? 's' : ''}`;
                            }
                        }

                        // Update Fibonacci level
                        if (fibLevelElement && target.fib_level) {
                            fibLevelElement.textContent = target.fib_level;
                        }

                        // Update progress bar - crucial for displaying progress
                        if (progressBar && target.completion_percent !== undefined) {
                            const percent = target.completion_percent * 100;
                            progressBar.style.width = `${percent}%`;
                            debug('TARGETS', `Setting progress bar width to ${percent}%`);
                        }
                    } else {
                        // Reset fields if no targets
                        if (nextTargetElement) nextTargetElement.textContent = '$0.00';
                        if (targetPercentElement) {
                            targetPercentElement.textContent = '0.00%';
                            targetPercentElement.className = 'value neutral';
                        }
                        if (distanceElement) {
                            distanceElement.textContent = '0.00%';
                            distanceElement.className = 'value neutral';
                        }
                        if (etaElement) etaElement.textContent = '--';
                        if (fibLevelElement) fibLevelElement.textContent = '--';

                        // Always set progress bar to 0% when no targets available
                        if (progressBar) {
                            progressBar.style.width = '0%';
                            debug('TARGETS', 'Resetting progress bar to 0%');
                        }
                    }

                    // Update timestamp
                    if (timestampElement) {
                        if (targetData.timestamp) {
                            timestampElement.textContent = formatTimeDiff(targetData.timestamp);
                        } else {
                            timestampElement.textContent = 'Just now';
                        }

                        // Add indicator if this was generated data
                        if (generatedMockData) {
                            timestampElement.textContent += ' (mock)';
                        }
                    }
                }
            } catch (error) {
                console.error('Error updating position targets:', error);

                // Create fallback display values for error case
                if (statusElement) {
                    statusElement.textContent = 'No Targets';
                    statusElement.className = 'value neutral';
                }

                if (nextTargetElement) nextTargetElement.textContent = '$0.00';
                if (targetPercentElement) {
                    targetPercentElement.textContent = '0.00%';
                    targetPercentElement.className = 'value neutral';
                }
                if (distanceElement) {
                    distanceElement.textContent = '0.00%';
                    distanceElement.className = 'value neutral';
                }
                if (etaElement) etaElement.textContent = '--';
                if (fibLevelElement) fibLevelElement.textContent = '--';

                // Ensure progress bar is set to 0% in error case
                if (progressBar) {
                    progressBar.style.width = '0%';
                    debug('TARGETS', 'Resetting progress bar to 0% due to error');
                }

                if (timestampElement) {
                    const now = new Date();
                    timestampElement.textContent = `${now.toLocaleTimeString()} (error)`;
                }
            }
        };

        // Set up auto-refresh for all components
        const startAutoRefresh = () => {
            // Check connection status
            const updateConnectionStatus = async () => {
                try {
                    const response = await fetch(HEALTH_ENDPOINT);
                    if (!response.ok) {
                        throw new Error(`Health check failed: ${response.status}`);
                    }

                    const healthData = await response.json();
                    const isConnected = healthData.redis === 'connected';

                    // Update status indicator
                    const statusDot = document.getElementById('status-dot');
                    const statusText = document.getElementById('status-text');

                    if (statusDot) {
                        statusDot.className = isConnected ? 'status-dot connected' : 'status-dot disconnected';
                    }

                    if (statusText) {
                        statusText.textContent = isConnected ? 'Connected to Redis' : 'Disconnected from Redis';
                    }

                    // Update data source 
                    const dataSourceEl = document.getElementById('data-source');
                    if (dataSourceEl) {
                        const dataSourceSpan = dataSourceEl.querySelector('span');
                        if (dataSourceSpan) {
                            dataSourceSpan.textContent = `Data Source: ${isConnected ? 'Redis' : 'Fallback'}`;
                        }
                    }

                    return isConnected;
                } catch (error) {
                    console.error('Error checking connection status:', error);

                    // Update status to disconnected
                    const statusDot = document.getElementById('status-dot');
                    const statusText = document.getElementById('status-text');

                    if (statusDot) {
                        statusDot.className = 'status-dot disconnected';
                    }

                    if (statusText) {
                        statusText.textContent = 'Connection Error';
                    }

                    return false;
                }
            };

            // Initial updates
            const initializeDashboard = async () => {
                const isConnected = await updateConnectionStatus();
                debug('INIT', `Initial connection status: ${isConnected ? 'Connected' : 'Disconnected'}`);

                // Fetch initial data
                updateBTCPriceTicker();
                updateTrapProbability();
                updatePositionInfo();
                updatePositionTargets();
                updateRedisDebugInfo();

                // Set up refresh intervals

                // Every 5 seconds:
                setInterval(() => {
                    updateBTCPriceTicker();
                    updateConnectionStatus();
                }, 5000);

                // Every 10 seconds:
                setInterval(() => {
                    updateTrapProbability();
                    updatePositionInfo();
                    updatePositionTargets();
                }, 10000);

                // Every 30 seconds:
                setInterval(() => {
                    updateRedisDebugInfo();
                }, 30000);

                debug('INIT', 'Auto-refresh intervals set up');
            };

            // Start the dashboard
            initializeDashboard();
        };

        // Start auto-refresh when document is ready
        startAutoRefresh();

        // Function to display BTC price popup
        const showBTCPrice = async () => {
            debug('HODL', 'Showing BTC price popup');
            const popupOverlay = document.getElementById('popup-overlay');
            const btcPopup = document.getElementById('btc-popup');
            const popupPrice = document.getElementById('popup-price');
            const popupChange = document.getElementById('popup-change');
            const popupShortTerm = document.getElementById('popup-short-term');
            const popupMediumTerm = document.getElementById('popup-medium-term');
            const popupPattern = document.getElementById('popup-pattern');
            const popupTime = document.getElementById('popup-time');

            // Show popup with loading state
            popupOverlay.classList.add('show');
            btcPopup.classList.add('show');

            if (popupPrice) popupPrice.innerHTML = 'Loading...';
            if (popupPattern) popupPattern.innerHTML = 'Checking patterns...';

            try {
                // Try to fetch the current BTC price from Redis
                let price = null;
                // Try different possible keys for price data
                for (const priceKey of ['btc_price', 'last_btc_price', 'sim_last_btc_price']) {
                    price = await fetchRedisKey(priceKey);
                    if (price !== null) {
                        debug('HODL', `Found BTC price in key: ${priceKey}`);
                        break;
                    }
                }

                if (price === null) {
                    throw new Error('Could not find BTC price in any Redis key');
                }

                // Get price changes data
                const changesData = await fetchRedisKey('btc_price_changes');

                // Get price patterns data
                const patternsData = await fetchRedisKey('btc_price_patterns');

                // Prepare the normalized data object
                const priceData = {
                    price: typeof price === 'number' ? price : parseFloat(price),
                    change: 0, // 24h change (not available in Redis currently)
                    shortTermChange: (changesData && changesData.short_term) ? changesData.short_term : 0,
                    mediumTermChange: (changesData && changesData.medium_term) ? changesData.medium_term : 0,
                    dominantPattern: findDominantPattern(patternsData || {}),
                    dominantPatternProbability: findHighestProbability(patternsData || {}),
                    patterns: patternsData || {},
                    timestamp: new Date().toISOString()
                };

                debug('HODL', 'BTC price data for popup:', priceData);

                // Update popup content
                if (popupPrice) {
                    popupPrice.innerHTML = formatPrice(priceData.price);
                    popupPrice.classList.add('pulse-animation');
                    setTimeout(() => popupPrice.classList.remove('pulse-animation'), 2000);
                }

                // Update 24h change
                if (popupChange) {
                    const change = priceData.change || 0;
                    popupChange.innerHTML = `24h: ${formatPercent(change)}`;
                    popupChange.className = 'btc-popup-change';
                    if (change > 0) popupChange.classList.add('positive');
                    else if (change < 0) popupChange.classList.add('negative');
                    else popupChange.classList.add('neutral');
                }

                // Update short-term change
                if (popupShortTerm) {
                    const shortChange = priceData.shortTermChange || 0;
                    popupShortTerm.innerHTML = `Short: ${formatPercent(shortChange)}`;
                    popupShortTerm.className = 'btc-popup-change';
                    if (shortChange > 0) popupShortTerm.classList.add('positive');
                    else if (shortChange < 0) popupShortTerm.classList.add('negative');
                    else popupShortTerm.classList.add('neutral');
                }

                // Update medium-term change
                if (popupMediumTerm) {
                    const mediumChange = priceData.mediumTermChange || 0;
                    popupMediumTerm.innerHTML = `Medium: ${formatPercent(mediumChange)}`;
                    popupMediumTerm.className = 'btc-popup-change';
                    if (mediumChange > 0) popupMediumTerm.classList.add('positive');
                    else if (mediumChange < 0) popupMediumTerm.classList.add('negative');
                    else popupMediumTerm.classList.add('neutral');
                }

                // Update pattern
                if (popupPattern) {
                    const pattern = priceData.dominantPattern || 'Unknown';
                    const probability = priceData.dominantPatternProbability || 0;

                    // Format pattern name for display
                    const patternName = pattern
                        .split('_')
                        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                        .join(' ');

                    popupPattern.innerHTML = `Dominant Pattern: ${patternName} (${Math.round(probability * 100)}%)`;
                }

                // Update time
                if (popupTime) {
                    popupTime.innerHTML = `Last Updated: ${new Date().toLocaleTimeString()}`;
                }

                // Shake the popup for emphasis
                btcPopup.classList.add('shake');
                setTimeout(() => btcPopup.classList.remove('shake'), 500);

                // Trigger JAH message animation for added effect
                shakeJahMessage();
            } catch (error) {
                console.error('Error showing BTC price:', error);

                // Try fallback to the combined data endpoint
                try {
                    const response = await fetch(COMBINED_DATA_ENDPOINT);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch combined data: ${response.status}`);
                    }

                    const combinedData = await response.json();
                    const btcData = combinedData.btc_price;

                    if (btcData && btcData.price) {
                        // Update popup with available data
                        if (popupPrice) {
                            popupPrice.innerHTML = formatPrice(btcData.price);
                        }

                        if (popupPattern) {
                            popupPattern.innerHTML = 'Pattern data not available';
                        }

                        if (popupTime) {
                            popupTime.innerHTML = `Last Updated: ${new Date().toLocaleTimeString()}`;
                        }
                    } else {
                        throw new Error('No price data in combined endpoint');
                    }
                } catch (fallbackError) {
                    console.error('Error with fallback data source:', fallbackError);

                    // Show error state
                    if (popupPrice) popupPrice.innerHTML = 'Error loading price';
                    if (popupPattern) popupPattern.innerHTML = 'Could not load pattern data';

                    // Shake the popup to indicate error
                    btcPopup.classList.add('shake');
                    setTimeout(() => btcPopup.classList.remove('shake'), 500);
                }
            }
        };

        // Trap-Aware Dual Trader functionality
        const updateTraderStatus = async () => {
            debug('TRADER', 'Updating trader status');
            const statusDot = document.getElementById('trading-status-dot');
            const statusText = document.getElementById('trading-status-text');
            const longTraderStatus = document.getElementById('long-trader-status');
            const shortTraderStatus = document.getElementById('short-trader-status');
            const combinedPnL = document.getElementById('combined-pnl');
            const lastAction = document.getElementById('last-trading-action');
            const timestamp = document.getElementById('trading-control-timestamp');

            try {
                // Get trader status from Redis
                const traderStatus = await fetchRedisKey('trader_status');

                if (!traderStatus) {
                    // No status found, show inactive
                    if (statusDot) statusDot.className = 'status-dot disconnected';
                    if (statusText) statusText.textContent = 'Inactive';
                    if (timestamp) timestamp.textContent = new Date().toLocaleTimeString();
                    return;
                }

                debug('TRADER', 'Received trader status:', traderStatus);

                // Update status based on data
                const status = traderStatus.status || 'unknown';

                if (statusDot) {
                    statusDot.className = status === 'running'
                        ? 'status-dot connected'
                        : 'status-dot disconnected';
                }

                if (statusText) {
                    statusText.textContent = status.charAt(0).toUpperCase() + status.slice(1);
                    statusText.className = 'value';

                    if (status === 'running') {
                        statusText.classList.add('positive');
                    } else if (status === 'stopping' || status === 'starting') {
                        statusText.classList.add('neutral');
                    } else {
                        statusText.classList.add('negative');
                    }
                }

                // Update long trader status
                if (longTraderStatus) {
                    const longStatus = traderStatus.long_trader_status || 'inactive';
                    longTraderStatus.textContent = longStatus.charAt(0).toUpperCase() + longStatus.slice(1);
                    longTraderStatus.className = 'value';

                    if (longStatus === 'active') {
                        longTraderStatus.classList.add('positive');
                    } else if (longStatus === 'error') {
                        longTraderStatus.classList.add('negative');
                    } else {
                        longTraderStatus.classList.add('neutral');
                    }
                }

                // Update short trader status
                if (shortTraderStatus) {
                    const shortStatus = traderStatus.short_trader_status || 'inactive';
                    shortTraderStatus.textContent = shortStatus.charAt(0).toUpperCase() + shortStatus.slice(1);
                    shortTraderStatus.className = 'value';

                    if (shortStatus === 'active') {
                        shortTraderStatus.classList.add('positive');
                    } else if (shortStatus === 'error') {
                        shortTraderStatus.classList.add('negative');
                    } else {
                        shortTraderStatus.classList.add('neutral');
                    }
                }

                // Update combined PnL
                if (combinedPnL) {
                    const pnl = traderStatus.combined_pnl || 0;
                    combinedPnL.textContent = formatPrice(pnl);
                    combinedPnL.className = 'value';

                    if (pnl > 0) {
                        combinedPnL.classList.add('positive');
                    } else if (pnl < 0) {
                        combinedPnL.classList.add('negative');
                    } else {
                        combinedPnL.classList.add('neutral');
                    }
                }

                // Update last action
                if (lastAction && traderStatus.last_action) {
                    lastAction.textContent = traderStatus.last_action;
                }

                // Update timestamp
                if (timestamp) {
                    let timeStr = 'Unknown';

                    if (traderStatus.timestamp) {
                        try {
                            const date = new Date(traderStatus.timestamp);
                            timeStr = date.toLocaleTimeString();
                        } catch (e) {
                            timeStr = 'Invalid timestamp';
                        }
                    } else {
                        timeStr = new Date().toLocaleTimeString();
                    }

                    timestamp.textContent = timeStr;
                }

            } catch (error) {
                console.error('Error updating trader status:', error);

                // Show error state
                if (statusDot) statusDot.className = 'status-dot disconnected';
                if (statusText) {
                    statusText.textContent = 'Error';
                    statusText.className = 'value negative';
                }
                if (timestamp) timestamp.textContent = `Error: ${new Date().toLocaleTimeString()}`;
            }
        };

        const updateTraderConfig = async () => {
            debug('TRADER', 'Updating trader configuration');
            try {
                // Get config values from UI
                const trapProtection = document.getElementById('trap-protection-toggle').checked;
                const trapThreshold = parseFloat(document.getElementById('trap-threshold').value);
                const longRisk = parseFloat(document.getElementById('long-risk').value);
                const shortRisk = parseFloat(document.getElementById('short-risk').value);

                // Build config object
                const config = {
                    trap_protection: trapProtection,
                    trap_threshold: trapThreshold,
                    long_risk_multiplier: longRisk,
                    short_risk_multiplier: shortRisk,
                    timestamp: new Date().toISOString()
                };

                debug('TRADER', 'Sending config to Redis:', config);

                // Set config in Redis
                try {
                    const response = await fetch(`${API_BASE}/trading/config`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(config)
                    });

                    if (!response.ok) {
                        throw new Error(`Failed to update config: ${response.status}`);
                    }

                    const result = await response.json();
                    debug('TRADER', 'Config update result:', result);
                    animateElement('trading-control-timestamp');

                } catch (fetchError) {
                    console.error('Error sending config to API:', fetchError);
                    // Fallback - try to set directly in Redis
                    try {
                        await fetch(`${API_BASE}/redis-key?key=trader_config`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ value: config })
                        });
                    } catch (redisError) {
                        console.error('Fallback also failed:', redisError);
                    }
                }

            } catch (error) {
                console.error('Error updating trader config:', error);
            }
        };

        const sendTraderCommand = async (command) => {
            debug('TRADER', `Sending trader command: ${command}`);
            try {
                // Build command object
                const commandData = {
                    command: command,
                    timestamp: new Date().toISOString()
                };

                // Send command to API
                try {
                    const response = await fetch(`${API_BASE}/trading/${command}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`Failed to send command: ${response.status}`);
                    }

                    const result = await response.json();
                    debug('TRADER', `Command ${command} result:`, result);

                    // Update status immediately
                    await updateTraderStatus();

                } catch (fetchError) {
                    console.error(`Error sending ${command} command to API:`, fetchError);
                    // Fallback - try to set directly in Redis
                    try {
                        await fetch(`${API_BASE}/redis-key?key=trader_commands`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ value: commandData })
                        });
                        await updateTraderStatus();
                    } catch (redisError) {
                        console.error('Fallback also failed:', redisError);
                    }
                }

            } catch (error) {
                console.error(`Error in sendTraderCommand(${command}):`, error);
            }
        };

        // Set up UI event handlers
        document.addEventListener('DOMContentLoaded', function () {
            // Hook up control buttons
            const startTradingBtn = document.getElementById('start-trading-btn');
            const stopTradingBtn = document.getElementById('stop-trading-btn');

            if (startTradingBtn) {
                startTradingBtn.addEventListener('click', () => {
                    debug('TRADER', 'Start trading button clicked');
                    sendTraderCommand('start');
                });
            }

            if (stopTradingBtn) {
                stopTradingBtn.addEventListener('click', () => {
                    debug('TRADER', 'Stop trading button clicked');
                    sendTraderCommand('stop');
                });
            }

            // Hook up range sliders
            const trapThresholdSlider = document.getElementById('trap-threshold');
            const trapThresholdValue = document.getElementById('trap-threshold-value');
            const longRiskSlider = document.getElementById('long-risk');
            const longRiskValue = document.getElementById('long-risk-value');
            const shortRiskSlider = document.getElementById('short-risk');
            const shortRiskValue = document.getElementById('short-risk-value');

            if (trapThresholdSlider && trapThresholdValue) {
                trapThresholdSlider.addEventListener('input', () => {
                    trapThresholdValue.textContent = trapThresholdSlider.value;
                });

                trapThresholdSlider.addEventListener('change', () => {
                    updateTraderConfig();
                });
            }

            if (longRiskSlider && longRiskValue) {
                longRiskSlider.addEventListener('input', () => {
                    longRiskValue.textContent = longRiskSlider.value;
                });

                longRiskSlider.addEventListener('change', () => {
                    updateTraderConfig();
                });
            }

            if (shortRiskSlider && shortRiskValue) {
                shortRiskSlider.addEventListener('input', () => {
                    shortRiskValue.textContent = shortRiskSlider.value;
                });

                shortRiskSlider.addEventListener('change', () => {
                    updateTraderConfig();
                });
            }

            // Hook up toggle
            const trapProtectionToggle = document.getElementById('trap-protection-toggle');
            if (trapProtectionToggle) {
                trapProtectionToggle.addEventListener('change', () => {
                    updateTraderConfig();
                });
            }

            // Initial load of trader config
            const loadTraderConfig = async () => {
                try {
                    const config = await fetchRedisKey('trader_config');
                    if (config) {
                        debug('TRADER', 'Loaded trader config from Redis:', config);

                        // Update UI with config values
                        if (trapProtectionToggle && config.trap_protection !== undefined) {
                            trapProtectionToggle.checked = config.trap_protection;
                        }

                        if (trapThresholdSlider && trapThresholdValue && config.trap_threshold !== undefined) {
                            trapThresholdSlider.value = config.trap_threshold;
                            trapThresholdValue.textContent = config.trap_threshold;
                        }

                        if (longRiskSlider && longRiskValue && config.long_risk_multiplier !== undefined) {
                            longRiskSlider.value = config.long_risk_multiplier;
                            longRiskValue.textContent = config.long_risk_multiplier;
                        }

                        if (shortRiskSlider && shortRiskValue && config.short_risk_multiplier !== undefined) {
                            shortRiskSlider.value = config.short_risk_multiplier;
                            shortRiskValue.textContent = config.short_risk_multiplier;
                        }
                    }
                } catch (error) {
                    console.error('Error loading trader config:', error);
                }
            };

            loadTraderConfig();
            updateTraderStatus();

            // Add trader status to auto-refresh
            setInterval(() => {
                updateTraderStatus();
            }, 5000); // Every 5 seconds
        });

        // Function to update the BitGet trader UI card
        const updateBitGetTraderUI = async (positionData) => {
            debug('BITGET', 'Updating BitGet Trader UI');

            try {
                // Exit if no position data
                if (!positionData) {
                    // Hide elements or show no position state
                    document.getElementById('bg-position-badge').textContent = 'NO POSITION';
                    document.getElementById('bg-position-badge').className = 'position-badge neutral';

                    // Reset all values to defaults or empty
                    document.getElementById('bg-pnl-percent').textContent = '0.00%';
                    document.getElementById('bg-pnl-usd').textContent = '$0.00';
                    document.getElementById('bg-position-size').textContent = '0.00 BTC';
                    document.getElementById('bg-leverage').textContent = '0x';
                    document.getElementById('bg-margin').textContent = '$0.00';
                    document.getElementById('bg-entry-price').textContent = '-';
                    document.getElementById('bg-current-price').textContent = '-';
                    document.getElementById('bg-breakeven').textContent = '-';
                    document.getElementById('bg-liquidation').textContent = '-';
                    document.getElementById('bg-margin-mode').textContent = '-';
                    document.getElementById('bg-position-mode').textContent = '-';
                    document.getElementById('bg-take-profit').textContent = 'NOT SET';
                    document.getElementById('bg-stop-loss').textContent = 'NOT SET';
                    document.getElementById('bg-margin-ratio').textContent = '0.00%';
                    document.getElementById('bg-total-fee').textContent = '$0.00';
                    document.getElementById('bg-realized-pnl').textContent = '$0.00';

                    // Hide TP/SL containers
                    document.getElementById('bg-tp-container').style.display = 'none';
                    document.getElementById('bg-sl-container').style.display = 'none';

                    // Hide liquidation progress
                    document.getElementById('bg-liquidation-progress').style.width = '0%';
                    document.getElementById('bg-entry-marker').style.display = 'none';
                    document.getElementById('bg-current-marker').style.display = 'none';

                    // Update timestamp
                    document.getElementById('bg-position-timestamp').textContent =
                        `Updated: ${new Date().toLocaleString()}`;

                    // Disable buttons
                    document.getElementById('bg-close-position').style.opacity = '0.5';
                    document.getElementById('bg-edit-position').style.opacity = '0.5';

                    return;
                }

                // Position is active - update all fields
                // First check if it's a BitGet response format
                const isBitGetFormat = positionData.symbol === 'BTC/USDT:USDT' ||
                    (positionData.info && positionData.info.symbol === 'BTCUSDT');

                let symbol, side, entryPrice, currentPrice, posSize, leverage, marginMode,
                    posMode, takeProfit, stopLoss, liquidationPrice, marginRatio, totalFee,
                    unrealizedPL, marginSize, breakEvenPrice, timestamp;

                if (isBitGetFormat) {
                    // Extract data from BitGet format
                    symbol = positionData.symbol || 'BTC/USDT:USDT';
                    side = positionData.side || '';
                    entryPrice = parseFloat(positionData.entryPrice || 0);
                    currentPrice = parseFloat(positionData.markPrice || 0);
                    posSize = parseFloat(positionData.contracts || 0);
                    leverage = parseFloat(positionData.leverage || 0);
                    marginMode = (positionData.marginMode || '').toLowerCase();
                    posMode = positionData.info?.posMode || 'one_way_mode';
                    takeProfit = positionData.info?.takeProfit || null;
                    stopLoss = positionData.info?.stopLoss || null;
                    liquidationPrice = parseFloat(positionData.liquidationPrice || 0);
                    marginRatio = parseFloat(positionData.marginRatio || 0) * 100;
                    totalFee = parseFloat(positionData.info?.totalFee || 0);
                    unrealizedPL = parseFloat(positionData.unrealizedPnl || 0);
                    marginSize = parseFloat(positionData.info?.marginSize || 0);
                    breakEvenPrice = parseFloat(positionData.info?.breakEvenPrice || 0);
                    timestamp = positionData.timestamp || Date.now();
                } else {
                    // Extract from standard format or calculate values
                    symbol = 'BTC/USDT';
                    side = positionData.position_side || '';
                    entryPrice = parseFloat(positionData.entry_price || 0);
                    currentPrice = parseFloat(positionData.current_price || 0);
                    posSize = parseFloat(positionData.position_size || 0);
                    leverage = parseFloat(positionData.leverage || 0);
                    marginMode = 'crossed';
                    posMode = 'one_way_mode';
                    takeProfit = positionData.take_profit || null;
                    stopLoss = positionData.stop_loss || null;
                    liquidationPrice = 0; // Will be estimated
                    marginRatio = 0;
                    totalFee = 0;
                    unrealizedPL = parseFloat(positionData.pnl_usd || 0);
                    marginSize = entryPrice * posSize / leverage;
                    breakEvenPrice = 0; // Will be calculated
                    timestamp = positionData.timestamp || Date.now();

                    // Calculate liquidation price (very rough estimate)
                    if (side.toLowerCase() === 'long') {
                        liquidationPrice = entryPrice * (1 - (0.9 / leverage));
                    } else {
                        liquidationPrice = entryPrice * (1 + (0.9 / leverage));
                    }

                    // Calculate break-even price
                    breakEvenPrice = entryPrice;
                }

                // Calculate percent PnL
                let pnlPercent = 0;
                if (positionData.percentage) {
                    pnlPercent = positionData.percentage;
                } else if (positionData.pnl_percent) {
                    pnlPercent = positionData.pnl_percent;
                } else if (entryPrice && currentPrice) {
                    if (side.toLowerCase() === 'long') {
                        pnlPercent = ((currentPrice - entryPrice) / entryPrice) * 100;
                    } else if (side.toLowerCase() === 'short') {
                        pnlPercent = ((entryPrice - currentPrice) / entryPrice) * 100;
                    }
                }

                // Format badge
                const badgeEl = document.getElementById('bg-position-badge');
                if (side.toLowerCase() === 'long') {
                    badgeEl.innerHTML = '<i class="fas fa-arrow-up"></i> LONG';
                    badgeEl.className = 'position-badge long';
                } else if (side.toLowerCase() === 'short') {
                    badgeEl.innerHTML = '<i class="fas fa-arrow-down"></i> SHORT';
                    badgeEl.className = 'position-badge short';
                } else {
                    badgeEl.textContent = 'UNKNOWN';
                    badgeEl.className = 'position-badge neutral';
                }

                // Update PnL
                const pnlPercentEl = document.getElementById('bg-pnl-percent');
                pnlPercentEl.textContent = `${pnlPercent > 0 ? '+' : ''}${pnlPercent.toFixed(2)}%`;
                pnlPercentEl.className = `bitget-pnl-value ${pnlPercent > 0 ? 'positive' : pnlPercent < 0 ? 'negative' : 'neutral'}`;

                const pnlUsdEl = document.getElementById('bg-pnl-usd');
                pnlUsdEl.textContent = `${unrealizedPL > 0 ? '+' : ''}$${Math.abs(unrealizedPL).toFixed(2)}`;
                pnlUsdEl.className = `bitget-pnl-value ${unrealizedPL > 0 ? 'positive' : unrealizedPL < 0 ? 'negative' : 'neutral'}`;

                // Update position stats
                document.getElementById('bg-position-size').textContent = `${posSize.toFixed(4)} BTC`;
                document.getElementById('bg-leverage').textContent = `${leverage}x`;
                document.getElementById('bg-margin').textContent = `$${marginSize.toFixed(2)}`;

                // Update position details
                document.getElementById('bg-entry-price').textContent = `$${entryPrice.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
                document.getElementById('bg-current-price').textContent = `$${currentPrice.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
                document.getElementById('bg-breakeven').textContent = `$${breakEvenPrice.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
                document.getElementById('bg-liquidation').textContent = `$${liquidationPrice.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
                document.getElementById('bg-margin-mode').textContent = marginMode.toUpperCase();
                document.getElementById('bg-position-mode').textContent = posMode.replace(/_/g, '-').toUpperCase();

                // Update TP/SL
                if (takeProfit) {
                    document.getElementById('bg-tp-container').style.display = 'flex';
                    document.getElementById('bg-take-profit').textContent = `$${parseFloat(takeProfit).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
                } else {
                    document.getElementById('bg-tp-container').style.display = 'none';
                }

                if (stopLoss) {
                    document.getElementById('bg-sl-container').style.display = 'flex';
                    document.getElementById('bg-stop-loss').textContent = `$${parseFloat(stopLoss).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
                } else {
                    document.getElementById('bg-sl-container').style.display = 'none';
                }

                // Update additional stats
                document.getElementById('bg-margin-ratio').textContent = `${marginRatio.toFixed(2)}%`;
                document.getElementById('bg-total-fee').textContent = `$${totalFee.toFixed(2)}`;

                // Calculate realized PNL (if available from BitGet data)
                let realizedPnl = parseFloat(positionData.info?.achievedProfits || 0);
                const realizedPnlEl = document.getElementById('bg-realized-pnl');
                realizedPnlEl.textContent = `${realizedPnl > 0 ? '+' : ''}$${realizedPnl.toFixed(2)}`;
                realizedPnlEl.className = `bitget-stat-value ${realizedPnl > 0 ? 'positive' : realizedPnl < 0 ? 'negative' : 'neutral'}`;

                // Update liquidation meter
                // Calculate the percentage of price movement from entry to liquidation
                let liquidationDistance = 0;
                if (side.toLowerCase() === 'long') {
                    liquidationDistance = ((entryPrice - liquidationPrice) / entryPrice) * 100;
                } else {
                    liquidationDistance = ((liquidationPrice - entryPrice) / entryPrice) * 100;
                }

                // Calculate how far we've moved towards liquidation (as percentage of the total distance)
                let currentProgress = 0;
                if (side.toLowerCase() === 'long') {
                    currentProgress = Math.max(0, ((entryPrice - currentPrice) / (entryPrice - liquidationPrice)) * 100);
                } else {
                    currentProgress = Math.max(0, ((currentPrice - entryPrice) / (liquidationPrice - entryPrice)) * 100);
                }

                // Cap at 100%
                currentProgress = Math.min(100, currentProgress);

                // Update progress bar
                document.getElementById('bg-liquidation-progress').style.width = `${currentProgress}%`;

                // Update price markers
                document.getElementById('bg-entry-marker').style.display = 'block';
                document.getElementById('bg-entry-marker').style.left = '0%';
                document.getElementById('bg-entry-marker').querySelector('.price-marker-label').textContent =
                    `$${Math.round(entryPrice).toLocaleString()}`;

                document.getElementById('bg-current-marker').style.display = 'block';
                // Position the current marker between entry and liquidation based on price
                let currentMarkerPos = 0;
                if (side.toLowerCase() === 'long') {
                    // For long positions, liquidation is below entry
                    currentMarkerPos = Math.max(0, ((entryPrice - currentPrice) / (entryPrice - liquidationPrice)) * 100);
                } else {
                    // For short positions, liquidation is above entry
                    currentMarkerPos = Math.max(0, ((currentPrice - entryPrice) / (liquidationPrice - entryPrice)) * 100);
                }
                // Cap at 100%
                currentMarkerPos = Math.min(100, currentMarkerPos);

                document.getElementById('bg-current-marker').style.left = `${currentMarkerPos}%`;
                document.getElementById('bg-current-marker').querySelector('.price-marker-label').textContent =
                    `$${Math.round(currentPrice).toLocaleString()}`;

                // Update timestamp
                let formattedTime;
                if (typeof timestamp === 'number') {
                    formattedTime = new Date(timestamp).toLocaleString();
                } else if (typeof timestamp === 'string') {
                    formattedTime = new Date(timestamp).toLocaleString();
                } else {
                    formattedTime = new Date().toLocaleString();
                }
                document.getElementById('bg-position-timestamp').textContent = `Updated: ${formattedTime}`;

                // Enable buttons
                document.getElementById('bg-close-position').style.opacity = '1';
                document.getElementById('bg-edit-position').style.opacity = '1';

            } catch (error) {
                console.error('Error updating BitGet trader UI:', error);
                document.getElementById('bg-position-timestamp').textContent =
                    `Error: ${new Date().toLocaleString()}`;
            }
        };

        // Function to set up dashboard refresh timer
        const setupRefreshTimer = () => {
            // Refresh trap probability data initially and every 15 seconds
            updateTrapProbability();
            setInterval(updateTrapProbability, 15000);

            // Refresh position data initially and every 5 seconds
            updatePositionInfo();
            setInterval(updatePositionInfo, 5000);

            // Refresh position targets initially and every 10 seconds
            updatePositionTargets();
            setInterval(updatePositionTargets, 10000);

            // Refresh market trends data initially and every 30 seconds
            updateMarketTrends();
            setInterval(updateMarketTrends, 30000);

            // Refresh other panels...
            updateBTCPriceDisplay();
            fetchRedisData();

            setInterval(updateBTCPriceDisplay, 10000);
            setInterval(fetchRedisData, 20000);
        };

        // Function to update Market Trends Analysis panel
        const updateMarketTrends = async () => {
            debug('TRENDS', 'Updating market trends analysis panel');

            const timestampElement = document.getElementById('trends-timestamp');

            try {
                // Show updating indicator
                if (timestampElement) {
                    timestampElement.textContent = 'Updating...';
                }

                // Fetch timeframe trends
                await updateTimeframeTrends();

                // Fetch Fibonacci levels
                await updateFibonacciLevels();

                // Fetch Market Maker traps
                await updateMarketMakerTraps();

                // Fetch Market Conditions
                await updateMarketConditions();

                // Update timestamp
                if (timestampElement) {
                    const timestamp = new Date().toLocaleTimeString();
                    timestampElement.textContent = timestamp;
                }

            } catch (error) {
                console.error('Error updating market trends:', error);

                if (timestampElement) {
                    timestampElement.textContent = `Error: ${new Date().toLocaleTimeString()}`;
                }
            }
        };

        // Function to update timeframe trends
        const updateTimeframeTrends = async () => {
            debug('TRENDS', 'Updating timeframe trends');

            try {
                // Get container elements
                const trendsContainer = document.getElementById('timeframe-trends');
                const barsContainer = document.getElementById('timeframe-bars');
                const labelsContainer = document.getElementById('timeframe-labels');

                // Clear existing content
                trendsContainer.innerHTML = '';
                barsContainer.innerHTML = '';
                labelsContainer.innerHTML = '';

                // Define timeframes to display prominently in cards
                const displayTimeframes = ['1min', '5min', '15min', '60min'];

                // Define all timeframes for bar chart
                const allTimeframes = ['1min', '5min', '15min', '30min', '60min', '240min', '720min', '1444min'];

                // Track the trend data for all timeframes for the bar chart
                const allTrendData = [];

                // Fetch trend data for each timeframe
                for (const timeframe of allTimeframes) {
                    try {
                        const data = await fetchRedisKey(`btc_trend_${timeframe}`);

                        if (data) {
                            // Add to all trend data array
                            allTrendData.push({
                                timeframe: timeframe,
                                trend: data.trend,
                                change: data.change
                            });

                            // Create trend card for display timeframes
                            if (displayTimeframes.includes(timeframe)) {
                                const cardHTML = createTrendCard(timeframe, data.trend, data.change);
                                trendsContainer.innerHTML += cardHTML;
                            }
                        }
                    } catch (error) {
                        console.error(`Error fetching trend data for ${timeframe}:`, error);
                    }
                }

                // Create bar chart
                if (allTrendData.length > 0) {
                    // Create bars
                    for (const data of allTrendData) {
                        const barHTML = createTimeframeBar(data.timeframe, data.change);
                        barsContainer.innerHTML += barHTML;

                        // Create label
                        const labelHTML = `<div class="timeframe-label">${data.timeframe.replace('min', '')}</div>`;
                        labelsContainer.innerHTML += labelHTML;
                    }
                }

            } catch (error) {
                console.error('Error updating timeframe trends:', error);
                throw error;
            }
        };

        // Helper function to create a trend card
        const createTrendCard = (timeframe, trend, change) => {
            // Determine trend class
            let trendClass = 'neutral';
            if (trend.includes('Bullish')) {
                trendClass = 'bullish';
            } else if (trend.includes('Bearish')) {
                trendClass = 'bearish';
            }

            // Format change with sign
            const changeSign = change > 0 ? '+' : '';

            // Generate description based on trend and change
            let description = '';
            if (Math.abs(change) > 2) {
                description = 'Strong price movement';
            } else if (Math.abs(change) > 1) {
                description = 'Moderate price action';
            } else if (Math.abs(change) > 0.5) {
                description = 'Mild price fluctuation';
            } else {
                description = 'Sideways movement';
            }

            return `
                <div class="trend-card">
                    <div class="trend-timeframe">${timeframe}</div>
                    <div class="trend-value ${trendClass}">${trend} <span class="trend-pct">${changeSign}${change.toFixed(2)}%</span></div>
                    <div class="trend-description">${description}</div>
                </div>
            `;
        };

        // Helper function to create a timeframe bar
        const createTimeframeBar = (timeframe, change) => {
            // Determine bar class and height
            const barClass = change >= 0 ? 'positive' : 'negative';
            const heightPct = Math.min(Math.abs(change) * 10, 100); // 10% change = 100% height

            return `
                <div class="timeframe-bar">
                    <div class="timeframe-bar-fill ${barClass}" style="height: ${heightPct}%;"></div>
                </div>
            `;
        };

        // Function to update Fibonacci levels
        const updateFibonacciLevels = async () => {
            debug('TRENDS', 'Updating Fibonacci levels');

            try {
                // Get container element
                const fibContainer = document.getElementById('fibonacci-levels');

                // Clear existing content
                fibContainer.innerHTML = '';

                // Fetch Fibonacci levels
                const fibLevels = await fetchRedisKey('fibonacci:current_levels');
                if (!fibLevels) {
                    fibContainer.innerHTML = '<p class="trend-description">No Fibonacci data available.</p>';
                    return;
                }

                // Get current price
                const currentPrice = parseFloat(await fetchRedisKey('last_btc_price') || 0);
                if (currentPrice === 0) {
                    fibContainer.innerHTML = '<p class="trend-description">Cannot determine current price.</p>';
                    return;
                }

                // Find closest Fibonacci level
                let closestLevel = null;
                let minDistance = Number.MAX_VALUE;

                // Sort levels and create HTML
                for (const [level, price] of Object.entries(fibLevels).sort((a, b) => parseFloat(a[1]) - parseFloat(b[1]))) {
                    const distance = Math.abs(currentPrice - price);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestLevel = level;
                    }

                    const isActive = closestLevel === level;
                    const distancePct = ((price - currentPrice) / currentPrice * 100).toFixed(2);
                    const directionIcon = price > currentPrice ? '↑' : '↓';

                    fibContainer.innerHTML += `
                        <div class="fib-level ${isActive ? 'active' : ''}">
                            <div class="fib-level-name">${level}</div>
                            <div class="fib-level-price">$${parseFloat(price).toLocaleString()} <span style="opacity: 0.7; font-size: 0.75rem;">${directionIcon} ${Math.abs(distancePct)}%</span></div>
                        </div>
                    `;
                }

            } catch (error) {
                console.error('Error updating Fibonacci levels:', error);
                throw error;
            }
        };

        // Function to update Market Maker traps
        const updateMarketMakerTraps = async () => {
            debug('TRENDS', 'Updating Market Maker traps');

            try {
                // Get container elements
                const trapsContainer = document.getElementById('mm-traps');
                const noTrapsMessage = document.getElementById('no-traps-message');

                // Clear existing content
                trapsContainer.innerHTML = '';

                // Fetch trap data
                let trapData = await fetchRedisKey('mm_traps:current_traps');
                if (!trapData) {
                    // Try alternative key
                    trapData = await fetchRedisKey('mm_trap_detection');
                }

                if (!trapData || trapData.length === 0) {
                    // No traps detected
                    trapsContainer.innerHTML = '';
                    noTrapsMessage.style.display = 'block';
                    return;
                }

                // Display traps
                noTrapsMessage.style.display = 'none';

                // Either trapData is an array or a single object
                const traps = Array.isArray(trapData) ? trapData : [trapData];

                for (const trap of traps) {
                    const trapType = trap.type || trap.trap_type;
                    const confidence = trap.confidence || 0.5;
                    const timeframe = trap.timeframe || 'recent';

                    // Create trap indicator
                    trapsContainer.innerHTML += `
                        <div class="trap-indicator">
                            <div class="trap-dot ${trapType.toLowerCase().includes('bull') ? 'bull' : 'bear'}"></div>
                            <div class="trap-info">
                                <span class="trap-type">${trapType}</span>
                                <span class="trap-confidence">${Math.round(confidence * 100)}%</span>
                                <div class="trap-timeframe">${timeframe} timeframe</div>
                            </div>
                        </div>
                    `;
                }

            } catch (error) {
                console.error('Error updating Market Maker traps:', error);
                throw error;
            }
        };

        // Function to update Market Conditions
        const updateMarketConditions = async () => {
            debug('TRENDS', 'Updating Market Conditions');

            try {
                // Fetch market regime
                const marketRegime = await fetchRedisKey('market_regime');
                if (marketRegime) {
                    const regimeElement = document.getElementById('market-regime');
                    regimeElement.textContent = marketRegime;

                    // Set appropriate class
                    regimeElement.className = 'regime-value';
                    if (marketRegime.includes('High Volatility')) {
                        regimeElement.classList.add('high-volatility');
                    } else if (marketRegime.includes('Moderate Volatility')) {
                        regimeElement.classList.add('moderate-volatility');
                    } else {
                        regimeElement.classList.add('low-volatility');
                    }
                }

                // Fetch volatility
                const volatility = await fetchRedisKey('market_volatility');
                if (volatility) {
                    document.getElementById('market-volatility').textContent = `${parseFloat(volatility).toFixed(2)}%`;
                }

                // Update Schumann resonance (this is more for fun/theme - could be dynamic but static is fine)
                const schumannValue = document.getElementById('schumann-value');
                const schumannDesc = document.getElementById('schumann-desc');

                // Randomly vary the value slightly for visual effect
                const baseValue = 7.83;
                const variation = (Math.random() * 0.2) - 0.1; // +/- 0.1
                schumannValue.textContent = `${(baseValue + variation).toFixed(2)} Hz`;

                // Update description based on market trend
                const overallTrend = await fetchRedisKey('btc_trend_15min');
                if (overallTrend && overallTrend.trend) {
                    if (overallTrend.trend.includes('Bullish')) {
                        schumannDesc.textContent = 'Harmonizing with cosmic bullish energy';
                    } else if (overallTrend.trend.includes('Bearish')) {
                        schumannDesc.textContent = 'Aligning with planetary correction waves';
                    } else {
                        schumannDesc.textContent = 'Balanced harmonic equilibrium state';
                    }
                }

            } catch (error) {
                console.error('Error updating Market Conditions:', error);
                throw error;
            }
        };

        // Load all dashboard modules on page load
        document.addEventListener('DOMContentLoaded', function () {
            debug('INIT', 'DOM content loaded, initializing dashboard...');

            // Get session token if one exists
            setupAuthListeners();
            checkSession();

            // Start updates
            setupRefreshTimer();

            // Set up module-specific refresh buttons
            setupRefreshButtons();

            // Set up BitGet trader action buttons
            setupBitGetTraderUI();
        });

        // Helper function to show toast notifications
        const showToast = (message, type = 'info') => {
            // Create toast container if it doesn't exist
            let toastContainer = document.getElementById('toast-container');
            if (!toastContainer) {
                toastContainer = document.createElement('div');
                toastContainer.id = 'toast-container';
                toastContainer.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    z-index: 9999;
                `;
                document.body.appendChild(toastContainer);
            }

            // Create toast element
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.style.cssText = `
                padding: 12px 20px;
                margin-bottom: 10px;
                border-radius: 8px;
                color: white;
                font-weight: bold;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                display: flex;
                align-items: center;
                min-width: 200px;
                max-width: 400px;
                animation: fadeIn 0.3s ease, fadeOut 0.5s ease 2.5s forwards;
                cursor: pointer;
            `;

            // Set background color based on type
            switch (type) {
                case 'success':
                    toast.style.background = 'linear-gradient(135deg, #76b852, #4CAF50)';
                    break;
                case 'error':
                    toast.style.background = 'linear-gradient(135deg, #ff6d00, #F44336)';
                    break;
                case 'warning':
                    toast.style.background = 'linear-gradient(135deg, #ffeb3b, #FFC107)';
                    toast.style.color = '#333';
                    break;
                default:
                    toast.style.background = 'linear-gradient(135deg, #29B6F6, #2196F3)';
                    break;
            }

            // Icon based on type
            let icon = '';
            switch (type) {
                case 'success':
                    icon = '<i class="fas fa-check-circle" style="margin-right: 10px;"></i>';
                    break;
                case 'error':
                    icon = '<i class="fas fa-times-circle" style="margin-right: 10px;"></i>';
                    break;
                case 'warning':
                    icon = '<i class="fas fa-exclamation-triangle" style="margin-right: 10px;"></i>';
                    break;
                default:
                    icon = '<i class="fas fa-info-circle" style="margin-right: 10px;"></i>';
                    break;
            }

            // Set content
            toast.innerHTML = `${icon}${message}`;

            // Add keyframes for animations if not already added
            if (!document.getElementById('toast-keyframes')) {
                const style = document.createElement('style');
                style.id = 'toast-keyframes';
                style.innerHTML = `
                    @keyframes fadeIn {
                        from { opacity: 0; transform: translateY(-20px); }
                        to { opacity: 1; transform: translateY(0); }
                    }
                    @keyframes fadeOut {
                        from { opacity: 1; transform: translateY(0); }
                        to { opacity: 0; transform: translateY(-20px); }
                    }
                `;
                document.head.appendChild(style);
            }

            // Click to dismiss
            toast.addEventListener('click', () => {
                toast.style.animation = 'fadeOut 0.3s ease forwards';
                setTimeout(() => {
                    toast.remove();
                }, 300);
            });

            // Append toast to container
            toastContainer.appendChild(toast);

            // Auto remove after 3 seconds
            setTimeout(() => {
                toast.remove();
            }, 3000);
        };

        // Trap Analysis Dashboard Integration
        document.addEventListener('DOMContentLoaded', function () {
            setupTrapAnalysisDashboard();
        });

        function setupTrapAnalysisDashboard() {
            const expandBtn = document.getElementById('expand-trap-btn');
            const fullscreenBtn = document.getElementById('fullscreen-trap-btn');
            const minimizeBtn = document.getElementById('minimize-trap-btn');
            const closeBtn = document.getElementById('close-trap-btn');
            const trapPanel = document.getElementById('trap-analysis-panel');
            const trapModal = document.getElementById('trap-analysis-modal');
            const trapContainer = document.getElementById('trap-analysis-container');
            const trapModalContent = document.getElementById('trap-analysis-modal-content');
            const refreshBtn = document.getElementById('refresh-trap-analysis');

            // Load trap analysis content
            loadTrapAnalysisDashboard();

            // Expand button - make panel larger
            if (expandBtn) {
                expandBtn.addEventListener('click', function () {
                    trapPanel.classList.toggle('expanded');
                    if (trapPanel.classList.contains('expanded')) {
                        trapPanel.style.gridColumn = 'span 2';
                        trapPanel.style.height = '700px';
                        expandBtn.innerHTML = '<i class="fas fa-compress-alt"></i>';
                        expandBtn.title = 'Collapse Panel';
                    } else {
                        trapPanel.style.gridColumn = '';
                        trapPanel.style.height = '';
                        expandBtn.innerHTML = '<i class="fas fa-expand-alt"></i>';
                        expandBtn.title = 'Expand Panel';
                    }
                });
            }

            // Fullscreen button - open modal
            if (fullscreenBtn) {
                fullscreenBtn.addEventListener('click', function () {
                    trapModal.classList.add('show');
                    const content = trapContainer.innerHTML;
                    trapModalContent.innerHTML = content;
                    // Refresh data in fullscreen view
                    loadTrapAnalysisDashboard(true);
                });
            }

            // Minimize button - collapse modal
            if (minimizeBtn) {
                minimizeBtn.addEventListener('click', function () {
                    trapModal.classList.remove('show');
                });
            }

            // Close button - close modal
            if (closeBtn) {
                closeBtn.addEventListener('click', function () {
                    trapModal.classList.remove('show');
                });
            }

            // Refresh button - reload trap analysis data
            if (refreshBtn) {
                refreshBtn.addEventListener('click', function () {
                    loadTrapAnalysisDashboard();
                    refreshBtn.disabled = true;
                    setTimeout(() => {
                        refreshBtn.disabled = false;
                    }, 3000);
                });
            }
        }

        function loadTrapAnalysisDashboard(isFullscreen = false) {
            debug('TRAP_DASHBOARD', 'Loading trap analysis dashboard');

            const containerElement = isFullscreen ?
                document.getElementById('trap-analysis-modal-content') :
                document.getElementById('trap-analysis-container');

            if (!containerElement) {
                console.error('Container element not found');
                return;
            }

            // Show loading indicator
            containerElement.innerHTML = `
                <div class="loading-container">
                    <div class="loading-spinner"></div>
                    <div class="loading-text">Loading Trap Analysis Dashboard...</div>
                </div>
            `;

            // Try to fetch the trap analysis panel HTML
            fetch('/api/trap-analysis-panel')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Failed to load trap analysis panel: ${response.status}`);
                    }
                    return response.text();
                })
                .then(html => {
                    // Successfully loaded trap panel content
                    containerElement.innerHTML = html;

                    // Initialize any scripts from the loaded content
                    initializeTrapAnalysisScripts(containerElement);

                    debug('TRAP_DASHBOARD', 'Trap analysis dashboard loaded successfully');
                })
                .catch(error => {
                    console.error('Error loading trap analysis dashboard:', error);

                    // Show error message
                    containerElement.innerHTML = `
                        <div class="trap-error-container" style="text-align: center; padding: 20px;">
                            <div style="font-size: 3rem; color: var(--red-color); margin-bottom: 15px;">
                                <i class="fas fa-exclamation-triangle"></i>
                            </div>
                            <h3 style="color: var(--red-color); margin-bottom: 10px;">Failed to Load Trap Analysis</h3>
                            <p style="color: var(--muted-color); margin-bottom: 15px;">
                                ${error.message}
                            </p>
                            <div>
                                <button class="refresh-button" onclick="loadTrapAnalysisDashboard(${isFullscreen})">
                                    <i class="fas fa-sync-alt"></i> Try Again
                                </button>
                            </div>
                        </div>
                    `;
                });
        }

        function initializeTrapAnalysisScripts(containerElement) {
            // Find any script tags in the loaded content and execute them
            const scripts = containerElement.querySelectorAll('script');

            scripts.forEach(script => {
                // Create a new script element
                const newScript = document.createElement('script');

                // Copy all attributes from original script
                Array.from(script.attributes).forEach(attr => {
                    newScript.setAttribute(attr.name, attr.value);
                });

                // Set the script content
                newScript.textContent = script.textContent;

                // Replace the original script with new one to force execution
                script.parentNode.replaceChild(newScript, script);
            });
        }
    </script>
</body>

</html>