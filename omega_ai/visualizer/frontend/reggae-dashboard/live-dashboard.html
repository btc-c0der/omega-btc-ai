<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OMEGA BTC AI - Live Reggae Dashboard</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --green-color: #00B52D;
            --yellow-color: #FFD700;
            --red-color: #FF3D00;
            --bg-color: #121212;
            --card-bg: #1E1E1E;
            --text-color: #E0E0E0;
            --muted-color: #AAAAAA;
            --border-color: rgba(255, 215, 0, 0.2);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Courier New', monospace;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            line-height: 1.6;
            background-image:
                radial-gradient(circle at 10% 20%, rgba(0, 181, 45, 0.05) 0%, transparent 20%),
                radial-gradient(circle at 90% 30%, rgba(255, 215, 0, 0.05) 0%, transparent 20%),
                radial-gradient(circle at 50% 70%, rgba(255, 61, 0, 0.05) 0%, transparent 20%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background-color: var(--card-bg);
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }

        .header h1 {
            color: var(--yellow-color);
            margin: 0;
            font-size: 1.8rem;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header h1 i {
            font-size: 1.6rem;
        }

        .price-ticker {
            display: flex;
            align-items: center;
            background: rgba(255, 215, 0, 0.1);
            padding: 5px 15px;
            border-radius: 20px;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
        }

        .btc-price {
            font-weight: bold;
            color: var(--yellow-color);
            margin-right: 10px;
            font-size: 1.3rem;
        }

        .price-change {
            border-radius: 4px;
            padding: 2px 8px;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .price-change.positive {
            background-color: rgba(0, 181, 45, 0.2);
            color: var(--green-color);
        }

        .price-change.negative {
            background-color: rgba(255, 61, 0, 0.2);
            color: var(--red-color);
        }

        .price-change.neutral {
            background-color: rgba(255, 255, 255, 0.2);
            color: var(--yellow-color);
        }

        .status-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: var(--card-bg);
            padding: 10px 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .status-indicator {
            display: flex;
            align-items: center;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .status-dot.connected {
            background-color: var(--green-color);
            box-shadow: 0 0 10px var(--green-color);
            animation: pulse 2s infinite;
        }

        .status-dot.disconnected {
            background-color: var(--red-color);
            box-shadow: 0 0 10px var(--red-color);
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(0, 181, 45, 0.4);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(0, 181, 45, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(0, 181, 45, 0);
            }
        }

        .data-source {
            background-color: rgba(255, 215, 0, 0.2);
            padding: 5px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            color: var(--yellow-color);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }

        @media (min-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr 1fr;
            }
        }

        .card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .card h2 {
            color: var(--yellow-color);
            margin-top: 0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            font-size: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .card h2 i {
            font-size: 1.2rem;
            margin-right: 8px;
        }

        .card h2 .refresh-time {
            font-size: 0.8rem;
            color: var(--muted-color);
            font-weight: normal;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            border-bottom: 1px dotted rgba(255, 255, 255, 0.1);
            padding-bottom: 8px;
        }

        .label {
            color: var(--muted-color);
        }

        .value {
            font-weight: bold;
        }

        .value.positive {
            color: var(--green-color);
        }

        .value.negative {
            color: var(--red-color);
        }

        .value.neutral {
            color: var(--yellow-color);
        }

        .progress-bar {
            width: 100%;
            background-color: rgba(255, 255, 255, 0.1);
            height: 20px;
            border-radius: 10px;
            margin: 15px 0;
            overflow: hidden;
            position: relative;
        }

        .progress-bar-inner {
            height: 100%;
            border-radius: 10px;
            transition: width 1s ease, background-color 1s ease;
            background-image: linear-gradient(to right, var(--green-color), var(--yellow-color), var(--red-color));
            background-size: 200% 100%;
            animation: gradient-shift 3s ease infinite;
        }

        @keyframes gradient-shift {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        .jah-message {
            background: linear-gradient(to right, rgba(0, 181, 45, 0.2), rgba(255, 221, 0, 0.2), rgba(255, 61, 0, 0.2));
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            color: var(--yellow-color);
            margin-top: 20px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
        }

        .jah-message::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg,
                    transparent,
                    rgba(255, 255, 255, 0.1),
                    transparent);
            animation: shine 2s infinite;
        }

        @keyframes shine {
            100% {
                left: 100%;
            }
        }

        .components-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .component-item {
            background-color: rgba(30, 30, 30, 0.5);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid var(--border-color);
        }

        .component-name {
            font-size: 0.9rem;
            color: var(--muted-color);
            margin-bottom: 5px;
        }

        .component-value {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .component-bar {
            flex-grow: 1;
            height: 5px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin: 0 10px;
            overflow: hidden;
        }

        .component-bar-inner {
            height: 100%;
            background-color: var(--yellow-color);
            border-radius: 3px;
            transition: width 0.5s ease;
        }

        .component-number {
            font-weight: bold;
            color: var(--yellow-color);
            font-size: 0.9rem;
        }

        .component-description {
            font-size: 0.8rem;
            color: var(--text-color);
            margin-top: 5px;
            font-style: italic;
        }

        .footer {
            margin-top: 30px;
            text-align: center;
            color: var(--muted-color);
            font-size: 0.9rem;
            padding: 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .footer-icons {
            display: flex;
            gap: 15px;
            margin-top: 5px;
        }

        .footer-icons i {
            color: var(--yellow-color);
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }

        .footer-icons i:hover {
            transform: scale(1.2);
        }

        .refresh-button {
            background-color: #1c384e;
            color: #bcd4e6;
            border: 1px solid #3a546a;
            border-radius: 4px;
            padding: 8px 12px;
            margin-top: 15px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .refresh-button:hover {
            background-color: #2a4e6c;
        }

        .refresh-button:disabled {
            background-color: #1c2832;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .refresh-button i {
            margin-right: 6px;
        }

        .shake {
            animation: shake 0.5s cubic-bezier(.36, .07, .19, .97) both;
        }

        @keyframes shake {

            10%,
            90% {
                transform: translate3d(-1px, 0, 0);
            }

            20%,
            80% {
                transform: translate3d(2px, 0, 0);
            }

            30%,
            50%,
            70% {
                transform: translate3d(-4px, 0, 0);
            }

            40%,
            60% {
                transform: translate3d(4px, 0, 0);
            }
        }

        .btc-logo {
            font-size: 1.5rem;
            margin-right: 8px;
            color: var(--yellow-color);
        }

        /* Add styles for the license disclaimer */
        .license-disclaimer {
            margin-top: 2rem;
            padding: 1rem;
            border-top: 1px solid rgba(255, 215, 0, 0.1);
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
        }

        .license-disclaimer p {
            margin: 0.5rem 0;
        }

        .license-disclaimer a {
            color: rgba(255, 215, 0, 0.7);
            text-decoration: none;
        }

        .license-disclaimer a:hover {
            color: rgba(255, 215, 0, 1);
            text-decoration: underline;
        }

        .position-flow-viz {
            margin-top: 20px;
            border-top: 1px solid var(--border-color);
            padding-top: 15px;
        }

        .position-flow-viz h3 {
            margin-bottom: 10px;
            color: var(--yellow-color);
            font-size: 1.2rem;
        }

        .position-flow-container {
            width: 100%;
            height: 200px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            border: 1px solid var(--border-color);
            position: relative;
        }

        .position-flow-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--muted-color);
            text-align: center;
            font-size: 0.9rem;
            padding: 0 15px;
        }

        #position-flow-canvas {
            width: 100%;
            height: 100%;
        }

        .target-indicator {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }

        .target-indicator-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .target-indicator-dot.close {
            background-color: var(--yellow-color);
            box-shadow: 0 0 8px var(--yellow-color);
        }

        .target-indicator-dot.very-close {
            background-color: var(--green-color);
            box-shadow: 0 0 8px var(--green-color);
            animation: pulse-target 1.5s infinite;
        }

        .target-indicator-dot.reached {
            background-color: var(--green-color);
            box-shadow: 0 0 12px var(--green-color);
        }

        .target-indicator-text {
            font-size: 0.9rem;
        }

        @keyframes pulse-target {
            0% {
                box-shadow: 0 0 0 0 rgba(0, 181, 45, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(0, 181, 45, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(0, 181, 45, 0);
            }
        }

        .fib-level {
            display: inline-block;
            padding: 2px 10px;
            border-radius: 12px;
            background-color: rgba(255, 215, 0, 0.2);
            color: var(--yellow-color);
            font-size: 0.9rem;
            margin-right: 5px;
        }

        /* Redis Monitor Styles */
        .redis-monitor-card {
            margin-top: 20px;
        }

        .redis-monitor-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 15px;
        }

        .redis-stat {
            flex: 1;
            min-width: 150px;
        }

        .redis-keys-section {
            margin-top: 15px;
        }

        .redis-keys-container {
            max-height: 250px;
            overflow-y: auto;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            padding: 10px;
            margin-top: 10px;
        }

        .redis-keys-list {
            font-family: monospace;
        }

        .redis-namespace {
            margin-top: 8px;
            padding: 4px 8px;
            background-color: rgba(0, 40, 80, 0.3);
            border-radius: 3px;
            border-left: 3px solid #4a90e2;
        }

        .redis-namespace-name {
            color: #5dade2;
            font-weight: bold;
        }

        .redis-namespace-keys {
            padding-left: 10px;
            margin: 5px 0;
        }

        .redis-key-item {
            padding: 3px 8px;
            margin: 2px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
        }

        .redis-key-name {
            color: #bcd4e6;
            font-family: monospace;
            padding-right: 10px;
        }

        .redis-key-detail {
            color: #8899aa;
            font-size: 0.85em;
        }

        .redis-key-error {
            color: #ff6b6b;
            padding: 10px;
        }

        .redis-actions {
            margin-top: 15px;
            text-align: center;
        }

        .refresh-btn {
            background-color: #2c3e50;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .refresh-btn:hover {
            background-color: #3c536b;
        }

        .refresh-btn:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        .positive {
            color: #4caf50;
        }

        .negative {
            color: #f44336;
        }

        .neutral {
            color: #8899aa;
        }

        /* End of Redis Monitor Styles */

        .redis-key-loading {
            color: #8899aa;
            font-style: italic;
            text-align: center;
            padding: 10px;
        }

        .redis-namespace {
            margin-top: 8px;
            padding: 4px 8px;
            background-color: rgba(0, 40, 80, 0.3);
            border-radius: 3px;
            border-left: 3px solid #4a90e2;
        }

        .redis-namespace-name {
            color: #5dade2;
            font-weight: bold;
        }

        .redis-key-item {
            padding: 3px 8px;
            margin: 2px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
        }

        .redis-key-name {
            color: #bcd4e6;
            font-family: monospace;
            padding-right: 10px;
        }

        .redis-key-detail {
            color: #8899aa;
            font-size: 0.85em;
        }

        /* HODL Button Styles */
        .hodl-button {
            background: linear-gradient(to right, rgba(0, 181, 45, 0.8), rgba(255, 215, 0, 0.8), rgba(255, 61, 0, 0.8));
            color: white;
            border: none;
            border-radius: 25px;
            font-weight: bold;
            padding: 10px 20px;
            font-size: 1.1rem;
            margin-top: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .hodl-button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
        }

        .hodl-button:active {
            transform: translateY(1px);
        }

        .hodl-button i {
            font-size: 1.3rem;
        }

        /* BTC Price Popup */
        .btc-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background-color: var(--card-bg);
            border: 2px solid var(--yellow-color);
            border-radius: 15px;
            padding: 25px;
            z-index: 1000;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .btc-popup.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            visibility: visible;
        }

        .btc-popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .btc-popup-title {
            color: var(--yellow-color);
            font-size: 1.8rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .btc-popup-close {
            background: none;
            border: none;
            color: var(--muted-color);
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.3s;
        }

        .btc-popup-close:hover {
            color: var(--red-color);
        }

        .btc-popup-content {
            text-align: center;
        }

        .btc-popup-price {
            font-size: 3rem;
            color: var(--yellow-color);
            margin: 15px 0;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
            font-weight: bold;
        }

        .btc-popup-changes {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }

        .btc-popup-change {
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
        }

        .btc-popup-pattern {
            margin-top: 15px;
            padding: 10px;
            background-color: rgba(255, 215, 0, 0.1);
            border-radius: 10px;
            font-size: 1.1rem;
        }

        .btc-popup-time {
            margin-top: 20px;
            color: var(--muted-color);
            font-size: 0.9rem;
        }

        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .popup-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        @keyframes btc-pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        .pulse-animation {
            animation: btc-pulse 1s infinite;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1><i class="fa-brands fa-bitcoin"></i> OMEGA BTC AI REGGAE DASHBOARD</h1>
            <div class="price-ticker">
                <i class="btc-logo fa-brands fa-bitcoin"></i>
                <div id="btcPrice"></div>
                <div id="priceChanges">
                    <span id="shortTermChange"></span>
                    <span id="mediumTermChange"></span>
                </div>
                <div id="dominantPattern"></div>
                <div id="dataSource"></div>
                <div id="lastUpdated"></div>
            </div>
        </div>

        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot disconnected" id="status-dot"></div>
                <span id="status-text">Connecting to Redis...</span>
            </div>
            <div class="data-source" id="data-source">
                <i class="fas fa-database"></i>
                <span>Data Source: Initializing...</span>
            </div>
        </div>

        <div class="dashboard">
            <div class="card">
                <h2>
                    <i class="fas fa-chart-line"></i> TRAP PROBABILITY
                    <span class="refresh-time" id="trap-time">Updating...</span>
                </h2>
                <div class="data-row">
                    <span class="label">Probability:</span>
                    <span id="trap-probability" class="value neutral">0%</span>
                </div>
                <div class="data-row">
                    <span class="label">Type:</span>
                    <span id="trap-type" class="value neutral">Unknown</span>
                </div>
                <div class="data-row">
                    <span class="label">Trend:</span>
                    <span id="trap-trend" class="value neutral">Stable</span>
                </div>
                <div class="data-row">
                    <span class="label">Confidence:</span>
                    <span id="trap-confidence" class="value neutral">0%</span>
                </div>
                <div class="progress-bar">
                    <div id="trap-bar" class="progress-bar-inner" style="width: 0%"></div>
                </div>

                <h3>Components Analysis</h3>
                <div class="components-grid" id="trap-components">
                    <!-- Components will be inserted here -->
                </div>

                <div id="jah-message" class="jah-message">
                    JAH GUIDES THE TRADING PATH!
                </div>
            </div>

            <div class="card">
                <h2><i class="fas fa-chart-line"></i> Position Information <span class="refresh-time"
                        id="position-timestamp">--</span></h2>
                <div class="data-row">
                    <span class="label">Status:</span>
                    <span class="value neutral" id="position-status">No Position</span>
                </div>
                <div class="data-row">
                    <span class="label">Side:</span>
                    <span class="value neutral" id="position-side">--</span>
                </div>
                <div class="data-row">
                    <span class="label">Entry Price:</span>
                    <span class="value" id="entry-price">$0.00</span>
                </div>
                <div class="data-row">
                    <span class="label">Current Price:</span>
                    <span class="value" id="current-price">$0.00</span>
                </div>
                <div class="data-row">
                    <span class="label">Position Size:</span>
                    <span class="value" id="position-size">0.00 BTC</span>
                </div>
                <div class="data-row">
                    <span class="label">Leverage:</span>
                    <span class="value" id="position-leverage">0x</span>
                </div>
                <div class="data-row">
                    <span class="label">Risk Multiplier:</span>
                    <span class="value" id="risk-multiplier">1.00x</span>
                </div>
                <div class="data-row">
                    <span class="label">PnL:</span>
                    <span class="value neutral" id="pnl-percent">0.00%</span> / <span class="value neutral"
                        id="pnl-usd">$0.00</span>
                </div>
                <div class="data-row">
                    <span class="label">Stop Loss:</span>
                    <span class="value" id="stop-loss">$0.00</span>
                </div>
                <div class="data-row">
                    <span class="label">Take Profits:</span>
                    <span class="value" id="take-profits">--</span>
                </div>
                <div class="data-row">
                    <span class="label">Entry Time:</span>
                    <span class="value" id="entry-time">--</span>
                </div>
                <div class="data-row">
                    <span class="label">Source:</span>
                    <span class="value" id="position-source">--</span>
                </div>
            </div>

            <!-- Position Close Target Module -->
            <div class="card">
                <h2><i class="fas fa-bullseye"></i> Position Close Targets <span class="refresh-time"
                        id="target-timestamp">--</span></h2>
                <div class="data-row">
                    <span class="label">Target Status:</span>
                    <span class="value neutral" id="target-status">No Target</span>
                </div>
                <div class="data-row">
                    <span class="label">Next Target:</span>
                    <span class="value" id="next-target-price">$0.00</span>
                </div>
                <div class="data-row">
                    <span class="label">Next Target %:</span>
                    <span class="value neutral" id="next-target-percent">0.00%</span>
                </div>
                <div class="data-row">
                    <span class="label">Distance to Target:</span>
                    <span class="value" id="target-distance">0.00%</span>
                </div>
                <div class="data-row">
                    <span class="label">Est. Completion Time:</span>
                    <span class="value" id="target-eta">--</span>
                </div>
                <div class="data-row">
                    <span class="label">Fibonacci Level:</span>
                    <span class="value" id="fib-level">--</span>
                </div>

                <!-- Target Progress Bar -->
                <div class="label">Progress to Target:</div>
                <div class="progress-bar">
                    <div class="progress-bar-inner" id="target-progress-bar" style="width: 0%;"></div>
                </div>

                <!-- Position Flow Visualization -->
                <div class="position-flow-viz">
                    <h3>Position Flow</h3>
                    <div class="position-flow-container" id="position-flow-container">
                        <div class="position-flow-placeholder">Position flow visualization will appear here when a
                            position is active</div>
                        <canvas id="position-flow-canvas" width="100%" height="200"></canvas>
                    </div>
                </div>
            </div>

            <!-- Redis Debug Module -->
            <div class="card">
                <h2><i class="fas fa-database"></i> Redis Monitor <span class="refresh-time"
                        id="redis-monitor-timestamp">--</span></h2>

                <div class="data-row">
                    <span class="label">Connection Status:</span>
                    <span class="value neutral" id="redis-connection-status">Unknown</span>
                </div>

                <div class="data-row">
                    <span class="label">Last Updated:</span>
                    <span class="value" id="redis-last-updated">--</span>
                </div>

                <div class="data-row">
                    <span class="label">Active Keys:</span>
                    <span class="value" id="redis-active-keys">-</span>
                </div>

                <!-- Redis Keys List -->
                <h3>Recent Redis Keys</h3>
                <div class="redis-keys-container"
                    style="max-height: 200px; overflow-y: auto; margin-top: 10px; background-color: rgba(0,0,0,0.2); border-radius: 5px; padding: 10px;">
                    <div id="redis-keys-list">
                        <div class="redis-key-loading">Loading Redis keys...</div>
                    </div>
                </div>

                <button class="refresh-button" id="refresh-redis-info">
                    <i class="fas fa-sync-alt"></i> Refresh Redis Info
                </button>
            </div>
        </div>

        <div class="footer">
            <div>OMEGA BTC AI - Powered by Rastafarian wisdom & Modern AI</div>
            <div class="footer-icons">
                <i class="fa-brands fa-bitcoin"></i>
                <i class="fas fa-brain"></i>
                <i class="fas fa-chart-line"></i>
                <i class="fas fa-code"></i>
            </div>
            <button id="hodl-button" class="hodl-button">
                <i class="fa-brands fa-bitcoin"></i> CHECK BTC PRICE (HODL!)
            </button>
            <div>JAH LOVE ❤️ GUIDE THE WAY</div>
        </div>
    </div>

    <!-- BTC Price Popup -->
    <div id="popup-overlay" class="popup-overlay"></div>
    <div id="btc-popup" class="btc-popup">
        <div class="btc-popup-header">
            <div class="btc-popup-title">
                <i class="fa-brands fa-bitcoin"></i> Bitcoin Price
            </div>
            <button id="btc-popup-close" class="btc-popup-close">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="btc-popup-content">
            <div class="btc-popup-price" id="popup-price">$0.00</div>
            <div class="btc-popup-changes">
                <div class="btc-popup-change" id="popup-change">24h: 0.00%</div>
                <div class="btc-popup-change" id="popup-short-term">Short: 0.00%</div>
                <div class="btc-popup-change" id="popup-medium-term">Medium: 0.00%</div>
            </div>
            <div class="btc-popup-pattern" id="popup-pattern">
                Dominant Pattern: Unknown
            </div>
            <div class="btc-popup-time" id="popup-time">
                Last Updated: --
            </div>
        </div>
    </div>

    <!-- GNU License Disclaimer -->
    <div class="license-disclaimer">
        <p>OMEGA BTC AI - Copyright (C) 2024 OMEGA BTC AI Team</p>
        <p>This program is free software: you can redistribute it and/or modify
            it under the terms of the GNU General Public License as published by
            the Free Software Foundation, either version 3 of the License, or
            (at your option) any later version.</p>
        <p>This program is distributed in the hope that it will be useful,
            but WITHOUT ANY WARRANTY; without even the implied warranty of
            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
            GNU General Public License for more details.</p>
        <p>You should have received a copy of the GNU General Public License
            along with this program. If not, see <a href="https://www.gnu.org/licenses/"
                target="_blank">https://www.gnu.org/licenses/</a></p>
    </div>

    <script>
        // Debug helper
        const DEBUG = true; // Set to false to disable debug logs
        function debug(section, message, data = null) {
            if (!DEBUG) return;
            const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
            if (data) {
                console.log(`${timestamp} [${section}] ${message}`, data);
            } else {
                console.log(`${timestamp} [${section}] ${message}`);
            }
        }

        // API endpoints for Redis data
        const API_BASE = "http://localhost:8001/api";
        const TRAP_ENDPOINT = `${API_BASE}/trap-probability`;
        const POSITION_ENDPOINT = `${API_BASE}/position`;
        const BTC_PRICE_ENDPOINT = `${API_BASE}/btc-price`;
        const REDIS_KEYS_ENDPOINT = `${API_BASE}/redis-keys`;
        const COMBINED_DATA_ENDPOINT = `${API_BASE}/data`;
        const HEALTH_ENDPOINT = `${API_BASE}/health`;

        // Animation helper for UI feedback
        const animateElement = (elementId) => {
            const element = document.getElementById(elementId);
            if (element) {
                element.classList.add('shake');
                setTimeout(() => {
                    element.classList.remove('shake');
                }, 500);
            }
        };

        // Function to shake the JAH message for UI feedback
        const shakeJahMessage = () => {
            // Try with hyphen (HTML/CSS convention)
            let jahMessage = document.getElementById('jah-message');

            // Fallback to underscore if hyphen version not found
            if (!jahMessage) {
                jahMessage = document.getElementById('jah_message');
            }

            // If either version exists, apply the animation
            if (jahMessage) {
                jahMessage.classList.add('shake');
                setTimeout(() => {
                    jahMessage.classList.remove('shake');
                }, 500);
            } else {
                console.warn('JAH message element not found');
            }
        };

        // Format helpers
        const formatPrice = (num) => {
            if (num === undefined || num === null) return 'N/A';
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            }).format(num);
        };

        const formatPercent = (value) => {
            if (value === undefined || value === null) return 'N/A';
            // Convert decimal (0.024) to percentage (2.44%)
            const percent = value * 100;
            return `${percent >= 0 ? '+' : ''}${percent.toFixed(2)}%`;
        };

        // Helper function to fetch Redis key value with retries
        const fetchRedisKey = async (key, retries = 1) => {
            debug('REDIS', `Fetching Redis key value for: ${key}`);
            try {
                // Use the new direct Redis key access endpoint
                const response = await fetch(`${API_BASE}/redis-key?key=${encodeURIComponent(key)}`);
                if (!response.ok) {
                    throw new Error(`Failed to fetch Redis key ${key}: ${response.status}`);
                }

                const data = await response.json();
                debug('REDIS', `Received data for key ${key}:`, data);

                if (data.status === 'error') {
                    throw new Error(data.error || `Error fetching key ${key}`);
                }

                return data.value;
            } catch (error) {
                console.error(`Error fetching Redis key ${key}:`, error);
                if (retries > 0) {
                    debug('REDIS', `Retrying fetch for key ${key}, ${retries} retries left`);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    return fetchRedisKey(key, retries - 1);
                }
                return null;
            }
        };

        // Helper function to find the dominant pattern
        const findDominantPattern = (patterns) => {
            let dominantPattern = 'Unknown';
            let highestProb = 0;

            for (const [pattern, probability] of Object.entries(patterns)) {
                if (probability > highestProb) {
                    highestProb = probability;
                    dominantPattern = pattern;
                }
            }

            return dominantPattern;
        };

        // Helper function to find the highest probability
        const findHighestProbability = (patterns) => {
            let highestProb = 0;

            for (const probability of Object.values(patterns)) {
                if (probability > highestProb) {
                    highestProb = probability;
                }
            }

            return highestProb;
        };

        // Function to check Redis connection status
        const checkRedisStatus = async () => {
            try {
                const response = await fetch(HEALTH_ENDPOINT);
                if (!response.ok) {
                    return { connected: false, message: 'Backend connection failed' };
                }

                const data = await response.json();
                return {
                    connected: data.redis === 'connected',
                    message: data.redis === 'connected' ? 'Connected to Redis' : 'Redis connection issue'
                };
            } catch (error) {
                console.error('Error checking Redis status:', error);
                return { connected: false, message: 'Connection error' };
            }
        };

        // Function to update Redis debug information
        const updateRedisDebugInfo = async () => {
            const connectionStatusElement = document.getElementById('redis-connection-status');
            const lastUpdatedElement = document.getElementById('redis-last-updated');
            const activeKeysElement = document.getElementById('redis-active-keys');
            const keysListElement = document.getElementById('redis-keys-list');

            try {
                // Check Redis connection status
                const redisStatus = await checkRedisStatus();
                connectionStatusElement.textContent = redisStatus.connected ? 'Connected' : 'Disconnected';
                connectionStatusElement.className = redisStatus.connected ? 'value positive' : 'value negative';

                if (redisStatus.connected) {
                    // Fetch Redis keys to check what's available
                    const response = await fetch(REDIS_KEYS_ENDPOINT);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch Redis keys: ${response.status}`);
                    }

                    const keysData = await response.json();
                    debug('REDIS', 'Received Redis keys data:', keysData);

                    // Update keys count
                    if (keysData.total_keys) {
                        activeKeysElement.textContent = `${keysData.displayed_keys || 0}/${keysData.total_keys} keys`;
                    } else {
                        activeKeysElement.textContent = `${keysData.keys?.length || 0} keys`;
                    }

                    // Update keys list
                    if (keysListElement && keysData.keys && keysData.keys.length > 0) {
                        keysListElement.innerHTML = '';

                        // Group keys by namespace (first part before colon)
                        const keysByNamespace = {};
                        keysData.keys.forEach(keyInfo => {
                            const key = keyInfo.key;
                            const namespace = key.includes(':') ? key.split(':')[0] : 'other';

                            if (!keysByNamespace[namespace]) {
                                keysByNamespace[namespace] = [];
                            }

                            keysByNamespace[namespace].push(keyInfo);
                        });

                        // Create elements for each namespace
                        for (const [namespace, keys] of Object.entries(keysByNamespace)) {
                            const namespaceEl = document.createElement('div');
                            namespaceEl.className = 'redis-namespace';
                            namespaceEl.innerHTML = `<div class="redis-namespace-name">${namespace}</div>`;

                            const keysEl = document.createElement('div');
                            keysEl.className = 'redis-namespace-keys';

                            keys.forEach(keyInfo => {
                                const keyEl = document.createElement('div');
                                keyEl.className = 'redis-key-item';

                                let details = '';
                                if (keyInfo.type) {
                                    details += `type: ${keyInfo.type}`;
                                }
                                if (keyInfo.length !== undefined) {
                                    details += details ? ', ' : '';
                                    details += `length: ${keyInfo.length}`;
                                }
                                if (keyInfo.fields !== undefined) {
                                    details += details ? ', ' : '';
                                    details += `fields: ${keyInfo.fields}`;
                                }

                                keyEl.innerHTML = `
                                    <span class="redis-key-name">${keyInfo.key}</span>
                                    <span class="redis-key-detail">${details}</span>
                                `;

                                keysEl.appendChild(keyEl);
                            });

                            namespaceEl.appendChild(keysEl);
                            keysListElement.appendChild(namespaceEl);
                        }
                    } else {
                        keysListElement.innerHTML = '<div class="redis-key-error">No Redis keys found</div>';
                    }
                } else {
                    activeKeysElement.textContent = '0 keys';
                    keysListElement.innerHTML = `<div class="redis-key-error">Redis connection failed: ${redisStatus.message}</div>`;
                }

                // Update last updated timestamp
                lastUpdatedElement.textContent = new Date().toLocaleTimeString();

            } catch (error) {
                console.error('Error updating Redis debug info:', error);

                connectionStatusElement.textContent = 'Error';
                connectionStatusElement.className = 'value negative';
                activeKeysElement.textContent = 'Error';
                lastUpdatedElement.textContent = new Date().toLocaleTimeString();

                if (keysListElement) {
                    keysListElement.innerHTML = `<div class="redis-key-error">Error: ${error.message}</div>`;
                }
            }
        };

        // Function to update the BTC price ticker in the header
        const updateBTCPriceTicker = async () => {
            debug('PRICE_TICKER', 'Updating BTC price ticker in header');
            try {
                // Get BTC price data from Redis
                let price = null;
                // Try different possible keys for price data
                for (const priceKey of ['btc_price', 'last_btc_price', 'sim_last_btc_price']) {
                    price = await fetchRedisKey(priceKey);
                    if (price !== null) {
                        debug('PRICE', `Found BTC price in key: ${priceKey}`);
                        break;
                    }
                }

                if (price === null) {
                    throw new Error('Could not find BTC price in any Redis key');
                }

                // Get price changes data
                const changesData = await fetchRedisKey('btc_price_changes');

                // Get price patterns data
                const patternsData = await fetchRedisKey('btc_price_patterns');

                // Prepare the data object
                const data = {
                    price: typeof price === 'number' ? price : parseFloat(price),
                    shortTermChange: (changesData && changesData.short_term) ? changesData.short_term : 0,
                    mediumTermChange: (changesData && changesData.medium_term) ? changesData.medium_term : 0,
                    dominantPattern: findDominantPattern(patternsData || {}),
                    patterns: patternsData || {},
                    timestamp: new Date().toISOString()
                };

                // Update the price display in header
                const btcPrice = document.getElementById('btcPrice');
                if (btcPrice) {
                    btcPrice.textContent = formatPrice(data.price);
                    btcPrice.classList.add('btc-price');
                }

                // Update short-term and medium-term changes
                const shortTermElement = document.getElementById('shortTermChange');
                const mediumTermElement = document.getElementById('mediumTermChange');

                if (shortTermElement && data.shortTermChange !== null) {
                    shortTermElement.textContent = formatPercent(data.shortTermChange);
                    shortTermElement.className = data.shortTermChange >= 0 ? 'price-change positive' : 'price-change negative';
                }

                if (mediumTermElement && data.mediumTermChange !== null) {
                    mediumTermElement.textContent = formatPercent(data.mediumTermChange);
                    mediumTermElement.className = data.mediumTermChange >= 0 ? 'price-change positive' : 'price-change negative';
                }

                // Update dominant pattern
                const dominantPatternElement = document.getElementById('dominantPattern');
                if (dominantPatternElement && data.dominantPattern) {
                    // Capitalize pattern name
                    const capitalizedPattern = data.dominantPattern.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    dominantPatternElement.textContent = capitalizedPattern;
                }

                debug('PRICE_TICKER', 'BTC price ticker in header updated successfully');
            } catch (error) {
                console.error('Error updating BTC price ticker:', error);

                // Try using combined data endpoint as fallback
                try {
                    const response = await fetch(COMBINED_DATA_ENDPOINT);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch combined data: ${response.status}`);
                    }

                    const combinedData = await response.json();
                    if (combinedData.btc_price && combinedData.btc_price.price) {
                        const btcPrice = document.getElementById('btcPrice');
                        if (btcPrice) {
                            btcPrice.textContent = formatPrice(combinedData.btc_price.price);
                        }
                    }
                } catch (fallbackError) {
                    console.error('Fallback for BTC price also failed:', fallbackError);
                    const btcPrice = document.getElementById('btcPrice');
                    if (btcPrice) {
                        btcPrice.textContent = 'Price Unavailable';
                    }
                }
            }
        };

        // Wait for DOM to be fully loaded before setting up event handlers
        document.addEventListener('DOMContentLoaded', function () {
            debug('INIT', 'DOM fully loaded, initializing dashboard');

            // DOM Elements for reference
            const statusDot = document.getElementById('status-dot');
            const statusText = document.getElementById('status-text');
            const dataSource = document.getElementById('data-source').querySelector('span');
            const btcPrice = document.getElementById('btcPrice');
            const priceChange = document.getElementById('priceChanges');
            const trapTime = document.getElementById('trap-time');
            const positionTime = document.getElementById('position-time');
            const refreshButton = document.getElementById('refresh-data');

            // HODL Button elements
            const hodlButton = document.getElementById('hodl-button');
            const btcPopup = document.getElementById('btc-popup');
            const popupOverlay = document.getElementById('popup-overlay');
            const popupCloseBtn = document.getElementById('btc-popup-close');

            // Set up event handlers for the HODL button and popup
            if (hodlButton) {
                debug('INIT', 'Setting up HODL button event listener');
                hodlButton.addEventListener('click', function (e) {
                    debug('HODL', 'HODL button clicked');
                    e.preventDefault();
                    showBTCPrice();
                });
            } else {
                console.error('HODL button not found in the DOM');
            }

            // Set up popup close button event listener
            if (popupCloseBtn) {
                popupCloseBtn.addEventListener('click', function () {
                    debug('HODL', 'Popup close button clicked');
                    popupOverlay.classList.remove('show');
                    btcPopup.classList.remove('show');
                });
            }

            // Set up overlay event listener
            if (popupOverlay) {
                popupOverlay.addEventListener('click', function () {
                    debug('HODL', 'Popup overlay clicked');
                    popupOverlay.classList.remove('show');
                    btcPopup.classList.remove('show');
                });
            }

            // Initialize the dashboard with auto-refresh
            startAutoRefresh();

            debug('INIT', 'Event handlers set up');
        });

        // Function to update the trap probability card
        const updateTrapProbability = async () => {
            debug('TRAP', 'Updating trap probability card');

            // Get DOM elements
            const probabilityElement = document.getElementById('trap-probability');
            const typeElement = document.getElementById('trap-type');
            const trendElement = document.getElementById('trap-trend');
            const confidenceElement = document.getElementById('trap-confidence');
            const progressBar = document.getElementById('trap-bar');
            const componentsGrid = document.getElementById('trap-components');
            const jahMessage = document.getElementById('jah-message');
            const timeElement = document.getElementById('trap-time');

            try {
                // Try to fetch trap data directly from Redis
                const trapData = await fetchRedisKey('current_trap_probability');

                if (!trapData) {
                    // Fallback to API endpoint if Redis key not found
                    const response = await fetch(TRAP_ENDPOINT);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch trap data: ${response.status}`);
                    }
                    trapData = await response.json();
                }

                // Update UI with trap data
                if (trapData) {
                    debug('TRAP', 'Trap probability data:', trapData);

                    // Update probability
                    if (probabilityElement) {
                        const probability = trapData.probability || 0;
                        const probabilityPercent = Math.round(probability * 100);
                        probabilityElement.textContent = `${probabilityPercent}%`;

                        // Set color based on probability
                        probabilityElement.className = 'value';
                        if (probability >= 0.7) probabilityElement.classList.add('negative');
                        else if (probability >= 0.4) probabilityElement.classList.add('neutral');
                        else probabilityElement.classList.add('positive');

                        // Update progress bar
                        if (progressBar) {
                            progressBar.style.width = `${probabilityPercent}%`;
                        }
                    }

                    // Update trap type
                    if (typeElement && trapData.trap_type) {
                        // Format trap type for display
                        const formattedType = trapData.trap_type
                            .split('_')
                            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                            .join(' ');

                        typeElement.textContent = formattedType;
                    }

                    // Update trend
                    if (trendElement && trapData.trend) {
                        trendElement.textContent = trapData.trend;

                        // Set color based on trend
                        trendElement.className = 'value';
                        if (trapData.trend === 'increasing') trendElement.classList.add('negative');
                        else if (trapData.trend === 'decreasing') trendElement.classList.add('positive');
                        else trendElement.classList.add('neutral');
                    }

                    // Update confidence
                    if (confidenceElement && trapData.confidence) {
                        const confidencePercent = Math.round(trapData.confidence * 100);
                        confidenceElement.textContent = `${confidencePercent}%`;

                        // Set color based on confidence
                        confidenceElement.className = 'value';
                        if (trapData.confidence >= 0.8) confidenceElement.classList.add('positive');
                        else if (trapData.confidence >= 0.4) confidenceElement.classList.add('neutral');
                        else confidenceElement.classList.add('negative');
                    }

                    // Update components grid if available
                    if (componentsGrid && trapData.components) {
                        componentsGrid.innerHTML = ''; // Clear existing components

                        for (const [componentName, value] of Object.entries(trapData.components)) {
                            const componentDesc = trapData.descriptions?.[componentName] || `${componentName} factor`;

                            // Format name for display
                            const formattedName = componentName
                                .split('_')
                                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                                .join(' ');

                            // Create component element
                            const componentEl = document.createElement('div');
                            componentEl.className = 'component-item';

                            const percent = Math.round(value * 100);
                            componentEl.innerHTML = `
                                <div class="component-name">${formattedName}</div>
                                <div class="component-value">
                                    <span class="component-number">${percent}%</span>
                                    <div class="component-bar">
                                        <div class="component-bar-inner" style="width: ${percent}%"></div>
                                    </div>
                                </div>
                                <div class="component-description">${componentDesc}</div>
                            `;

                            componentsGrid.appendChild(componentEl);
                        }
                    }

                    // Update JAH message
                    if (jahMessage && trapData.message) {
                        jahMessage.textContent = trapData.message;
                        // Add animation
                        jahMessage.classList.add('shake');
                        setTimeout(() => {
                            jahMessage.classList.remove('shake');
                        }, 500);
                    }

                    // Update timestamp
                    if (timeElement && trapData.timestamp) {
                        timeElement.textContent = formatTimeDiff(trapData.timestamp);
                    }
                }
            } catch (error) {
                console.error('Error updating trap probability:', error);
                if (timeElement) {
                    timeElement.textContent = 'Update failed';
                }
            }
        };

        // Function to update the position information card
        const updatePositionInfo = async () => {
            debug('POSITION', 'Updating position information card');

            // Get DOM elements
            const statusElement = document.getElementById('position-status');
            const sideElement = document.getElementById('position-side');
            const entryPriceElement = document.getElementById('entry-price');
            const currentPriceElement = document.getElementById('current-price');
            const positionSizeElement = document.getElementById('position-size');
            const leverageElement = document.getElementById('position-leverage');
            const riskMultiplierElement = document.getElementById('risk-multiplier');
            const pnlPercentElement = document.getElementById('pnl-percent');
            const pnlUsdElement = document.getElementById('pnl-usd');
            const stopLossElement = document.getElementById('stop-loss');
            const takeProfitsElement = document.getElementById('take-profits');
            const entryTimeElement = document.getElementById('entry-time');
            const sourceElement = document.getElementById('position-source');
            const timestampElement = document.getElementById('position-timestamp');

            try {
                // Try to fetch position data directly from Redis
                let positionData = await fetchRedisKey('current_position');

                if (!positionData) {
                    // Fallback to API endpoint if Redis key not found
                    const response = await fetch(POSITION_ENDPOINT);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch position data: ${response.status}`);
                    }
                    positionData = await response.json();
                }

                // Update UI with position data
                if (positionData) {
                    debug('POSITION', 'Position data:', positionData);

                    // Update position status
                    if (statusElement) {
                        const hasPosition = positionData.has_position || false;
                        statusElement.textContent = hasPosition ? 'Active' : 'No Position';
                        statusElement.className = 'value';
                        statusElement.classList.add(hasPosition ? 'positive' : 'neutral');
                    }

                    // If there's an active position, update all fields
                    if (positionData.has_position) {
                        // Update position side
                        if (sideElement && positionData.position_side) {
                            sideElement.textContent = positionData.position_side.toUpperCase();
                            sideElement.className = 'value';
                            sideElement.classList.add(positionData.position_side === 'long' ? 'positive' : 'negative');
                        }

                        // Update entry price
                        if (entryPriceElement && positionData.entry_price) {
                            entryPriceElement.textContent = formatPrice(positionData.entry_price);
                        }

                        // Update current price
                        if (currentPriceElement && positionData.current_price) {
                            currentPriceElement.textContent = formatPrice(positionData.current_price);
                        }

                        // Update position size
                        if (positionSizeElement && positionData.position_size) {
                            positionSizeElement.textContent = `${positionData.position_size} BTC`;
                        }

                        // Update leverage
                        if (leverageElement && positionData.leverage) {
                            leverageElement.textContent = `${positionData.leverage}x`;
                        }

                        // Update risk multiplier
                        if (riskMultiplierElement && positionData.risk_multiplier) {
                            riskMultiplierElement.textContent = `${positionData.risk_multiplier.toFixed(2)}x`;
                        }

                        // Update PnL percent
                        if (pnlPercentElement && positionData.pnl_percent !== undefined) {
                            pnlPercentElement.textContent = `${positionData.pnl_percent.toFixed(2)}%`;
                            pnlPercentElement.className = 'value';
                            if (positionData.pnl_percent > 0) {
                                pnlPercentElement.classList.add('positive');
                            } else if (positionData.pnl_percent < 0) {
                                pnlPercentElement.classList.add('negative');
                            } else {
                                pnlPercentElement.classList.add('neutral');
                            }
                        }

                        // Update PnL USD
                        if (pnlUsdElement && positionData.pnl_usd !== undefined) {
                            pnlUsdElement.textContent = formatPrice(positionData.pnl_usd);
                            pnlUsdElement.className = 'value';
                            if (positionData.pnl_usd > 0) {
                                pnlUsdElement.classList.add('positive');
                            } else if (positionData.pnl_usd < 0) {
                                pnlUsdElement.classList.add('negative');
                            } else {
                                pnlUsdElement.classList.add('neutral');
                            }
                        }

                        // Update stop loss
                        if (stopLossElement && positionData.stop_loss) {
                            stopLossElement.textContent = formatPrice(positionData.stop_loss);
                        }

                        // Update take profits
                        if (takeProfitsElement && positionData.take_profits) {
                            // Format take profits for display
                            if (Array.isArray(positionData.take_profits)) {
                                const takeProfitsList = positionData.take_profits
                                    .map(tp => `${formatPrice(tp.price)} (${Math.round(tp.size * 100)}%)`)
                                    .join(', ');
                                takeProfitsElement.textContent = takeProfitsList;
                            } else {
                                takeProfitsElement.textContent = 'Not set';
                            }
                        }

                        // Update entry time
                        if (entryTimeElement && positionData.entry_time) {
                            // Format entry time
                            const entryDate = new Date(positionData.entry_time);
                            entryTimeElement.textContent = entryDate.toLocaleString();
                        }

                        // Update source
                        if (sourceElement && positionData.source) {
                            sourceElement.textContent = positionData.source;
                        }
                    } else {
                        // Reset fields if no position
                        if (sideElement) sideElement.textContent = '--';
                        if (entryPriceElement) entryPriceElement.textContent = '$0.00';
                        if (currentPriceElement) currentPriceElement.textContent = '$0.00';
                        if (positionSizeElement) positionSizeElement.textContent = '0.00 BTC';
                        if (leverageElement) leverageElement.textContent = '0x';
                        if (riskMultiplierElement) riskMultiplierElement.textContent = '1.00x';
                        if (pnlPercentElement) {
                            pnlPercentElement.textContent = '0.00%';
                            pnlPercentElement.className = 'value neutral';
                        }
                        if (pnlUsdElement) {
                            pnlUsdElement.textContent = '$0.00';
                            pnlUsdElement.className = 'value neutral';
                        }
                        if (stopLossElement) stopLossElement.textContent = '$0.00';
                        if (takeProfitsElement) takeProfitsElement.textContent = '--';
                        if (entryTimeElement) entryTimeElement.textContent = '--';
                        if (sourceElement) sourceElement.textContent = '--';
                    }

                    // Update timestamp
                    if (timestampElement && positionData.timestamp) {
                        timestampElement.textContent = formatTimeDiff(positionData.timestamp);
                    }
                }
            } catch (error) {
                console.error('Error updating position information:', error);
                if (timestampElement) {
                    timestampElement.textContent = 'Update failed';
                }
            }
        };

        // Function to update position close targets
        const updatePositionTargets = async () => {
            debug('TARGETS', 'Updating position close targets');

            // Get DOM elements
            const statusElement = document.getElementById('target-status');
            const nextTargetElement = document.getElementById('next-target-price');
            const targetPercentElement = document.getElementById('next-target-percent');
            const distanceElement = document.getElementById('target-distance');
            const etaElement = document.getElementById('target-eta');
            const fibLevelElement = document.getElementById('fib-level');
            const progressBar = document.getElementById('target-progress-bar');
            const timestampElement = document.getElementById('target-timestamp');

            try {
                // First update timestamp to show we're working
                if (timestampElement) {
                    timestampElement.textContent = 'Updating...';
                }

                // Try to fetch target data directly from Redis
                let targetData = await fetchRedisKey('position_targets');
                let generatedMockData = false;

                // If no targets data in Redis, try to create mock data based on position
                if (!targetData) {
                    debug('TARGETS', 'No position_targets in Redis, trying to generate mock data');
                    try {
                        // Get position data to create mock targets
                        const positionData = await fetchRedisKey('current_position');

                        if (positionData && positionData.has_position) {
                            debug('TARGETS', 'Found position data, generating mock targets');
                            // Get latest price data for accurate calculations
                            let currentPrice = 0;
                            try {
                                for (const priceKey of ['btc_price', 'last_btc_price', 'sim_last_btc_price']) {
                                    const price = await fetchRedisKey(priceKey);
                                    if (price !== null) {
                                        currentPrice = typeof price === 'number' ? price : parseFloat(price);
                                        debug('TARGETS', `Using current price from ${priceKey}: ${currentPrice}`);
                                        break;
                                    }
                                }
                            } catch (priceError) {
                                debug('TARGETS', `Error getting price data: ${priceError.message}`);
                                // Use position's current price as fallback
                                currentPrice = positionData.current_price || 0;
                            }

                            // Get position details for target calculation
                            const entryPrice = positionData.entry_price || currentPrice;
                            const isLong = (positionData.position_side || '').toLowerCase() === 'long';

                            // If we don't have both prices, use some defaults
                            if (!entryPrice || !currentPrice) {
                                debug('TARGETS', 'Missing price data, using defaults');
                                const defaultPrice = 65000; // Default BTC price if we can't get real data
                                currentPrice = currentPrice || defaultPrice;
                                const entryPrice = entryPrice || defaultPrice * 0.99; // 1% below default as a fallback
                            }

                            // Calculate targets based on position type
                            const targetPercent = isLong ? 0.05 : -0.05; // 5% target
                            const targetPrice = isLong
                                ? entryPrice * (1 + targetPercent)
                                : entryPrice * (1 - targetPercent);

                            // Calculate progress towards target
                            const priceDistance = isLong
                                ? (targetPrice - currentPrice) / targetPrice
                                : (currentPrice - targetPrice) / currentPrice;

                            // Ensure completion percent is between 0-100%
                            const completionPercent = Math.max(0, Math.min(1 - priceDistance, 1));

                            targetData = {
                                has_targets: true,
                                next_target: {
                                    price: targetPrice,
                                    percent: targetPercent,
                                    distance: priceDistance,
                                    eta_minutes: Math.round(priceDistance * 120), // Mock ETA
                                    completion_percent: completionPercent,
                                    fib_level: '0.382'
                                },
                                timestamp: new Date().toISOString()
                            };
                            generatedMockData = true;
                            debug('TARGETS', 'Generated mock target data:', targetData);
                        } else {
                            debug('TARGETS', 'No position data found, using empty targets');
                            // No position found, use empty targets
                            targetData = {
                                has_targets: false,
                                timestamp: new Date().toISOString()
                            };
                            generatedMockData = true;
                        }
                    } catch (mockDataError) {
                        debug('TARGETS', `Error generating mock data: ${mockDataError.message}`);
                        // If mock data generation fails, use empty data
                        targetData = {
                            has_targets: false,
                            error: mockDataError.message,
                            timestamp: new Date().toISOString()
                        };
                    }
                }

                // Update UI with target data - always update even if there are no targets
                if (targetData) {
                    debug('TARGETS', 'Position targets data:', targetData);

                    // Update target status
                    if (statusElement) {
                        const hasTargets = targetData.has_targets || false;
                        statusElement.textContent = hasTargets ? 'Active' : 'No Targets';
                        statusElement.className = 'value';
                        statusElement.classList.add(hasTargets ? 'positive' : 'neutral');
                    }

                    // If there are targets, update all fields
                    if (targetData.has_targets && targetData.next_target) {
                        const target = targetData.next_target;

                        // Update next target price
                        if (nextTargetElement && target.price) {
                            nextTargetElement.textContent = formatPrice(target.price);
                        }

                        // Update target percent
                        if (targetPercentElement && target.percent !== undefined) {
                            const percentValue = target.percent * 100;
                            targetPercentElement.textContent = `${percentValue.toFixed(2)}%`;
                            targetPercentElement.className = 'value';
                            if (percentValue > 0) {
                                targetPercentElement.classList.add('positive');
                            } else if (percentValue < 0) {
                                targetPercentElement.classList.add('negative');
                            } else {
                                targetPercentElement.classList.add('neutral');
                            }
                        }

                        // Update distance to target
                        if (distanceElement && target.distance !== undefined) {
                            const distancePercent = target.distance * 100;
                            distanceElement.textContent = `${distancePercent.toFixed(2)}%`;
                            distanceElement.className = 'value';

                            // Color based on how close we are (closer is better)
                            if (distancePercent < 2) {
                                distanceElement.classList.add('positive');
                            } else if (distancePercent < 5) {
                                distanceElement.classList.add('neutral');
                            } else {
                                distanceElement.classList.add('negative');
                            }
                        }

                        // Update ETA
                        if (etaElement && target.eta_minutes !== undefined) {
                            if (target.eta_minutes < 1) {
                                etaElement.textContent = 'Imminent';
                            } else if (target.eta_minutes < 60) {
                                etaElement.textContent = `~${target.eta_minutes} minutes`;
                            } else {
                                const hours = Math.floor(target.eta_minutes / 60);
                                etaElement.textContent = `~${hours} hour${hours > 1 ? 's' : ''}`;
                            }
                        }

                        // Update Fibonacci level
                        if (fibLevelElement && target.fib_level) {
                            fibLevelElement.textContent = target.fib_level;
                        }

                        // Update progress bar - crucial for displaying progress
                        if (progressBar && target.completion_percent !== undefined) {
                            const percent = target.completion_percent * 100;
                            progressBar.style.width = `${percent}%`;
                            debug('TARGETS', `Setting progress bar width to ${percent}%`);
                        }
                    } else {
                        // Reset fields if no targets
                        if (nextTargetElement) nextTargetElement.textContent = '$0.00';
                        if (targetPercentElement) {
                            targetPercentElement.textContent = '0.00%';
                            targetPercentElement.className = 'value neutral';
                        }
                        if (distanceElement) {
                            distanceElement.textContent = '0.00%';
                            distanceElement.className = 'value neutral';
                        }
                        if (etaElement) etaElement.textContent = '--';
                        if (fibLevelElement) fibLevelElement.textContent = '--';

                        // Always set progress bar to 0% when no targets available
                        if (progressBar) {
                            progressBar.style.width = '0%';
                            debug('TARGETS', 'Resetting progress bar to 0%');
                        }
                    }

                    // Update timestamp
                    if (timestampElement) {
                        if (targetData.timestamp) {
                            timestampElement.textContent = formatTimeDiff(targetData.timestamp);
                        } else {
                            timestampElement.textContent = 'Just now';
                        }

                        // Add indicator if this was generated data
                        if (generatedMockData) {
                            timestampElement.textContent += ' (mock)';
                        }
                    }
                }
            } catch (error) {
                console.error('Error updating position targets:', error);

                // Create fallback display values for error case
                if (statusElement) {
                    statusElement.textContent = 'No Targets';
                    statusElement.className = 'value neutral';
                }

                if (nextTargetElement) nextTargetElement.textContent = '$0.00';
                if (targetPercentElement) {
                    targetPercentElement.textContent = '0.00%';
                    targetPercentElement.className = 'value neutral';
                }
                if (distanceElement) {
                    distanceElement.textContent = '0.00%';
                    distanceElement.className = 'value neutral';
                }
                if (etaElement) etaElement.textContent = '--';
                if (fibLevelElement) fibLevelElement.textContent = '--';

                // Ensure progress bar is set to 0% in error case
                if (progressBar) {
                    progressBar.style.width = '0%';
                    debug('TARGETS', 'Resetting progress bar to 0% due to error');
                }

                if (timestampElement) {
                    const now = new Date();
                    timestampElement.textContent = `${now.toLocaleTimeString()} (error)`;
                }
            }
        };

        // Set up auto-refresh for all components
        const startAutoRefresh = () => {
            // Check connection status
            const updateConnectionStatus = async () => {
                try {
                    const response = await fetch(HEALTH_ENDPOINT);
                    if (!response.ok) {
                        throw new Error(`Health check failed: ${response.status}`);
                    }

                    const healthData = await response.json();
                    const isConnected = healthData.redis === 'connected';

                    // Update status indicator
                    const statusDot = document.getElementById('status-dot');
                    const statusText = document.getElementById('status-text');

                    if (statusDot) {
                        statusDot.className = isConnected ? 'status-dot connected' : 'status-dot disconnected';
                    }

                    if (statusText) {
                        statusText.textContent = isConnected ? 'Connected to Redis' : 'Disconnected from Redis';
                    }

                    // Update data source 
                    const dataSourceEl = document.getElementById('data-source');
                    if (dataSourceEl) {
                        const dataSourceSpan = dataSourceEl.querySelector('span');
                        if (dataSourceSpan) {
                            dataSourceSpan.textContent = `Data Source: ${isConnected ? 'Redis' : 'Fallback'}`;
                        }
                    }

                    return isConnected;
                } catch (error) {
                    console.error('Error checking connection status:', error);

                    // Update status to disconnected
                    const statusDot = document.getElementById('status-dot');
                    const statusText = document.getElementById('status-text');

                    if (statusDot) {
                        statusDot.className = 'status-dot disconnected';
                    }

                    if (statusText) {
                        statusText.textContent = 'Connection Error';
                    }

                    return false;
                }
            };

            // Initial updates
            const initializeDashboard = async () => {
                const isConnected = await updateConnectionStatus();
                debug('INIT', `Initial connection status: ${isConnected ? 'Connected' : 'Disconnected'}`);

                // Fetch initial data
                updateBTCPriceTicker();
                updateTrapProbability();
                updatePositionInfo();
                updatePositionTargets();
                updateRedisDebugInfo();

                // Set up refresh intervals

                // Every 5 seconds:
                setInterval(() => {
                    updateBTCPriceTicker();
                    updateConnectionStatus();
                }, 5000);

                // Every 10 seconds:
                setInterval(() => {
                    updateTrapProbability();
                    updatePositionInfo();
                    updatePositionTargets();
                }, 10000);

                // Every 30 seconds:
                setInterval(() => {
                    updateRedisDebugInfo();
                }, 30000);

                debug('INIT', 'Auto-refresh intervals set up');
            };

            // Start the dashboard
            initializeDashboard();
        };

        // Start auto-refresh when document is ready
        startAutoRefresh();

        // Function to display BTC price popup
        const showBTCPrice = async () => {
            debug('HODL', 'Showing BTC price popup');
            const popupOverlay = document.getElementById('popup-overlay');
            const btcPopup = document.getElementById('btc-popup');
            const popupPrice = document.getElementById('popup-price');
            const popupChange = document.getElementById('popup-change');
            const popupShortTerm = document.getElementById('popup-short-term');
            const popupMediumTerm = document.getElementById('popup-medium-term');
            const popupPattern = document.getElementById('popup-pattern');
            const popupTime = document.getElementById('popup-time');

            // Show popup with loading state
            popupOverlay.classList.add('show');
            btcPopup.classList.add('show');

            if (popupPrice) popupPrice.innerHTML = 'Loading...';
            if (popupPattern) popupPattern.innerHTML = 'Checking patterns...';

            try {
                // Try to fetch the current BTC price from Redis
                let price = null;
                // Try different possible keys for price data
                for (const priceKey of ['btc_price', 'last_btc_price', 'sim_last_btc_price']) {
                    price = await fetchRedisKey(priceKey);
                    if (price !== null) {
                        debug('HODL', `Found BTC price in key: ${priceKey}`);
                        break;
                    }
                }

                if (price === null) {
                    throw new Error('Could not find BTC price in any Redis key');
                }

                // Get price changes data
                const changesData = await fetchRedisKey('btc_price_changes');

                // Get price patterns data
                const patternsData = await fetchRedisKey('btc_price_patterns');

                // Prepare the normalized data object
                const priceData = {
                    price: typeof price === 'number' ? price : parseFloat(price),
                    change: 0, // 24h change (not available in Redis currently)
                    shortTermChange: (changesData && changesData.short_term) ? changesData.short_term : 0,
                    mediumTermChange: (changesData && changesData.medium_term) ? changesData.medium_term : 0,
                    dominantPattern: findDominantPattern(patternsData || {}),
                    dominantPatternProbability: findHighestProbability(patternsData || {}),
                    patterns: patternsData || {},
                    timestamp: new Date().toISOString()
                };

                debug('HODL', 'BTC price data for popup:', priceData);

                // Update popup content
                if (popupPrice) {
                    popupPrice.innerHTML = formatPrice(priceData.price);
                    popupPrice.classList.add('pulse-animation');
                    setTimeout(() => popupPrice.classList.remove('pulse-animation'), 2000);
                }

                // Update 24h change
                if (popupChange) {
                    const change = priceData.change || 0;
                    popupChange.innerHTML = `24h: ${formatPercent(change)}`;
                    popupChange.className = 'btc-popup-change';
                    if (change > 0) popupChange.classList.add('positive');
                    else if (change < 0) popupChange.classList.add('negative');
                    else popupChange.classList.add('neutral');
                }

                // Update short-term change
                if (popupShortTerm) {
                    const shortChange = priceData.shortTermChange || 0;
                    popupShortTerm.innerHTML = `Short: ${formatPercent(shortChange)}`;
                    popupShortTerm.className = 'btc-popup-change';
                    if (shortChange > 0) popupShortTerm.classList.add('positive');
                    else if (shortChange < 0) popupShortTerm.classList.add('negative');
                    else popupShortTerm.classList.add('neutral');
                }

                // Update medium-term change
                if (popupMediumTerm) {
                    const mediumChange = priceData.mediumTermChange || 0;
                    popupMediumTerm.innerHTML = `Medium: ${formatPercent(mediumChange)}`;
                    popupMediumTerm.className = 'btc-popup-change';
                    if (mediumChange > 0) popupMediumTerm.classList.add('positive');
                    else if (mediumChange < 0) popupMediumTerm.classList.add('negative');
                    else popupMediumTerm.classList.add('neutral');
                }

                // Update pattern
                if (popupPattern) {
                    const pattern = priceData.dominantPattern || 'Unknown';
                    const probability = priceData.dominantPatternProbability || 0;

                    // Format pattern name for display
                    const patternName = pattern
                        .split('_')
                        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                        .join(' ');

                    popupPattern.innerHTML = `Dominant Pattern: ${patternName} (${Math.round(probability * 100)}%)`;
                }

                // Update time
                if (popupTime) {
                    popupTime.innerHTML = `Last Updated: ${new Date().toLocaleTimeString()}`;
                }

                // Shake the popup for emphasis
                btcPopup.classList.add('shake');
                setTimeout(() => btcPopup.classList.remove('shake'), 500);

                // Trigger JAH message animation for added effect
                shakeJahMessage();
            } catch (error) {
                console.error('Error showing BTC price:', error);

                // Try fallback to the combined data endpoint
                try {
                    const response = await fetch(COMBINED_DATA_ENDPOINT);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch combined data: ${response.status}`);
                    }

                    const combinedData = await response.json();
                    const btcData = combinedData.btc_price;

                    if (btcData && btcData.price) {
                        // Update popup with available data
                        if (popupPrice) {
                            popupPrice.innerHTML = formatPrice(btcData.price);
                        }

                        if (popupPattern) {
                            popupPattern.innerHTML = 'Pattern data not available';
                        }

                        if (popupTime) {
                            popupTime.innerHTML = `Last Updated: ${new Date().toLocaleTimeString()}`;
                        }
                    } else {
                        throw new Error('No price data in combined endpoint');
                    }
                } catch (fallbackError) {
                    console.error('Error with fallback data source:', fallbackError);

                    // Show error state
                    if (popupPrice) popupPrice.innerHTML = 'Error loading price';
                    if (popupPattern) popupPattern.innerHTML = 'Could not load pattern data';

                    // Shake the popup to indicate error
                    btcPopup.classList.add('shake');
                    setTimeout(() => btcPopup.classList.remove('shake'), 500);
                }
            }
        };
    </script>
</body>

</html>